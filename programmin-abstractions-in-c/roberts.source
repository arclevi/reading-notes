#!/bin/sh
# This is a shell archive (produced by GNU sharutils 4.1).
# To extract the files from this archive, save it to some FILE, remove
# everything before the `!/bin/sh' line above, then type `sh FILE'.
#
# Made on 1997-09-06 10:03 PDT by <eroberts@Eeyore.stanford.edu>.
# Source directory was `/u1/eroberts/books/programming-abstractions-in-c'.
#
# Existing files will *not* be overwritten unless `-c' is specified.
#
# This shar contains:
# length mode       name
# ------ ---------- ------------------------------------------
#    751 -rw-r--r-- programs/01-Overview-of-ANSI-C/addlist.c
#    513 -rw-r--r-- programs/01-Overview-of-ANSI-C/average3.c
#   5680 -rw-r--r-- programs/01-Overview-of-ANSI-C/calendar.c
#    772 -rw-r--r-- programs/01-Overview-of-ANSI-C/digitsum.c
#    817 -rw-r--r-- programs/01-Overview-of-ANSI-C/isvowel.c
#    260 -rw-r--r-- programs/01-Overview-of-ANSI-C/liftoff.c
#    440 -rw-r--r-- programs/01-Overview-of-ANSI-C/oddeven.c
#   1051 -rw-r--r-- programs/01-Overview-of-ANSI-C/powertab.c
#   1961 -rw-r--r-- programs/01-Overview-of-ANSI-C/Makefile
#   3534 -rw-r--r-- programs/02-Data-Types-in-C/employee.c
#   2101 -rw-r--r-- programs/02-Data-Types-in-C/gymjudge.c
#   2339 -rw-r--r-- programs/02-Data-Types-in-C/quadeq.c
#   1314 -rw-r--r-- programs/02-Data-Types-in-C/Makefile
#   1864 -rw-r--r-- programs/03-Libraries-and-Interfaces/copyfile.c
#   2537 -rw-r--r-- programs/03-Libraries-and-Interfaces/craps.c
#    926 -rw-r--r-- programs/03-Libraries-and-Interfaces/flipcoin.c
#    128 -rw-r--r-- programs/03-Libraries-and-Interfaces/jabber.txt
#   2195 -rw-r--r-- programs/03-Libraries-and-Interfaces/linecopy.c
#   2968 -rw-r--r-- programs/03-Libraries-and-Interfaces/pigword1.c
#   2435 -rw-r--r-- programs/03-Libraries-and-Interfaces/pigword2.c
#   1751 -rw-r--r-- programs/03-Libraries-and-Interfaces/random.c
#   1454 -rw-r--r-- programs/03-Libraries-and-Interfaces/random.h
#    460 -rw-r--r-- programs/03-Libraries-and-Interfaces/randtest.c
#   2138 -rw-r--r-- programs/03-Libraries-and-Interfaces/remcom.c
#   1289 -rw-r--r-- programs/03-Libraries-and-Interfaces/spcount.c
#   2195 -rw-r--r-- programs/03-Libraries-and-Interfaces/Makefile
#   4770 -rw-r--r-- programs/04-Introduction-to-Recursion/bsearch.c
#   1011 -rw-r--r-- programs/04-Introduction-to-Recursion/fact.c
#   1734 -rw-r--r-- programs/04-Introduction-to-Recursion/fastfib.c
#    901 -rw-r--r-- programs/04-Introduction-to-Recursion/fib.c
#    952 -rw-r--r-- programs/04-Introduction-to-Recursion/ifact.c
#   1567 -rw-r--r-- programs/04-Introduction-to-Recursion/oddeven.c
#   1410 -rw-r--r-- programs/04-Introduction-to-Recursion/palin.c
#   2097 -rw-r--r-- programs/04-Introduction-to-Recursion/palin2.c
#   1840 -rw-r--r-- programs/04-Introduction-to-Recursion/Makefile
#    430 -rw-r--r-- programs/05-Recursive-Procedures/archway.c
#   1592 -rw-r--r-- programs/05-Recursive-Procedures/hanoi.c
#   2731 -rw-r--r-- programs/05-Recursive-Procedures/koch.c
#   2499 -rw-r--r-- programs/05-Recursive-Procedures/mondrian.c
#   2029 -rw-r--r-- programs/05-Recursive-Procedures/permute.c
#   1527 -rw-r--r-- programs/05-Recursive-Procedures/Makefile
#    240 -rw-r--r-- programs/06-Backtracking-Algorithms/example.maz
#   2053 -rw-r--r-- programs/06-Backtracking-Algorithms/maze.c
#   2428 -rw-r--r-- programs/06-Backtracking-Algorithms/mazelib.h
#   6173 -rw-r--r-- programs/06-Backtracking-Algorithms/nim.c
#  15726 -rw-r--r-- programs/06-Backtracking-Algorithms/tictac.c
#   1342 -rw-r--r-- programs/06-Backtracking-Algorithms/Makefile
#  12103 -rw-rw-r-- programs/06-Backtracking-Algorithms/mazelib.c
#   2471 -rw-r--r-- programs/07-Algorithmic-Analysis/msort.c
#   1845 -rw-r--r-- programs/07-Algorithmic-Analysis/qsort.c
#    656 -rw-r--r-- programs/07-Algorithmic-Analysis/sort.h
#   1085 -rw-r--r-- programs/07-Algorithmic-Analysis/ssort.c
#   2402 -rw-r--r-- programs/07-Algorithmic-Analysis/testsort.c
#   1419 -rw-r--r-- programs/07-Algorithmic-Analysis/Makefile
#   3478 -rw-r--r-- programs/08-Abstract-Data-Types/rpncalc.c
#   4137 -rw-r--r-- programs/08-Abstract-Data-Types/scanadt.c
#   5000 -rw-r--r-- programs/08-Abstract-Data-Types/scanadt.h
#   2785 -rw-r--r-- programs/08-Abstract-Data-Types/stack.c
#   3186 -rw-r--r-- programs/08-Abstract-Data-Types/stack.h
#    616 -rw-r--r-- programs/08-Abstract-Data-Types/testscan.c
#   1364 -rw-r--r-- programs/08-Abstract-Data-Types/Makefile
#   2397 -rw-r--r-- programs/09-Efficiency-and-ADTs/arraybuf.c
#   2538 -rw-r--r-- programs/09-Efficiency-and-ADTs/buffer.h
#   2173 -rw-r--r-- programs/09-Efficiency-and-ADTs/editor.c
#   3125 -rw-r--r-- programs/09-Efficiency-and-ADTs/listbuf.c
#   2785 -rw-r--r-- programs/09-Efficiency-and-ADTs/stack.c
#   3182 -rw-r--r-- programs/09-Efficiency-and-ADTs/stack.h
#   2467 -rw-r--r-- programs/09-Efficiency-and-ADTs/stackbuf.c
#   1579 -rw-r--r-- programs/09-Efficiency-and-ADTs/Makefile
#   7458 -rw-r--r-- programs/10-Linear-Structures/checkout.c
#     19 -rw-r--r-- programs/10-Linear-Structures/dstack.c
#   2589 -rw-r--r-- programs/10-Linear-Structures/qarray.c
#   2329 -rw-r--r-- programs/10-Linear-Structures/qlist.c
#   2412 -rw-r--r-- programs/10-Linear-Structures/qtest.c
#   2957 -rw-r--r-- programs/10-Linear-Structures/queue.h
#   3461 -rw-r--r-- programs/10-Linear-Structures/rpncalc.c
#  10928 -rw-r--r-- programs/10-Linear-Structures/scanadt.c
#   7862 -rw-r--r-- programs/10-Linear-Structures/scanadt.h
#   1839 -rw-r--r-- programs/10-Linear-Structures/stack.c
#   3186 -rw-r--r-- programs/10-Linear-Structures/stack.h
#   1821 -rw-r--r-- programs/10-Linear-Structures/Makefile
#   2320 -rw-r--r-- programs/11-Symbol-Tables/cmddisp.c
#   2430 -rw-r--r-- programs/11-Symbol-Tables/cmpfn.c
#   1347 -rw-r--r-- programs/11-Symbol-Tables/cmpfn.h
#   3530 -rw-r--r-- programs/11-Symbol-Tables/dumpfreq.c
#   2595 -rw-r--r-- programs/11-Symbol-Tables/iterator.c
#   1527 -rw-r--r-- programs/11-Symbol-Tables/iterator.h
#     79 -rw-r--r-- programs/11-Symbol-Tables/macbeth.txt
#   3013 -rw-r--r-- programs/11-Symbol-Tables/mapfreq.c
#   1531 -rw-r--r-- programs/11-Symbol-Tables/plot.c
#  10929 -rw-r--r-- programs/11-Symbol-Tables/scanadt.c
#   7881 -rw-r--r-- programs/11-Symbol-Tables/scanadt.h
#   5312 -rw-r--r-- programs/11-Symbol-Tables/sorttest.c
#   3983 -rw-r--r-- programs/11-Symbol-Tables/symtab.c
#   2165 -rw-r--r-- programs/11-Symbol-Tables/symtab.h
#   1528 -rw-r--r-- programs/11-Symbol-Tables/symtest.c
#   2545 -rw-r--r-- programs/11-Symbol-Tables/wordfreq.c
#   2361 -rw-r--r-- programs/11-Symbol-Tables/Makefile
#   1082 -rw-r--r-- programs/12-Recursive-Lists/bigfact.c
#   5184 -rw-r--r-- programs/12-Recursive-Lists/bigint.c
#   1714 -rw-r--r-- programs/12-Recursive-Lists/bigint.h
#   1075 -rw-r--r-- programs/12-Recursive-Lists/list.c
#   1793 -rw-r--r-- programs/12-Recursive-Lists/list.h
#   8842 -rw-r--r-- programs/12-Recursive-Lists/listtest.c
#  10928 -rw-r--r-- programs/12-Recursive-Lists/scanadt.c
#   7862 -rw-r--r-- programs/12-Recursive-Lists/scanadt.h
#   1438 -rw-r--r-- programs/12-Recursive-Lists/Makefile
#   7002 -rw-r--r-- programs/13-Trees/avltree.c
#   7517 -rw-r--r-- programs/13-Trees/bst.c
#   4878 -rw-r--r-- programs/13-Trees/bst.h
#   2675 -rw-r--r-- programs/13-Trees/bsttab.c
#   2067 -rw-r--r-- programs/13-Trees/bsttest.c
#   2658 -rw-r--r-- programs/13-Trees/cmpfn.c
#   1402 -rw-r--r-- programs/13-Trees/cmpfn.h
#    295 -rw-r--r-- programs/13-Trees/elements.dat
#   4556 -rw-r--r-- programs/13-Trees/introbst.c
#  10928 -rw-r--r-- programs/13-Trees/scanadt.c
#   7862 -rw-r--r-- programs/13-Trees/scanadt.h
#   2504 -rw-r--r-- programs/13-Trees/symtab.h
#   3287 -rw-r--r-- programs/13-Trees/symtest.c
#   2076 -rw-r--r-- programs/13-Trees/Makefile
#   2581 -rw-r--r-- programs/13-Trees/cmdscan.c
#   4248 -rw-r--r-- programs/13-Trees/cmdscan.h
#   2595 -rw-r--r-- programs/13-Trees/iterator.c
#   1527 -rw-r--r-- programs/13-Trees/iterator.h
#   3983 -rw-r--r-- programs/13-Trees/symtab.c
#   1682 -rw-r--r-- programs/14-Expression-Trees/eval.c
#   1222 -rw-r--r-- programs/14-Expression-Trees/eval.h
#   2505 -rw-r--r-- programs/14-Expression-Trees/exp.c
#   3322 -rw-r--r-- programs/14-Expression-Trees/exp.h
#    837 -rw-r--r-- programs/14-Expression-Trees/interp.c
#   3889 -rw-r--r-- programs/14-Expression-Trees/iverson.c
#   3687 -rw-r--r-- programs/14-Expression-Trees/parser.c
#   1320 -rw-r--r-- programs/14-Expression-Trees/parser.h
#  10928 -rw-r--r-- programs/14-Expression-Trees/scanadt.c
#   7862 -rw-r--r-- programs/14-Expression-Trees/scanadt.h
#   4897 -rw-r--r-- programs/14-Expression-Trees/symtab.c
#   2504 -rw-r--r-- programs/14-Expression-Trees/symtab.h
#   1583 -rw-r--r-- programs/14-Expression-Trees/Makefile
#   7517 -rw-r--r-- programs/15-Sets/bst.c
#   4877 -rw-r--r-- programs/15-Sets/bst.h
#   2658 -rw-r--r-- programs/15-Sets/cmpfn.c
#   1402 -rw-r--r-- programs/15-Sets/cmpfn.h
#   2888 -rw-r--r-- programs/15-Sets/cvecset.c
#   3757 -rw-r--r-- programs/15-Sets/cvector.c
#   1372 -rw-r--r-- programs/15-Sets/cvector.h
#   4556 -rw-r--r-- programs/15-Sets/iterator.c
#   1531 -rw-r--r-- programs/15-Sets/iterator.h
#   3324 -rw-r--r-- programs/15-Sets/itertype.h
#   2209 -rw-r--r-- programs/15-Sets/permute.c
#   9887 -rw-r--r-- programs/15-Sets/set.c
#   6341 -rw-r--r-- programs/15-Sets/set.h
#   2260 -rw-r--r-- programs/15-Sets/settest.c
#   1530 -rw-r--r-- programs/15-Sets/strtest.c
#   2363 -rw-r--r-- programs/15-Sets/Makefile
#   1138 -rw-r--r-- programs/15-Sets/foreach.c
#    908 -rw-r--r-- programs/15-Sets/foreach.h
#   2307 -rw-r--r-- programs/16-Graphs/adjmat-graph.c
#   7517 -rw-r--r-- programs/16-Graphs/bst.c
#   4878 -rw-r--r-- programs/16-Graphs/bst.h
#   2581 -rw-r--r-- programs/16-Graphs/cmdscan.c
#   4248 -rw-r--r-- programs/16-Graphs/cmdscan.h
#   2658 -rw-r--r-- programs/16-Graphs/cmpfn.c
#   1402 -rw-r--r-- programs/16-Graphs/cmpfn.h
#   1138 -rw-r--r-- programs/16-Graphs/foreach.c
#    908 -rw-r--r-- programs/16-Graphs/foreach.h
#   3922 -rw-r--r-- programs/16-Graphs/graph.c
#   4665 -rw-r--r-- programs/16-Graphs/graph.h
#   7238 -rw-rw-r-- programs/16-Graphs/gtest.c
#   4556 -rw-r--r-- programs/16-Graphs/iterator.c
#   1531 -rw-r--r-- programs/16-Graphs/iterator.h
#   3324 -rw-r--r-- programs/16-Graphs/itertype.h
#   1075 -rw-r--r-- programs/16-Graphs/list.c
#   1793 -rw-r--r-- programs/16-Graphs/list.h
#  10928 -rw-r--r-- programs/16-Graphs/scanadt.c
#   7862 -rw-r--r-- programs/16-Graphs/scanadt.h
#   9887 -rw-r--r-- programs/16-Graphs/set.c
#   6341 -rw-r--r-- programs/16-Graphs/set.h
#   1583 -rw-r--r-- programs/16-Graphs/simple-graph.c
#   1146 -rw-r--r-- programs/16-Graphs/simple-graph.h
#   4897 -rw-r--r-- programs/16-Graphs/symtab.c
#   2504 -rw-r--r-- programs/16-Graphs/symtab.h
#   2112 -rw-r--r-- programs/16-Graphs/Makefile
#
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  echo 'WARNING: not restoring timestamps.  Consider getting and'
  echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
# ============= programs/01-Overview-of-ANSI-C/addlist.c ==============
if test ! -d 'programs'; then
  echo 'x - creating directory programs'
  mkdir 'programs'
fi
if test ! -d 'programs/01-Overview-of-ANSI-C'; then
  echo 'x - creating directory programs/01-Overview-of-ANSI-C'
  mkdir 'programs/01-Overview-of-ANSI-C'
fi
if test -f 'programs/01-Overview-of-ANSI-C/addlist.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/01-Overview-of-ANSI-C/addlist.c (file already exists)'
else
  echo 'x - extracting programs/01-Overview-of-ANSI-C/addlist.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/01-Overview-of-ANSI-C/addlist.c' &&
/*
X * File: addlist.c
X * ---------------
X * This program adds a list of numbers.  The end of the
X * input is indicated by entering a sentinel value, which
X * is defined by setting the value of the constant Sentinel.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "simpio.h"
X
/*
X * Constants
X * ---------
X * Sentinel -- Value that terminates the input list
X */
X
#define Sentinel 0
X
/* Main program */
X
main()
{
X    int value, total;
X
X    printf("This program adds a list of numbers.\n");
X    printf("Use %d to signal the end of list.\n", Sentinel);
X    total = 0;
X    while (TRUE) {
X        printf(" ? ");
X        value = GetInteger();
X        if (value == Sentinel) break;
X        total += value;
X    }
X    printf("The total is %d\n", total);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/01-Overview-of-ANSI-C/addlist.c' &&
  chmod 0644 'programs/01-Overview-of-ANSI-C/addlist.c' ||
  echo 'restore of programs/01-Overview-of-ANSI-C/addlist.c failed'
  shar_count="`wc -c < 'programs/01-Overview-of-ANSI-C/addlist.c'`"
  test 751 -eq "$shar_count" ||
    echo "programs/01-Overview-of-ANSI-C/addlist.c: original size 751, current size $shar_count"
fi
# ============= programs/01-Overview-of-ANSI-C/average3.c ==============
if test -f 'programs/01-Overview-of-ANSI-C/average3.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/01-Overview-of-ANSI-C/average3.c (file already exists)'
else
  echo 'x - extracting programs/01-Overview-of-ANSI-C/average3.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/01-Overview-of-ANSI-C/average3.c' &&
/*
X * File: average3.c
X * ----------------
X * This program reads in three floating-point numbers and
X * computes their average.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "simpio.h"
X
main()
{
X    double n1, n2, n3, average;
X
X    printf("This program averages three numbers.\n");
X    printf("1st number: ");
X    n1 = GetReal();
X    printf("2nd number: ");
X    n2 = GetReal();
X    printf("3nd number: ");
X    n3 = GetReal();
X    average = (n1 + n2 + n3) / 3;
X    printf("The average is %g\n", average);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/01-Overview-of-ANSI-C/average3.c' &&
  chmod 0644 'programs/01-Overview-of-ANSI-C/average3.c' ||
  echo 'restore of programs/01-Overview-of-ANSI-C/average3.c failed'
  shar_count="`wc -c < 'programs/01-Overview-of-ANSI-C/average3.c'`"
  test 513 -eq "$shar_count" ||
    echo "programs/01-Overview-of-ANSI-C/average3.c: original size 513, current size $shar_count"
fi
# ============= programs/01-Overview-of-ANSI-C/calendar.c ==============
if test -f 'programs/01-Overview-of-ANSI-C/calendar.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/01-Overview-of-ANSI-C/calendar.c (file already exists)'
else
  echo 'x - extracting programs/01-Overview-of-ANSI-C/calendar.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/01-Overview-of-ANSI-C/calendar.c' &&
/*
X * File: calendar.c
X * ----------------
X * This program is used to generate a calendar for a year
X * entered by the user.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "simpio.h"
X
/*
X * Constants
X * ---------
X * The definitions introduce symbolic names for the days
X * of the week are the months of the year.
X */
X
#define Sunday     0
#define Monday     1
#define Tuesday    2
#define Wednesday  3
#define Thursday   4
#define Friday     5
#define Saturday   6
X
#define January    1
#define February   2
#define March      3
#define April      4
#define May        5
#define June       6
#define July       7
#define August     8
#define September  9
#define October   10
#define November  11
#define December  12
X
/* Function prototypes */
X
void GiveInstructions(void);
int GetYearFromUser(void);
void PrintCalendar(int year);
void PrintCalendarMonth(int month, int year);
void IndentFirstLine(int weekday);
int MonthDays(int month, int year);
int FirstDayOfMonth(int month, int year);
string MonthName(int month);
bool IsLeapYear(int year);
void MonthTest(void);
X
void MonthTest(void)
{
X    int month;
X
X    for (month = 1; month <= 12; month++) {
X        printf("%-10s %2d\n", MonthName(month), MonthDays(month, 1996));
X    }
}
X
/* Main program */
X
main()
{
X    int year;
X
X    GiveInstructions();
X    year = GetYearFromUser();
X    PrintCalendar(year);
}
X
/*
X * Function: GiveInstructions
X * Usage: GiveInstructions();
X * --------------------------
X * This procedure prints out instructions to the user.
X */
X
void GiveInstructions(void)
{
X    printf("This program displays a calendar for a full\n");
X    printf("year.  The year must not be before 1900.\n");
}
X
/*
X * Function: GetYearFromUser
X * Usage: year = GetYearFromUser();
X * --------------------------------
X * This function reads in a year from the user and returns
X * that value.  If the user enters a year before 1900, the
X * function gives the user another chance.
X */
X
int GetYearFromUser(void)
{
X    int year;
X
X    while (TRUE) {
X        printf("Which year? ");
X        year = GetInteger();
X        if (year >= 1900) return (year);
X        printf("The year must be at least 1900.\n");
X    }
}
X
/*
X * Function: PrintCalendar
X * Usage: PrintCalendar(year);
X * ---------------------------
X * This procedure prints a calendar for an entire year.
X */
X
void PrintCalendar(int year)
{
X    int month;
X
X    for (month = 1; month <= 12; month++) {
X        PrintCalendarMonth(month, year);
X        printf("\n");
X    }
}
X
/*
X * Function: PrintCalendarMonth
X * Usage: PrintCalendarMonth(month, year);
X * ---------------------------------------
X * This procedure prints a calendar for the given month
X * and year.
X */
X
void PrintCalendarMonth(int month, int year)
{
X    int weekday, nDays, day;
X
X    printf("    %s %d\n", MonthName(month), year);
X    printf(" Su Mo Tu We Th Fr Sa\n");
X    nDays = MonthDays(month, year);
X    weekday = FirstDayOfMonth(month, year);
X    IndentFirstLine(weekday);
X    for (day = 1; day <= nDays; day++) {
X        printf(" %2d", day);
X        if (weekday == Saturday) printf("\n");
X        weekday = (weekday + 1) % 7;
X    }
X    if (weekday != Sunday) printf("\n");
}
X
/*
X * Function: IndentFirstLine
X * Usage: IndentFirstLine(weekday);
X * --------------------------------
X * This procedure indents the first line of the calendar
X * by printing enough blank spaces to get to the position
X * on the line corresponding to weekday.
X */
X
void IndentFirstLine(int weekday)
{
X    int i;
X
X    for (i = 0; i < weekday; i++) {
X        printf("   ");
X    }
}
X
/*
X * Function: MonthDays
X * Usage: ndays = MonthDays(month, year);
X * --------------------------------------
X * MonthDays returns the number of days in the indicated
X * month and year.  The year is required to handle leap years.
X */
X
int MonthDays(int month, int year)
{
X    switch (month) {
X      case September:
X      case April:
X      case June:
X      case November:
X        return (30);
X      case February:
X        return ((IsLeapYear(year)) ? 29 : 28);
X      default:
X        return (31);
X    }
}
X
/*
X * Function: FirstDayOfMonth
X * Usage: weekday = FirstDayOfMonth(month, year);
X * ----------------------------------------------
X * This function returns the day of the week on which the
X * indicated month begins.  This program simply counts
X * forward from January 1, 1900, which was a Monday.
X */
X
int FirstDayOfMonth(int month, int year)
{
X    int weekday, i;
X
X    weekday = Monday;
X    for (i = 1900; i < year; i++) {
X        weekday = (weekday + 365) % 7;
X        if (IsLeapYear(i)) weekday = (weekday + 1) % 7;
X    }
X    for (i = 1; i < month; i++) {
X        weekday = (weekday + MonthDays(i, year)) % 7;
X    }
X    return (weekday);
}
X
/*
X * Function: MonthName
X * Usage: name = MonthName(month);
X * -------------------------------
X * MonthName converts a numeric month in the range 1-12
X * into the string name for that month.
X */
X
string MonthName(int month)
{
X    switch (month) {
X      case  1: return ("January");
X      case  2: return ("February");
X      case  3: return ("March");
X      case  4: return ("April");
X      case  5: return ("May");
X      case  6: return ("June");
X      case  7: return ("July");
X      case  8: return ("August");
X      case  9: return ("September");
X      case 10: return ("October");
X      case 11: return ("November");
X      case 12: return ("December");
X      default: return ("Illegal month");
X    }
}
X
/*
X * Function: IsLeapYear
X * Usage: if (IsLeapYear(year)) . . .
X * ----------------------------------
X * This function returns TRUE if year is a leap year.
X */
X
bool IsLeapYear(int year)
{
X    return ( ((year % 4 == 0) && (year % 100 != 0))
X             || (year % 400 == 0) );
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/01-Overview-of-ANSI-C/calendar.c' &&
  chmod 0644 'programs/01-Overview-of-ANSI-C/calendar.c' ||
  echo 'restore of programs/01-Overview-of-ANSI-C/calendar.c failed'
  shar_count="`wc -c < 'programs/01-Overview-of-ANSI-C/calendar.c'`"
  test 5680 -eq "$shar_count" ||
    echo "programs/01-Overview-of-ANSI-C/calendar.c: original size 5680, current size $shar_count"
fi
# ============= programs/01-Overview-of-ANSI-C/digitsum.c ==============
if test -f 'programs/01-Overview-of-ANSI-C/digitsum.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/01-Overview-of-ANSI-C/digitsum.c (file already exists)'
else
  echo 'x - extracting programs/01-Overview-of-ANSI-C/digitsum.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/01-Overview-of-ANSI-C/digitsum.c' &&
/*
X * File: digitsum.c
X * ----------------
X * This program sums the digits in a nonnegative integer.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "simpio.h"
X
/* Function prototypes */
X
static int DigitSum(int n);
X
/* Main program */
X
main()
{
X    int n;
X
X    printf("This program sums the digits in an integer.\n");
X    printf("Enter a nonnegative integer: ");
X    n = GetInteger();
X    printf("The sum of the digits is %d\n", DigitSum(n));
}
X
/*
X * Function: DigitSum
X * Usage: sum = DigitSum(n);
X * -------------------------
X * This function returns the sum of the digits in n, where n
X * is a nonnegative integer.
X */
X
static int DigitSum(int n)
{
X    int sum;
X
X    sum = 0;
X    while (n > 0) {
X        sum += n % 10;
X        n /= 10;
X    }
X    return (sum);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/01-Overview-of-ANSI-C/digitsum.c' &&
  chmod 0644 'programs/01-Overview-of-ANSI-C/digitsum.c' ||
  echo 'restore of programs/01-Overview-of-ANSI-C/digitsum.c failed'
  shar_count="`wc -c < 'programs/01-Overview-of-ANSI-C/digitsum.c'`"
  test 772 -eq "$shar_count" ||
    echo "programs/01-Overview-of-ANSI-C/digitsum.c: original size 772, current size $shar_count"
fi
# ============= programs/01-Overview-of-ANSI-C/isvowel.c ==============
if test -f 'programs/01-Overview-of-ANSI-C/isvowel.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/01-Overview-of-ANSI-C/isvowel.c (file already exists)'
else
  echo 'x - extracting programs/01-Overview-of-ANSI-C/isvowel.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/01-Overview-of-ANSI-C/isvowel.c' &&
/*
X * File: isvowel.c
X * ---------------
X * This file defines the predicate function IsVowel.
X */
X
#include <stdio.h>
#include "genlib.h"
X
/* Private function prototypes */
X
static bool IsVowel(char ch);
X
/* Main program */
X
main()
{
X    char ch;
X
X    printf("The vowels are:");
X    for (ch = 'A'; ch <= 'Z'; ch++) {
X        if (IsVowel(ch)) printf(" %c", ch);
X    }
X    printf("\n");
}
X
/*
X * Function: IsVowel
X * Usage: if (IsVowel(ch)) . . .
X * -----------------------------
X * This function returns TRUE if ch is a vowel, which are
X * recognized in either upper or lower case.
X */
X
static bool IsVowel(char ch)
{
X    switch (ch) {
X      case 'A': case 'E': case 'I': case 'O': case 'U':
X      case 'a': case 'e': case 'i': case 'o': case 'u':
X        return (TRUE);
X      default:
X        return (FALSE);
X    }
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/01-Overview-of-ANSI-C/isvowel.c' &&
  chmod 0644 'programs/01-Overview-of-ANSI-C/isvowel.c' ||
  echo 'restore of programs/01-Overview-of-ANSI-C/isvowel.c failed'
  shar_count="`wc -c < 'programs/01-Overview-of-ANSI-C/isvowel.c'`"
  test 817 -eq "$shar_count" ||
    echo "programs/01-Overview-of-ANSI-C/isvowel.c: original size 817, current size $shar_count"
fi
# ============= programs/01-Overview-of-ANSI-C/liftoff.c ==============
if test -f 'programs/01-Overview-of-ANSI-C/liftoff.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/01-Overview-of-ANSI-C/liftoff.c (file already exists)'
else
  echo 'x - extracting programs/01-Overview-of-ANSI-C/liftoff.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/01-Overview-of-ANSI-C/liftoff.c' &&
/*
X * File: liftoff.c
X * ---------------
X * This program simulates a countdown for a rocket launch.
X */
X
#include <stdio.h>
#include "genlib.h"
X
main()
{
X    int t;
X
X    for (t = 10; t >= 0; t--) {
X        printf("%2d\n", t);
X    }
X    printf("Liftoff!\n");
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/01-Overview-of-ANSI-C/liftoff.c' &&
  chmod 0644 'programs/01-Overview-of-ANSI-C/liftoff.c' ||
  echo 'restore of programs/01-Overview-of-ANSI-C/liftoff.c failed'
  shar_count="`wc -c < 'programs/01-Overview-of-ANSI-C/liftoff.c'`"
  test 260 -eq "$shar_count" ||
    echo "programs/01-Overview-of-ANSI-C/liftoff.c: original size 260, current size $shar_count"
fi
# ============= programs/01-Overview-of-ANSI-C/oddeven.c ==============
if test -f 'programs/01-Overview-of-ANSI-C/oddeven.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/01-Overview-of-ANSI-C/oddeven.c (file already exists)'
else
  echo 'x - extracting programs/01-Overview-of-ANSI-C/oddeven.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/01-Overview-of-ANSI-C/oddeven.c' &&
/*
X * File: oddeven.c
X * ---------------
X * This program reads in a number and classifies it
X * as even or odd.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "simpio.h"
X
main()
{
X    int n;
X
X    printf("This program labels a number as even or odd.\n");
X    printf("Enter a number: ");
X    n = GetInteger();
X    if (n % 2 == 0) {
X        printf("That number is even.\n");
X    } else {
X        printf("That number is odd.\n");
X    }
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/01-Overview-of-ANSI-C/oddeven.c' &&
  chmod 0644 'programs/01-Overview-of-ANSI-C/oddeven.c' ||
  echo 'restore of programs/01-Overview-of-ANSI-C/oddeven.c failed'
  shar_count="`wc -c < 'programs/01-Overview-of-ANSI-C/oddeven.c'`"
  test 440 -eq "$shar_count" ||
    echo "programs/01-Overview-of-ANSI-C/oddeven.c: original size 440, current size $shar_count"
fi
# ============= programs/01-Overview-of-ANSI-C/powertab.c ==============
if test -f 'programs/01-Overview-of-ANSI-C/powertab.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/01-Overview-of-ANSI-C/powertab.c (file already exists)'
else
  echo 'x - extracting programs/01-Overview-of-ANSI-C/powertab.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/01-Overview-of-ANSI-C/powertab.c' &&
/*
X * File: powertab.c
X * ----------------
X * This program generates a table comparing values
X * of the functions n^2 and 2^n.
X */
X
#include <stdio.h>
#include "genlib.h"
X
/*
X * Constants
X * ---------
X * LowerLimit -- Starting value for the table
X * UpperLimit -- Final value for the table
X */
X
#define LowerLimit  0
#define UpperLimit 12
X
/* Private function prototypes */
X
static int RaiseIntToPower(int n, int k);
X
/* Main program */
X
main()
{
X    int n;
X
X    printf("    |   2 |    N\n");
X    printf("  N |  N  |   2\n");
X    printf("----+-----+------\n");
X    for (n = LowerLimit; n <= UpperLimit; n++) {
X        printf(" %2d | %3d | %4d\n", n,
X               RaiseIntToPower(n, 2),
X               RaiseIntToPower(2, n));
X    }
}
X
/*
X * Function: RaiseIntToPower
X * Usage: p = RaiseIntToPower(n, k);
X * ---------------------------------
X * This function returns n to the kth power.
X */
X
static int RaiseIntToPower(int n, int k)
{
X    int i, result;
X
X    result = 1;
X    for (i = 0; i < k; i++) {
X        result *= n;
X    }
X    return (result);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/01-Overview-of-ANSI-C/powertab.c' &&
  chmod 0644 'programs/01-Overview-of-ANSI-C/powertab.c' ||
  echo 'restore of programs/01-Overview-of-ANSI-C/powertab.c failed'
  shar_count="`wc -c < 'programs/01-Overview-of-ANSI-C/powertab.c'`"
  test 1051 -eq "$shar_count" ||
    echo "programs/01-Overview-of-ANSI-C/powertab.c: original size 1051, current size $shar_count"
fi
# ============= programs/01-Overview-of-ANSI-C/Makefile ==============
if test -f 'programs/01-Overview-of-ANSI-C/Makefile' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/01-Overview-of-ANSI-C/Makefile (file already exists)'
else
  echo 'x - extracting programs/01-Overview-of-ANSI-C/Makefile (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/01-Overview-of-ANSI-C/Makefile' &&
# Makefile for programs in directory 01-Overview-of-ANSI-C
# ***************************************************************
X
PROGRAMS = \
X    addlist \
X    average3 \
X    calendar \
X    digitsum \
X    isvowel \
X    liftoff \
X    oddeven \
X    powertab
X
# ***************************************************************
# Parameters to control Makefile operation
# Note that the gccx command script must be defined
X
CC = gccx
CFLAGS = 
X
# ***************************************************************
# Entry to bring the package up to date
X
all: $(PROGRAMS)
X
# ***************************************************************
# Standard entries to remove files from the directories
#    tidy    -- eliminate unwanted files
#    scratch -- delete derived files in preparation for rebuild
X
tidy:
X	rm -f ,* .,* *~ core a.out graphics.ps
X
scratch: tidy
X	rm -f *.o *.a $(PROGRAMS)
X
# ***************************************************************
# C compilations
X
addlist.o: addlist.c
X	$(CC) $(CFLAGS) -c addlist.c
X
average3.o: average3.c
X	$(CC) $(CFLAGS) -c average3.c
X
calendar.o: calendar.c
X	$(CC) $(CFLAGS) -c calendar.c
X
digitsum.o: digitsum.c
X	$(CC) $(CFLAGS) -c digitsum.c
X
isvowel.o: isvowel.c
X	$(CC) $(CFLAGS) -c isvowel.c
X
liftoff.o: liftoff.c
X	$(CC) $(CFLAGS) -c liftoff.c
X
oddeven.o: oddeven.c
X	$(CC) $(CFLAGS) -c oddeven.c
X
powertab.o: powertab.c
X	$(CC) $(CFLAGS) -c powertab.c
X
X
# ***************************************************************
# Executable programs
X
addlist: addlist.o
X	$(CC) $(CFLAGS) -o addlist addlist.o
X
average3: average3.o
X	$(CC) $(CFLAGS) -o average3 average3.o
X
calendar: calendar.o
X	$(CC) $(CFLAGS) -o calendar calendar.o
X
digitsum: digitsum.o
X	$(CC) $(CFLAGS) -o digitsum digitsum.o
X
isvowel: isvowel.o
X	$(CC) $(CFLAGS) -o isvowel isvowel.o
X
liftoff: liftoff.o
X	$(CC) $(CFLAGS) -o liftoff liftoff.o
X
oddeven: oddeven.o
X	$(CC) $(CFLAGS) -o oddeven oddeven.o
X
powertab: powertab.o
X	$(CC) $(CFLAGS) -o powertab powertab.o
X
SHAR_EOF
  $shar_touch -am 0905205197 'programs/01-Overview-of-ANSI-C/Makefile' &&
  chmod 0644 'programs/01-Overview-of-ANSI-C/Makefile' ||
  echo 'restore of programs/01-Overview-of-ANSI-C/Makefile failed'
  shar_count="`wc -c < 'programs/01-Overview-of-ANSI-C/Makefile'`"
  test 1961 -eq "$shar_count" ||
    echo "programs/01-Overview-of-ANSI-C/Makefile: original size 1961, current size $shar_count"
fi
# ============= programs/02-Data-Types-in-C/employee.c ==============
if test ! -d 'programs/02-Data-Types-in-C'; then
  echo 'x - creating directory programs/02-Data-Types-in-C'
  mkdir 'programs/02-Data-Types-in-C'
fi
if test -f 'programs/02-Data-Types-in-C/employee.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/02-Data-Types-in-C/employee.c (file already exists)'
else
  echo 'x - extracting programs/02-Data-Types-in-C/employee.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/02-Data-Types-in-C/employee.c' &&
/*
X * File: employee.c
X * ----------------
X * This program tests the functions defined for records of type
X * employeeRecordT and employeeT.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "strlib.h"
#include "simpio.h"
X
/*
X * Constants
X * ---------
X * MaxEmployees -- Maximum number of employees
X */
X
#define MaxEmployees 100
X
/*
X * Type: employeeRecordT
X * ---------------------
X * This structure defines a type for an employee record.
X */
X
typedef struct {
X    string name;
X    string title;
X    string ssnum;
X    double salary;
X    int withholding;
} employeeRecordT;
X
/*
X * Type: employeeT
X * ---------------
X * This type definition introduces an employeeT as a
X * pointer to the same record type as before.
X */
X
typedef struct {
X    string name;
X    string title;
X    string ssnum;
X    double salary;
X    int withholding;
} *employeeT;
X
/*
X * Type: payrollT
X * --------------
X * This type represents an entire collection of employees.  The
X * type definition uses a dynamic array of employeeT values to
X * ensure that there is no maximum bound imposed by the type.
X * The cost of this design is that the programmer must explicitly
X * allocate the storage for the array using NewArray.
X */
X
typedef struct {
X    employeeT *employees;
X    int nEmployees;
} *payrollT;
X
/*
X * Global variables
X * ----------------
X * staff       -- Array of employees
X * nEmployees  -- Number of employees
X * manager     -- Used to produce a figure for the code
X */
X
static employeeRecordT staff[MaxEmployees];
static int nEmployees;
X
static employeeRecordT manager = {
X    "Ebenezer Scrooge", "Partner", "271-82-8183", 250.00, 1
};
X
/* Private function declarations */
X
static void InitEmployeeTable(void);
static payrollT CreatePayroll(employeeRecordT staff[], int nEmployees);
static void ListEmployees(payrollT payroll);
static double AverageSalary(payrollT payroll);
X
/* Main program */
X
main()
{
X    payrollT payroll;
X
X    InitEmployeeTable();
X    payroll = CreatePayroll(staff, nEmployees);
X    ListEmployees(payroll);
}
X
static void InitEmployeeTable(void)
{
X    employeeRecordT empRec;
X
X    empRec.name = "Ebenezer Scrooge";
X    empRec.title = "Partner";
X    empRec.ssnum = "271-82-8183";
X    empRec.salary = 250.00;
X    empRec.withholding = 1;
X    staff[0] = empRec;
X    empRec.name = "Bob Cratchit";
X    empRec.title = "Clerk";
X    empRec.ssnum = "314-15-9265";
X    empRec.salary = 15.00;
X    empRec.withholding = 7;
X    staff[1] = empRec;
X    nEmployees = 2;
}
X
static payrollT CreatePayroll(employeeRecordT staff[], int nEmployees)
{
X    payrollT payroll;
X    int i;
X
X    payroll = New(payrollT);
X    payroll->employees = NewArray(nEmployees, employeeT);
X    payroll->nEmployees = nEmployees;
X    for (i = 0; i < nEmployees; i++) {
X        payroll->employees[i] = New(employeeT);
X        payroll->employees[i]->name = staff[i].name;
X        payroll->employees[i]->title = staff[i].title;
X        payroll->employees[i]->ssnum = staff[i].ssnum;
X        payroll->employees[i]->salary = staff[i].salary;
X        payroll->employees[i]->withholding = staff[i].withholding;
X    }
X    return (payroll);
}
X
static void ListEmployees(payrollT payroll)
{
X    int i;
X
X    for (i = 0; i < payroll->nEmployees; i++) {
X        printf("%s (%s)\n", payroll->employees[i]->name, payroll->employees[i]->title);
X    }
}
X
static double AverageSalary(payrollT payroll)
{
X    double total;
X    int i;
X
X    total = 0;
X    for (i = 0; i < payroll->nEmployees; i++) {
X        total += payroll->employees[i]->salary;
X    }
X    return (total / nEmployees);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/02-Data-Types-in-C/employee.c' &&
  chmod 0644 'programs/02-Data-Types-in-C/employee.c' ||
  echo 'restore of programs/02-Data-Types-in-C/employee.c failed'
  shar_count="`wc -c < 'programs/02-Data-Types-in-C/employee.c'`"
  test 3534 -eq "$shar_count" ||
    echo "programs/02-Data-Types-in-C/employee.c: original size 3534, current size $shar_count"
fi
# ============= programs/02-Data-Types-in-C/gymjudge.c ==============
if test -f 'programs/02-Data-Types-in-C/gymjudge.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/02-Data-Types-in-C/gymjudge.c (file already exists)'
else
  echo 'x - extracting programs/02-Data-Types-in-C/gymjudge.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/02-Data-Types-in-C/gymjudge.c' &&
/*
X * File: gymjudge.c
X * ----------------
X * This program averages a set of gymnastic scores.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "simpio.h"
X
/* Constants */
X
#define MaxJudges 100
#define MinScore    0.0
#define MaxScore   10.0
X
/* Private function prototypes */
X
static void ReadAllScores(double scores[], int nJudges);
static double GetScore(int judge);
double Mean(double array[], int n);
X
/* Main program */
X
main()
{
X    double scores[MaxJudges];
X    int nJudges;
X
X    printf("Enter number of judges: ");
X    nJudges = GetInteger();
X    if (nJudges > MaxJudges) Error("Too many judges");
X    ReadAllScores(scores, nJudges);
X    printf("The average score is %.2f\n", Mean(scores, nJudges));
}
X
/*
X * Function: ReadAllScores
X * Usage: ReadAllScores(scores, nJudges);
X * --------------------------------------
X * This function reads in scores for each of the judges.  The
X * array scores must be declared by the caller and must have
X * an allocated size that is at least as large as nJudges.
X */
X
static void ReadAllScores(double scores[], int nJudges)
{
X    int i;
X
X    for (i = 0; i < nJudges; i++) {
X        scores[i] = GetScore(i);
X    }
}
X
/*
X * Function: GetScore
X * Usage: score = GetScore(judge);
X * -------------------------------
X * This function reads in the score for the specified judge.
X * The implementation makes sure that the score is in the
X * legal range before returning.
X */
X
static double GetScore(int judge)
{
X    double score;
X
X    while (TRUE) {
X        printf("Score for judge #%d: ", judge);
X        score = GetReal();
X        if (score >= MinScore && score <= MaxScore) break;
X        printf("That score is out of range.  Try again.\n");
X    }
X    return (score);
}
X
/*
X * Function: Mean
X * Usage: mean = Mean(array, n);
X * -----------------------------
X * This function returns the statistical mean (average) of a
X * distribution stored in array, which has effective size n.
X */
X
double Mean(double array[], int n)
{
X    int i;
X    double total;
X
X    total = 0;
X    for (i = 0; i < n; i++) {
X        total += array[i];
X    }
X    return (total / n);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/02-Data-Types-in-C/gymjudge.c' &&
  chmod 0644 'programs/02-Data-Types-in-C/gymjudge.c' ||
  echo 'restore of programs/02-Data-Types-in-C/gymjudge.c failed'
  shar_count="`wc -c < 'programs/02-Data-Types-in-C/gymjudge.c'`"
  test 2101 -eq "$shar_count" ||
    echo "programs/02-Data-Types-in-C/gymjudge.c: original size 2101, current size $shar_count"
fi
# ============= programs/02-Data-Types-in-C/quadeq.c ==============
if test -f 'programs/02-Data-Types-in-C/quadeq.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/02-Data-Types-in-C/quadeq.c (file already exists)'
else
  echo 'x - extracting programs/02-Data-Types-in-C/quadeq.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/02-Data-Types-in-C/quadeq.c' &&
/*
X * File: quadeq.c
X * --------------
X * This program finds roots of the quadratic equation
X *
X *         2
X *     a x    +  b x  +  c  =  0
X */
X
#include <stdio.h>
#include <math.h>
#include "genlib.h"
#include "simpio.h"
X
/* Private function prototypes */
X
static void GetCoefficients(double *pa, double *pb, double *pc);
static void SolveQuadratic(double a, double b, double c,
X                           double *px1, double *px2);
static void DisplayRoots(double x1, double x2);
X
/* Main program */
X
main()
{
X    double a, b, c, x1, x2;
X
X    GetCoefficients(&a, &b, &c);
X    SolveQuadratic(a, b, c, &x1, &x2);
X    DisplayRoots(x1, x2);
}
X
/*
X * Function: GetCoefficients
X * Usage: GetCoefficients(&a, &b, &c);
X * -----------------------------------
X * This function is responsible for reading in the coefficients
X * of a quadratic equation.  The values of the coefficients are
X * passed back to the main program in the variables a, b, and c,
X * which are passed by reference.
X */
X
static void GetCoefficients(double *pa, double *pb, double *pc)
{
X    printf("Enter coefficients for the quadratic equation:\n");
X    printf("a: ");
X    *pa = GetReal();
X    printf("b: ");
X    *pb = GetReal();
X    printf("c: ");
X    *pc = GetReal();
}
X
/*
X * Function: SolveQuadratic
X * Usage: SolveQuadratic(a, b, c, &x1, &x2);
X * -----------------------------------------
X * This function solves a quadratic equation.  The coefficients
X * are supplied as the arguments a, b, and c, and the roots are
X * returned in x1 and x2, which are passed by reference.
X */
X
static void SolveQuadratic(double a, double b, double c,
X                           double *px1, double *px2)
{
X    double disc, sqrtDisc;
X
X    if (a == 0) Error("The coefficient a must be nonzero");
X    disc = b * b - 4 * a * c;
X    if (disc < 0) Error("The solutions are complex numbers");
X    sqrtDisc = sqrt(disc);
X    *px1 = (-b + sqrtDisc) / (2 * a);
X    *px2 = (-b - sqrtDisc) / (2 * a);
}
X
/*
X * Function: DisplayRoots
X * Usage: DisplayRoots(x1, x2);
X * ----------------------------
X * This function displays the values x1 and x2, which are
X * the roots of a quadratic equation.
X */
X
static void DisplayRoots(double x1, double x2)
{
X    if (x1 == x2) {
X        printf("There is a double root at %g\n", x1);
X    } else {
X        printf("The roots are %g and %g\n", x1, x2);
X    }
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/02-Data-Types-in-C/quadeq.c' &&
  chmod 0644 'programs/02-Data-Types-in-C/quadeq.c' ||
  echo 'restore of programs/02-Data-Types-in-C/quadeq.c failed'
  shar_count="`wc -c < 'programs/02-Data-Types-in-C/quadeq.c'`"
  test 2339 -eq "$shar_count" ||
    echo "programs/02-Data-Types-in-C/quadeq.c: original size 2339, current size $shar_count"
fi
# ============= programs/02-Data-Types-in-C/Makefile ==============
if test -f 'programs/02-Data-Types-in-C/Makefile' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/02-Data-Types-in-C/Makefile (file already exists)'
else
  echo 'x - extracting programs/02-Data-Types-in-C/Makefile (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/02-Data-Types-in-C/Makefile' &&
# Makefile for programs in directory 02-Data-Types-in-C
# ***************************************************************
X
PROGRAMS = \
X    employee \
X    gymjudge \
X    quadeq
X
# ***************************************************************
# Parameters to control Makefile operation
# Note that the gccx command script must be defined
X
CC = gccx
CFLAGS = 
X
# ***************************************************************
# Entry to bring the package up to date
X
all: $(PROGRAMS)
X
# ***************************************************************
# Standard entries to remove files from the directories
#    tidy    -- eliminate unwanted files
#    scratch -- delete derived files in preparation for rebuild
X
tidy:
X	rm -f ,* .,* *~ core a.out graphics.ps
X
scratch: tidy
X	rm -f *.o *.a $(PROGRAMS)
X
# ***************************************************************
# C compilations
X
employee.o: employee.c
X	$(CC) $(CFLAGS) -c employee.c
X
gymjudge.o: gymjudge.c
X	$(CC) $(CFLAGS) -c gymjudge.c
X
quadeq.o: quadeq.c
X	$(CC) $(CFLAGS) -c quadeq.c
X
X
# ***************************************************************
# Executable programs
X
employee: employee.o
X	$(CC) $(CFLAGS) -o employee employee.o
X
gymjudge: gymjudge.o
X	$(CC) $(CFLAGS) -o gymjudge gymjudge.o
X
quadeq: quadeq.o
X	$(CC) $(CFLAGS) -o quadeq quadeq.o
X
SHAR_EOF
  $shar_touch -am 0905205197 'programs/02-Data-Types-in-C/Makefile' &&
  chmod 0644 'programs/02-Data-Types-in-C/Makefile' ||
  echo 'restore of programs/02-Data-Types-in-C/Makefile failed'
  shar_count="`wc -c < 'programs/02-Data-Types-in-C/Makefile'`"
  test 1314 -eq "$shar_count" ||
    echo "programs/02-Data-Types-in-C/Makefile: original size 1314, current size $shar_count"
fi
# ============= programs/03-Libraries-and-Interfaces/copyfile.c ==============
if test ! -d 'programs/03-Libraries-and-Interfaces'; then
  echo 'x - creating directory programs/03-Libraries-and-Interfaces'
  mkdir 'programs/03-Libraries-and-Interfaces'
fi
if test -f 'programs/03-Libraries-and-Interfaces/copyfile.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/03-Libraries-and-Interfaces/copyfile.c (file already exists)'
else
  echo 'x - extracting programs/03-Libraries-and-Interfaces/copyfile.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/03-Libraries-and-Interfaces/copyfile.c' &&
/*
X * File: copyfile.c
X * ----------------
X * This program copies one file to another using character I/O.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "simpio.h"
X
/* Private function prototypes */
X
static void CopyFile(FILE *infile, FILE *outfile);
static FILE *OpenUserFile(string prompt, string mode);
X
/* Main program */
X
main()
{
X    FILE *infile, *outfile;
X
X    printf("This program copies one file to another.\n");
X    infile = OpenUserFile("Old file: ", "r");
X    outfile = OpenUserFile("New file: ", "w");
X    CopyFile(infile, outfile);
X    fclose(infile);
X    fclose(outfile);
}
X
/*
X * Function: CopyFile
X * Usage: CopyFile(infile, outfile);
X * ---------------------------------
X * This function copies the contents of infile to outfile.  The
X * client is responsible for opening these files before calling
X * CopyFile and for closing them afterward.
X */
X
static void CopyFile(FILE *infile, FILE *outfile)
{
X    int ch;
X
X    while ((ch = getc(infile)) != EOF) {
X        putc(ch, outfile);
X    }
}
X
/*
X * Function: OpenUserFile
X * Usage: fileptr = OpenUserFile(prompt, mode);
X * --------------------------------------------
X * This function prompts the user for a file name using the
X * prompt string supplied by the user and then attempts to
X * open that file with the specified mode.  If the file is
X * opened successfully, OpenUserFile returns the appropriate
X * file pointer.  If the open operation fails, the user is
X * informed of the failure and given an opportunity to enter
X * another file name.
X */
X
static FILE *OpenUserFile(string prompt, string mode)
{
X    string filename;
X    FILE *result;
X
X    while (TRUE) {
X        printf("%s", prompt);
X        filename = GetLine();
X        result = fopen(filename, mode);
X        if (result != NULL) break;
X        printf("Can't open the file \"%s\"\n", filename);
X    }
X    return (result);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/03-Libraries-and-Interfaces/copyfile.c' &&
  chmod 0644 'programs/03-Libraries-and-Interfaces/copyfile.c' ||
  echo 'restore of programs/03-Libraries-and-Interfaces/copyfile.c failed'
  shar_count="`wc -c < 'programs/03-Libraries-and-Interfaces/copyfile.c'`"
  test 1864 -eq "$shar_count" ||
    echo "programs/03-Libraries-and-Interfaces/copyfile.c: original size 1864, current size $shar_count"
fi
# ============= programs/03-Libraries-and-Interfaces/craps.c ==============
if test -f 'programs/03-Libraries-and-Interfaces/craps.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/03-Libraries-and-Interfaces/craps.c (file already exists)'
else
  echo 'x - extracting programs/03-Libraries-and-Interfaces/craps.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/03-Libraries-and-Interfaces/craps.c' &&
/*
X * File: craps.c
X * -------------
X * This program plays the casino game called craps, which is
X * played using a pair of dice.  At the beginning of the game,
X * you roll the dice and compute the total.  If your first roll
X * is 7 or 11, you win with what gamblers call a "natural."
X * If your first roll is 2, 3, or 12, you lose by "crapping
X * out."  In any other case, the total from the first roll
X * becomes your "point," after which you continue to roll
X * the dice until one of the following conditions occurs:
X *
X * a) You roll your point again.  This is called "making
X *    your point," which wins.
X *
X * b) You roll a 7, which loses.
X *
X * Other rolls, including 2, 3, 11, and 12, have no effect
X * during this phase of the game.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "random.h"
X
/* Function prototypes */
X
static bool TryToMakePoint(int point);
static int RollTwoDice(void);
X
/* Main program */
X
main()
{
X    int point;
X
X    Randomize();
X    printf("This program plays a game of craps.\n");
X    point = RollTwoDice();
X    switch (point) {
X      case 7: case 11:
X        printf("That's a natural.  You win.\n");
X        break;
X      case 2: case 3: case 12:
X        printf("That's craps.  You lose.\n");
X        break;
X      default:
X        printf("Your point is %d.\n", point);
X        if (TryToMakePoint(point)) {
X            printf("You made your point.  You win.\n");
X        } else {
X            printf("You rolled a seven.  You lose.\n");
X        }
X    }
}
X
/*
X * Function: TryToMakePoint
X * Usage: flag = TryToMakePoint(point);
X * ------------------------------------
X * This function is responsible for the part of the game
X * during which you roll the dice repeatedly until you either
X * make your point or roll a 7.  The function returns TRUE if
X * you make your point and FALSE if a 7 comes up first.
X */
X
static bool TryToMakePoint(int point)
{
X    int total;
X
X    while (TRUE) {
X        total = RollTwoDice();
X        if (total == point) return (TRUE);
X        if (total == 7) return (FALSE);
X    }
}
X
/*
X * Function: RollTwoDice
X * Usage: total = RollTwoDice();
X * -----------------------------
X * This function rolls two dice and returns their sum.  As part
X * of the implementation, the result is displayed on the screen.
X */
X
static int RollTwoDice(void)
{
X    int d1, d2, total;
X
X    printf("Rolling the dice . . .\n");
X    d1 = RandomInteger(1, 6);
X    d2 = RandomInteger(1, 6);
X    total = d1 + d2;
X    printf("You rolled %d and %d -- that's %d.\n", d1, d2, total);
X    return (total);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/03-Libraries-and-Interfaces/craps.c' &&
  chmod 0644 'programs/03-Libraries-and-Interfaces/craps.c' ||
  echo 'restore of programs/03-Libraries-and-Interfaces/craps.c failed'
  shar_count="`wc -c < 'programs/03-Libraries-and-Interfaces/craps.c'`"
  test 2537 -eq "$shar_count" ||
    echo "programs/03-Libraries-and-Interfaces/craps.c: original size 2537, current size $shar_count"
fi
# ============= programs/03-Libraries-and-Interfaces/flipcoin.c ==============
if test -f 'programs/03-Libraries-and-Interfaces/flipcoin.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/03-Libraries-and-Interfaces/flipcoin.c (file already exists)'
else
  echo 'x - extracting programs/03-Libraries-and-Interfaces/flipcoin.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/03-Libraries-and-Interfaces/flipcoin.c' &&
/*
X * File: flipcoin.c
X * ----------------
X * This program simulates flipping a coin.
X */
X
#include <stdio.h>
#include <stdlib.h>
#include "genlib.h"
#include "random.h"
X
/*
X * Constants
X * ---------
X * NTrials        -- Number of trials
X * EntriesPerLine -- Number of entries on a single line
X */
X
#define NTrials         100
#define EntriesPerLine   10
X
/* Private function prototypes */
X
static string FlipCoin(void);
X
/* Main program */
X
main()
{
X    int i;
X
X    for (i = 0; i < NTrials; i++) {
X        printf("%-7s", FlipCoin());
X        if ((i + 1) % EntriesPerLine == 0) printf("\n");
X    }
}
X
/*
X * Function: FlipCoin
X * Usage: str = FlipCoin();
X * ------------------------
X * This function simulates a coin flip by returning
X * either "heads" or "tails" with equal probability.
X */
X
static string FlipCoin(void)
{
X    if (RandomChance(0.50)) {
X        return ("heads");
X    } else {
X        return ("tails");
X    }
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/03-Libraries-and-Interfaces/flipcoin.c' &&
  chmod 0644 'programs/03-Libraries-and-Interfaces/flipcoin.c' ||
  echo 'restore of programs/03-Libraries-and-Interfaces/flipcoin.c failed'
  shar_count="`wc -c < 'programs/03-Libraries-and-Interfaces/flipcoin.c'`"
  test 926 -eq "$shar_count" ||
    echo "programs/03-Libraries-and-Interfaces/flipcoin.c: original size 926, current size $shar_count"
fi
# ============= programs/03-Libraries-and-Interfaces/jabber.txt ==============
if test -f 'programs/03-Libraries-and-Interfaces/jabber.txt' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/03-Libraries-and-Interfaces/jabber.txt (file already exists)'
else
  echo 'x - extracting programs/03-Libraries-and-Interfaces/jabber.txt (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/03-Libraries-and-Interfaces/jabber.txt' &&
'Twas brillig, and the slithy toves
Did gyre and gimble in the wabe;
All mimsy were the borogoves,
And the mome raths outgrabe.
SHAR_EOF
  $shar_touch -am 0906100197 'programs/03-Libraries-and-Interfaces/jabber.txt' &&
  chmod 0644 'programs/03-Libraries-and-Interfaces/jabber.txt' ||
  echo 'restore of programs/03-Libraries-and-Interfaces/jabber.txt failed'
  shar_count="`wc -c < 'programs/03-Libraries-and-Interfaces/jabber.txt'`"
  test 128 -eq "$shar_count" ||
    echo "programs/03-Libraries-and-Interfaces/jabber.txt: original size 128, current size $shar_count"
fi
# ============= programs/03-Libraries-and-Interfaces/linecopy.c ==============
if test -f 'programs/03-Libraries-and-Interfaces/linecopy.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/03-Libraries-and-Interfaces/linecopy.c (file already exists)'
else
  echo 'x - extracting programs/03-Libraries-and-Interfaces/linecopy.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/03-Libraries-and-Interfaces/linecopy.c' &&
/*
X * File: linecopy.c
X * ----------------
X * This program copies one file to another using line I/O.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "simpio.h"
X
/*
X * Constants
X * ---------
X * MaxLine -- Size of the buffer used in CopyFile
X */
X
#define MaxLine 100
X
/* Private function prototypes */
X
static void CopyFile(FILE *infile, FILE *outfile);
static FILE *OpenUserFile(string prompt, string mode);
X
/* Main program */
X
main()
{
X    FILE *infile, *outfile;
X
X    printf("This program copies one file to another.\n");
X    infile = OpenUserFile("Old file: ", "r");
X    outfile = OpenUserFile("New file: ", "w");
X    CopyFile(infile, outfile);
X    fclose(infile);
X    fclose(outfile);
}
X
/*
X * Function: CopyFile
X * Usage: CopyFile(infile, outfile);
X * ---------------------------------
X * This function copies the contents of infile to outfile.  The
X * client is responsible for opening these files before calling
X * CopyFile and for closing them afterward.  This implementation
X * uses line I/O to perform the copy.  Note that this approach
X * works correctly even if the file contains a line longer than
X * MaxLine; long lines are simply copied in pieces.
X */
X
static void CopyFile(FILE *infile, FILE *outfile)
{
X    char buffer[MaxLine];
X
X    while (fgets(buffer, MaxLine, infile) != NULL) {
X        fputs(buffer, outfile);
X    }
}
X
/*
X * Function: OpenUserFile
X * Usage: fileptr = OpenUserFile(prompt, mode);
X * --------------------------------------------
X * This function prompts the user for a file name using the
X * prompt string supplied by the user and then attempts to
X * open that file with the specified mode.  If the file is
X * opened successfully, OpenUserFile returns the appropriate
X * file pointer.  If the open operation fails, the user is
X * informed of the failure and given an opportunity to enter
X * another file name.
X */
X
static FILE *OpenUserFile(string prompt, string mode)
{
X    string filename;
X    FILE *result;
X
X    while (TRUE) {
X        printf("%s", prompt);
X        filename = GetLine();
X        result = fopen(filename, mode);
X        if (result != NULL) break;
X        printf("Can't open the file \"%s\"\n", filename);
X    }
X    return (result);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/03-Libraries-and-Interfaces/linecopy.c' &&
  chmod 0644 'programs/03-Libraries-and-Interfaces/linecopy.c' ||
  echo 'restore of programs/03-Libraries-and-Interfaces/linecopy.c failed'
  shar_count="`wc -c < 'programs/03-Libraries-and-Interfaces/linecopy.c'`"
  test 2195 -eq "$shar_count" ||
    echo "programs/03-Libraries-and-Interfaces/linecopy.c: original size 2195, current size $shar_count"
fi
# ============= programs/03-Libraries-and-Interfaces/pigword1.c ==============
if test -f 'programs/03-Libraries-and-Interfaces/pigword1.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/03-Libraries-and-Interfaces/pigword1.c (file already exists)'
else
  echo 'x - extracting programs/03-Libraries-and-Interfaces/pigword1.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/03-Libraries-and-Interfaces/pigword1.c' &&
/*
X * File: pigword.c (string.h version)
X * ----------------------------------
X * This program translates a word from English to Pig Latin by
X * applying the following rules:
X *
X * o  If the word contains no vowels, no translation is done,
X *    so that the new word is the same as the original.
X *
X * o  If the word begins with a vowel, the function adds "way"
X *    to the end of the original word.
X *
X * o  If the word begins with a consonant, the function extracts
X *    the string of consonants up to the first vowel, moves that
X *    to the end of the word, and adds "ay".
X */
X
#include <stdio.h>
#include <string.h>
#include "genlib.h"
#include "simpio.h"
X
/*
X * Constants
X * ---------
X * MaxWord -- Length of the maximum word
X */
X
#define MaxWord 20
X
/* Private function prototypes */
X
static void PigLatin(char *word, char buffer[], int bufferSize);
static char *FindFirstVowel(char *word);
static bool IsVowel(char ch);
X
/* Main program */
X
main()
{
X    string word;
X    char translationBuffer[MaxWord + 1];
X
X    printf("Enter a word: ");
X    word = GetLine();
X    PigLatin(word, translationBuffer, MaxWord + 1);
X    printf("Pig Latin: %s\n", translationBuffer);
}
X
/*
X * Function: PigLatin
X * Usage: PigLatin(word, buffer, bufferSize);
X * ------------------------------------------
X * This function translates a word from English to Pig Latin.  The
X * translated word is written into the array buffer, which has an
X * allocated size of bufferSize.  The code checks for buffer
X * overflow and generates an error if it occurs.
X */
X
static void PigLatin(char *word, char buffer[], int bufferSize)
{
X    char *vp;
X    int wordLength;
X
X    vp = FindFirstVowel(word);
X    wordLength = strlen(word);
X    if (vp == word) {
X        wordLength += 3;
X    } else if (vp != NULL) {
X        wordLength += 2;
X    }
X    if (wordLength >= bufferSize) Error("Buffer overflow");
X    if (vp == NULL) {
X        strcpy(buffer, word);
X    } else if (vp == word) {
X        strcpy(buffer, word);
X        strcat(buffer, "way");
X    } else {
X        strcpy(buffer, vp);
X        strncat(buffer, word, vp - word);
X        strcat(buffer, "ay");
X    }
}
X
/*
X * Function: FindFirstVowel
X * Usage: vp = FindFirstVowel(word);
X * ---------------------------------
X * This function returns a pointer of the first vowel in word.
X * If word does not contain a vowel, FindFirstVowel returns NULL.
X */
X
static char *FindFirstVowel(char *word)
{
X    char *cp;
X
X    for (cp = word; *cp != '\0'; cp++) {
X        if (IsVowel(*cp)) return (cp);
X    }
X    return (NULL);
}
X
/*
X * Function: IsVowel
X * Usage: if (IsVowel(ch)) . . .
X * -----------------------------
X * This function returns TRUE if ch is a vowel, which are
X * recognized in either upper or lower case.
X */
X
static bool IsVowel(char ch)
{
X    switch (ch) {
X      case 'A': case 'E': case 'I': case 'O': case 'U':
X      case 'a': case 'e': case 'i': case 'o': case 'u':
X        return (TRUE);
X      default:
X        return (FALSE);
X    }
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/03-Libraries-and-Interfaces/pigword1.c' &&
  chmod 0644 'programs/03-Libraries-and-Interfaces/pigword1.c' ||
  echo 'restore of programs/03-Libraries-and-Interfaces/pigword1.c failed'
  shar_count="`wc -c < 'programs/03-Libraries-and-Interfaces/pigword1.c'`"
  test 2968 -eq "$shar_count" ||
    echo "programs/03-Libraries-and-Interfaces/pigword1.c: original size 2968, current size $shar_count"
fi
# ============= programs/03-Libraries-and-Interfaces/pigword2.c ==============
if test -f 'programs/03-Libraries-and-Interfaces/pigword2.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/03-Libraries-and-Interfaces/pigword2.c (file already exists)'
else
  echo 'x - extracting programs/03-Libraries-and-Interfaces/pigword2.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/03-Libraries-and-Interfaces/pigword2.c' &&
/*
X * File: pigword.c (strlib.h version)
X * ----------------------------------
X * This program translates a word from English to Pig Latin by
X * applying the following rules:
X *
X * o  If the word contains no vowels, no translation is done,
X *    so that the new word is the same as the original.
X *
X * o  If the word begins with a vowel, the function adds "way"
X *    to the end of the original word.
X *
X * o  If the word begins with a consonant, the function extracts
X *    the string of consonants up to the first vowel, moves that
X *    to the end of the word, and adds "ay".
X */
X
#include <stdio.h>
#include "genlib.h"
#include "strlib.h"
#include "simpio.h"
X
/* Private function prototypes */
X
static string PigLatin(string word);
static int FindFirstVowel(string word);
static bool IsVowel(char ch);
X
/* Main program */
X
main()
{
X    string word;
X
X    printf("Enter a word: ");
X    word = GetLine();
X    printf("Pig Latin: %s\n", PigLatin(word));
}
X
/*
X * Function: PigLatin
X * Usage: translation = PigLatin(word);
X * ------------------------------------
X * This function translates a word from English to Pig Latin.
X * The translated word is returned as the value of the function.
X */
X
static string PigLatin(string word)
{
X    int vp;
X    string head, tail;
X
X    vp = FindFirstVowel(word);
X    if (vp == -1) {
X        return (word);
X    } else if (vp == 0) {
X        return (Concat(word, "way"));
X    } else {
X        head = SubString(word, 0, vp - 1);
X        tail = SubString(word, vp, StringLength(word) - 1);
X        return (Concat(tail, Concat(head, "ay")));
X    }
}
X
/*
X * Function: FindFirstVowel
X * Usage: k = FindFirstVowel(word);
X * --------------------------------
X * This function returns the index position of the first vowel
X * in word.  If word does not contain a vowel, FindFirstVowel
X * returns -1.
X */
X
static int FindFirstVowel(string word)
{
X    int i;
X
X    for (i = 0; i < StringLength(word); i++) {
X        if (IsVowel(IthChar(word, i))) return (i);
X    }
X    return (-1);
}
X
/*
X * Function: IsVowel
X * Usage: if (IsVowel(ch)) . . .
X * -----------------------------
X * This function returns TRUE if ch is a vowel, which are
X * recognized in either upper or lower case.
X */
X
static bool IsVowel(char ch)
{
X    switch (ch) {
X      case 'A': case 'E': case 'I': case 'O': case 'U':
X      case 'a': case 'e': case 'i': case 'o': case 'u':
X        return (TRUE);
X      default:
X        return (FALSE);
X    }
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/03-Libraries-and-Interfaces/pigword2.c' &&
  chmod 0644 'programs/03-Libraries-and-Interfaces/pigword2.c' ||
  echo 'restore of programs/03-Libraries-and-Interfaces/pigword2.c failed'
  shar_count="`wc -c < 'programs/03-Libraries-and-Interfaces/pigword2.c'`"
  test 2435 -eq "$shar_count" ||
    echo "programs/03-Libraries-and-Interfaces/pigword2.c: original size 2435, current size $shar_count"
fi
# ============= programs/03-Libraries-and-Interfaces/random.c ==============
if test -f 'programs/03-Libraries-and-Interfaces/random.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/03-Libraries-and-Interfaces/random.c (file already exists)'
else
  echo 'x - extracting programs/03-Libraries-and-Interfaces/random.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/03-Libraries-and-Interfaces/random.c' &&
/*
X * File: random.c
X * --------------
X * This file implements the random.h interface.
X */
X
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "genlib.h"
#include "random.h"
X
/*
X * Function: RandomInteger
X * -----------------------
X * This function begins by using rand to select an integer
X * in the interval [0, RAND_MAX] and then converts it to the
X * desired range by applying the following steps:
X *
X * 1. Normalize the value to a real number in the interval [0, 1)
X * 2. Scale the resulting value to the appropriate range size
X * 3. Truncate the scaled value to an integer
X * 4. Translate the integer to the appropriate starting point
X */
X
int RandomInteger(int low, int high)
{
X    int k;
X    double d;
X
X    d = (double) rand() / ((double) RAND_MAX + 1);
X    k = (int) (d * (high - low + 1));
X    return (low + k);
}
X
/*
X * Function: RandomReal
X * --------------------
X * The implementation of RandomReal is similar to that
X * of RandomInteger, without the truncation step.
X */
X
double RandomReal(double low, double high)
{
X    double d;
X
X    d = (double) rand() / ((double) RAND_MAX + 1);
X    return (low + d * (high - low));
}
X
/*
X * Function: RandomChance
X * ----------------------
X * This function uses RandomReal to generate a real number
X * in the interval [0, 1) and then compares that value to p.
X */
X
bool RandomChance(double p)
{
X    return (RandomReal(0, 1) < p);
}
X
/*
X * Function: Randomize
X * -------------------
X * This function operates by setting the random number
X * seed to the current time.  The srand function is
X * provided by the <stdlib.h> library and requires an
X * integer argument.  The time function is exported by
X * the <time.h> interface.
X */
X
void Randomize(void)
{
X    srand((int) time(NULL));
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/03-Libraries-and-Interfaces/random.c' &&
  chmod 0644 'programs/03-Libraries-and-Interfaces/random.c' ||
  echo 'restore of programs/03-Libraries-and-Interfaces/random.c failed'
  shar_count="`wc -c < 'programs/03-Libraries-and-Interfaces/random.c'`"
  test 1751 -eq "$shar_count" ||
    echo "programs/03-Libraries-and-Interfaces/random.c: original size 1751, current size $shar_count"
fi
# ============= programs/03-Libraries-and-Interfaces/random.h ==============
if test -f 'programs/03-Libraries-and-Interfaces/random.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/03-Libraries-and-Interfaces/random.h (file already exists)'
else
  echo 'x - extracting programs/03-Libraries-and-Interfaces/random.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/03-Libraries-and-Interfaces/random.h' &&
/*
X * File: random.h
X * --------------
X * This interface provides several functions for generating
X * pseudo-random numbers.
X */
X
#ifndef _random_h
#define _random_h
X
#include "genlib.h"
X
/*
X * Function: RandomInteger
X * Usage: n = RandomInteger(low, high);
X * ------------------------------------
X * This function returns a random integer in the range low to high,
X * inclusive.
X */
X
int RandomInteger(int low, int high);
X
/*
X * Function: RandomReal
X * Usage: d = RandomReal(low, high);
X * ---------------------------------
X * This function returns a random real number in the half-open
X * interval [low, high), meaning that the result is always
X * greater than or equal to low but strictly less than high.
X */
X
double RandomReal(double low, double high);
X
/*
X * Function: RandomChance
X * Usage: if (RandomChance(p)) . . .
X * ---------------------------------
X * The RandomChance function returns TRUE with the probability
X * indicated by p, which should be a floating-point number between
X * 0 (meaning never) and 1 (meaning always).  For example, calling
X * RandomChance(.30) returns TRUE 30 percent of the time.
X */
X
bool RandomChance(double p);
X
/*
X * Function: Randomize
X * Usage: Randomize();
X * -------------------
X * This function initializes the random-number generator so that
X * its results are unpredictable.  If this function is not called,
X * the other functions will return the same values on each run.
X */
X
void Randomize(void);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/03-Libraries-and-Interfaces/random.h' &&
  chmod 0644 'programs/03-Libraries-and-Interfaces/random.h' ||
  echo 'restore of programs/03-Libraries-and-Interfaces/random.h failed'
  shar_count="`wc -c < 'programs/03-Libraries-and-Interfaces/random.h'`"
  test 1454 -eq "$shar_count" ||
    echo "programs/03-Libraries-and-Interfaces/random.h: original size 1454, current size $shar_count"
fi
# ============= programs/03-Libraries-and-Interfaces/randtest.c ==============
if test -f 'programs/03-Libraries-and-Interfaces/randtest.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/03-Libraries-and-Interfaces/randtest.c (file already exists)'
else
  echo 'x - extracting programs/03-Libraries-and-Interfaces/randtest.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/03-Libraries-and-Interfaces/randtest.c' &&
/*
X * File: randtest.c
X * ----------------
X * This program tests the ANSI rand function.
X */
X
#include <stdio.h>
#include <stdlib.h>
#include "genlib.h"
X
/*
X * Constants
X * ---------
X * NTrials -- Number of trials
X */
X
#define NTrials 10
X
main()
{
X    int i;
X
X    printf("On this computer, RAND_MAX is %d.\n", RAND_MAX);
X    printf("The first %d calls to rand return:\n", NTrials);
X    for (i = 0; i < NTrials; i++) {
X        printf("%10d\n", rand());
X    }
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/03-Libraries-and-Interfaces/randtest.c' &&
  chmod 0644 'programs/03-Libraries-and-Interfaces/randtest.c' ||
  echo 'restore of programs/03-Libraries-and-Interfaces/randtest.c failed'
  shar_count="`wc -c < 'programs/03-Libraries-and-Interfaces/randtest.c'`"
  test 460 -eq "$shar_count" ||
    echo "programs/03-Libraries-and-Interfaces/randtest.c: original size 460, current size $shar_count"
fi
# ============= programs/03-Libraries-and-Interfaces/remcom.c ==============
if test -f 'programs/03-Libraries-and-Interfaces/remcom.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/03-Libraries-and-Interfaces/remcom.c (file already exists)'
else
  echo 'x - extracting programs/03-Libraries-and-Interfaces/remcom.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/03-Libraries-and-Interfaces/remcom.c' &&
/*
X * File: remcom.c
X * --------------
X * This program eliminates comments from a file.  This version
X * does not ignore comments that appear in a string constant;
X * that change is left to the reader as an exercise.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "simpio.h"
X
/* Private function prototypes */
X
static void CopyRemovingComments(FILE *infile, FILE *outfile);
X
/* Main program */
X
X
main()
{
X    string filename, temp;
X    FILE *infile, *outfile;
X
X    printf("This program removes comments from a file.\n");
X    while (TRUE) {
X        printf("File name: ");
X        filename = GetLine();
X        infile = fopen(filename, "r");
X        if (infile != NULL) break;
X        printf("File %s not found -- try again.\n", filename);
X    }
X    temp = tmpnam(NULL);
X    outfile = fopen(temp, "w");
X    if (outfile == NULL) Error("Can't open temporary file");
X    CopyRemovingComments(infile, outfile);
X    fclose(infile);
X    fclose(outfile);
X    if (remove(filename) != 0 || rename(temp, filename) != 0) {
X        Error("Unable to rename temporary file");
X    }
}
X
/*
X * Function: CopyRemovingComments
X * Usage: CopyRemovingComments(infile, outfile);
X * ---------------------------------------------
X * This function copies one file to another, removing comments
X * as it goes.  The status indicator as to whether a comment is
X * being read is stored in commentFlag.
X */
X
static void CopyRemovingComments(FILE *infile, FILE *outfile)
{
X    int ch, nch;
X    bool commentFlag;
X
X    commentFlag = FALSE;
X    while ((ch = getc(infile)) != EOF) {
X        if (commentFlag) {
X            if (ch == '*') {
X                nch = getc(infile);
X                if (nch == '/') {
X                    commentFlag = FALSE;
X                } else {
X                    ungetc(nch, infile);
X                }
X            }
X        } else {
X            if (ch == '/') {
X                nch = getc(infile);
X                if (nch == '*') {
X                    commentFlag = TRUE;
X                } else {
X                    ungetc(nch, infile);
X                }
X            }
X            if (!commentFlag) putc(ch, outfile);
X        }
X    }
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/03-Libraries-and-Interfaces/remcom.c' &&
  chmod 0644 'programs/03-Libraries-and-Interfaces/remcom.c' ||
  echo 'restore of programs/03-Libraries-and-Interfaces/remcom.c failed'
  shar_count="`wc -c < 'programs/03-Libraries-and-Interfaces/remcom.c'`"
  test 2138 -eq "$shar_count" ||
    echo "programs/03-Libraries-and-Interfaces/remcom.c: original size 2138, current size $shar_count"
fi
# ============= programs/03-Libraries-and-Interfaces/spcount.c ==============
if test -f 'programs/03-Libraries-and-Interfaces/spcount.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/03-Libraries-and-Interfaces/spcount.c (file already exists)'
else
  echo 'x - extracting programs/03-Libraries-and-Interfaces/spcount.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/03-Libraries-and-Interfaces/spcount.c' &&
/*
X * File: spcount.c
X * ---------------
X * This file defines the function CountSpaces, which returns
X * the number of spaces in a string.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "strlib.h"
#include "simpio.h"
X
/* Private function prototypes */
X
static int CountSpacesArray(char str[]);
static int CountSpacesPointer(char *str);
X
/* Main program */
X
main()
{
X    string str;
X
X    printf("Enter a string: ");
X    str = GetLine();
X    printf("Array:   %d spaces.\n", CountSpacesArray(str));
X    printf("Pointer: %d spaces.\n", CountSpacesPointer(str));
}
X
/*
X * Function: CountSpaces
X * Usage: nSpaces = CountSpaces(str);
X * ----------------------------------
X * This function counts the number of spaces in the string str.
X */
X
/* Array implementation */
X
#define CountSpaces CountSpacesArray
X
static int CountSpaces(char str[])
{
X    int i, nSpaces;
X
X    nSpaces = 0;
X    for (i = 0; str[i] != '\0'; i++) {
X        if (str[i] == ' ') nSpaces++;
X    }
X    return (nSpaces);
}
X
#undef CountSpaces
X
/* Pointer implementation */
X
#define CountSpaces CountSpacesPointer
X
static int CountSpaces(char *str)
{
X    int nSpaces;
X    char *cp;
X
X    nSpaces = 0;
X    for (cp = str; *cp != '\0'; cp++) {
X        if (*cp == ' ') nSpaces++;
X    }
X    return (nSpaces);
}
X
#undef CountSpaces
SHAR_EOF
  $shar_touch -am 0903182097 'programs/03-Libraries-and-Interfaces/spcount.c' &&
  chmod 0644 'programs/03-Libraries-and-Interfaces/spcount.c' ||
  echo 'restore of programs/03-Libraries-and-Interfaces/spcount.c failed'
  shar_count="`wc -c < 'programs/03-Libraries-and-Interfaces/spcount.c'`"
  test 1289 -eq "$shar_count" ||
    echo "programs/03-Libraries-and-Interfaces/spcount.c: original size 1289, current size $shar_count"
fi
# ============= programs/03-Libraries-and-Interfaces/Makefile ==============
if test -f 'programs/03-Libraries-and-Interfaces/Makefile' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/03-Libraries-and-Interfaces/Makefile (file already exists)'
else
  echo 'x - extracting programs/03-Libraries-and-Interfaces/Makefile (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/03-Libraries-and-Interfaces/Makefile' &&
# Makefile for programs in directory 03-Libraries-and-Interfaces
# ***************************************************************
X
PROGRAMS = \
X    copyfile \
X    craps \
X    flipcoin \
X    linecopy \
X    pigword1 \
X    pigword2 \
X    randtest \
X    remcom \
X    spcount
X
# ***************************************************************
# Parameters to control Makefile operation
# Note that the gccx command script must be defined
X
CC = gccx
CFLAGS = 
X
# ***************************************************************
# Entry to bring the package up to date
X
all: $(PROGRAMS)
X
# ***************************************************************
# Standard entries to remove files from the directories
#    tidy    -- eliminate unwanted files
#    scratch -- delete derived files in preparation for rebuild
X
tidy:
X	rm -f ,* .,* *~ core a.out graphics.ps
X
scratch: tidy
X	rm -f *.o *.a $(PROGRAMS)
X
# ***************************************************************
# C compilations
X
copyfile.o: copyfile.c
X	$(CC) $(CFLAGS) -c copyfile.c
X
craps.o: craps.c random.h
X	$(CC) $(CFLAGS) -c craps.c
X
flipcoin.o: flipcoin.c random.h
X	$(CC) $(CFLAGS) -c flipcoin.c
X
linecopy.o: linecopy.c
X	$(CC) $(CFLAGS) -c linecopy.c
X
pigword1.o: pigword1.c
X	$(CC) $(CFLAGS) -c pigword1.c
X
pigword2.o: pigword2.c
X	$(CC) $(CFLAGS) -c pigword2.c
X
random.o: random.c random.h
X	$(CC) $(CFLAGS) -c random.c
X
randtest.o: randtest.c
X	$(CC) $(CFLAGS) -c randtest.c
X
remcom.o: remcom.c
X	$(CC) $(CFLAGS) -c remcom.c
X
spcount.o: spcount.c
X	$(CC) $(CFLAGS) -c spcount.c
X
X
# ***************************************************************
# Executable programs
X
copyfile: copyfile.o
X	$(CC) $(CFLAGS) -o copyfile copyfile.o
X
craps: craps.o random.o
X	$(CC) $(CFLAGS) -o craps craps.o random.o
X
flipcoin: flipcoin.o random.o
X	$(CC) $(CFLAGS) -o flipcoin flipcoin.o random.o
X
linecopy: linecopy.o
X	$(CC) $(CFLAGS) -o linecopy linecopy.o
X
pigword1: pigword1.o
X	$(CC) $(CFLAGS) -o pigword1 pigword1.o
X
pigword2: pigword2.o
X	$(CC) $(CFLAGS) -o pigword2 pigword2.o
X
randtest: randtest.o
X	$(CC) $(CFLAGS) -o randtest randtest.o
X
remcom: remcom.o
X	$(CC) $(CFLAGS) -o remcom remcom.o
X
spcount: spcount.o
X	$(CC) $(CFLAGS) -o spcount spcount.o
X
SHAR_EOF
  $shar_touch -am 0905205197 'programs/03-Libraries-and-Interfaces/Makefile' &&
  chmod 0644 'programs/03-Libraries-and-Interfaces/Makefile' ||
  echo 'restore of programs/03-Libraries-and-Interfaces/Makefile failed'
  shar_count="`wc -c < 'programs/03-Libraries-and-Interfaces/Makefile'`"
  test 2195 -eq "$shar_count" ||
    echo "programs/03-Libraries-and-Interfaces/Makefile: original size 2195, current size $shar_count"
fi
# ============= programs/04-Introduction-to-Recursion/bsearch.c ==============
if test ! -d 'programs/04-Introduction-to-Recursion'; then
  echo 'x - creating directory programs/04-Introduction-to-Recursion'
  mkdir 'programs/04-Introduction-to-Recursion'
fi
if test -f 'programs/04-Introduction-to-Recursion/bsearch.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/04-Introduction-to-Recursion/bsearch.c (file already exists)'
else
  echo 'x - extracting programs/04-Introduction-to-Recursion/bsearch.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/04-Introduction-to-Recursion/bsearch.c' &&
/*
X * File: bsearch.c
X * ---------------
X * This program tests the recursive implementation of the
X * function FindStringInSortedArray by reimplementing the
X * mileage table example from Chapter 12 of The Art and
X * Science of C.
X */
X
#include <stdio.h>
#include <ctype.h>
#include "simpio.h"
#include "strlib.h"
#include "genlib.h"
X
/*
X * Constants
X * ---------
X * NCities -- Number of cities
X */
X
#define NCities 12
X
/*
X * Global variable: mileageTable
X * -----------------------------
X * This table is a two-dimensional array that holds the distance
X * between the cities whose indices are the row and column numbers.
X * Data source: Rand McNally Road Atlas.
X */
X
static int mileageTable[NCities][NCities] = {
X    {   0,1108, 708,1430, 732, 791,2191, 663, 854, 748,2483,2625},
X    {1108,   0, 994,1998, 799,1830,3017,1520, 222, 315,3128,3016},
X    { 708, 994,   0,1021, 279,1091,2048,1397, 809, 785,2173,2052},
X    {1430,1998,1021,   0,1283,1034,1031,2107,1794,1739,1255,1341},
X    { 732, 799, 279,1283,   0,1276,2288,1385, 649, 609,2399,2327},
X    { 791,1830,1091,1034,1276,   0,1541,1190,1610,1511,1911,2369},
X    {2191,3017,2048,1031,2288,1541,   0,2716,2794,2703, 387,1134},
X    { 663,1520,1397,2107,1385,1190,2716,   0,1334,1230,3093,3303},
X    { 854, 222, 809,1794, 649,1610,2794,1334,   0, 101,2930,2841},
X    { 748, 315, 785,1739, 609,1511,2703,1230, 101,   0,2902,2816},
X    {2483,3128,2173,1255,2399,1911, 387,3093,2930,2902,   0, 810},
X    {2625,3016,2052,1341,2327,2369,1134,3303,2841,2816, 810,   0},
};
X
/*
X * Global variable: cityTable
X * --------------------------
X * The array cityTable holds the names of the cities used in the
X * mileage table.
X */
X
static string cityTable[NCities] = {
X    "Atlanta",
X    "Boston",
X    "Chicago",
X    "Denver",
X    "Detroit",
X    "Houston",
X    "Los Angeles",
X    "Miami",
X    "New York",
X    "Philadelphia",
X    "San Francisco",
X    "Seattle",
};
X
/* Private function declarations */
X
static int GetCity(string prompt);
static int FindStringInSortedArray(string key, string array[], int n);
static int BinarySearch(string key, string array[],
X                        int low, int high);
X
/* Main program */
X
main()
{
X    int city1, city2;
X
X    printf("This program looks up intercity mileage.\n");
X    city1 = GetCity("Enter name of city #1: ");
X    city2 = GetCity("Enter name of city #2: ");
X    printf("Distance between %s", cityTable[city1]);
X    printf(" and %s:", cityTable[city2]);
X    printf(" %d miles.\n", mileageTable[city1][city2]);
}
X
/*
X * Function: GetCity
X * Usage: n = GetCity(prompt);
X * ---------------------------
X * This function prompts the user for a city name, reads in a
X * string, and returns the index corresponding to that city,
X * if it exists.  If an undefined city name is entered, the
X * user is given a chance to retry.
X */
X
static int GetCity(string prompt)
{
X    string cityName;
X    int index;
X
X    while (TRUE) {
X        printf("%s", prompt);
X        cityName = GetLine();
X        index = FindStringInSortedArray(cityName, cityTable, NCities);
X        if (index >= 0) break;
X        printf("Unknown city name -- try again.\n");
X    }
X    return (index);
}
X
/*
X * Function: FindStringInSortedArray
X * Usage: index = FindStringInSortedArray(key, array, n);
X * ------------------------------------------------------
X * This function searches the array looking for the specified
X * key. The argument n specifies the effective size of the
X * array, which must be sorted according to the lexicographic
X * order imposed by StringCompare.  If the key is found, the
X * function returns the index in the array at which that key
X * appears.  (If the key appears more than once in the array,
X * any of the matching indices may be returned).  If the key
X * does not exist in the array, the function returns -1.  In
X * this implementation, FindStringInSortedArray is simply a
X * wrapper; all the work is done by the recursive function
X * BinarySearch.
X */
X
static int FindStringInSortedArray(string key, string array[], int n)
{
X    return (BinarySearch(key, array, 0, n - 1));
}
X
/*
X * Function: BinarySearch
X * Usage: index = BinarySearch(key, array, low, high);
X * ---------------------------------------------------
X * This function does the work for FindStringInSortedArray.
X * The only difference is that BinarySearch takes both the
X * upper and lower limit of the search.
X */
X
static int BinarySearch(string key, string array[],
X                        int low, int high)
{
X    int mid, cmp;
X
X    if (low > high) return (-1);
X    mid = (low + high) / 2;
X    cmp = StringCompare(key, array[mid]);
X    if (cmp == 0) return (mid);
X    if (cmp < 0) {
X        return (BinarySearch(key, array, low, mid - 1));
X    } else {
X        return (BinarySearch(key, array, mid + 1, high));
X    }
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/04-Introduction-to-Recursion/bsearch.c' &&
  chmod 0644 'programs/04-Introduction-to-Recursion/bsearch.c' ||
  echo 'restore of programs/04-Introduction-to-Recursion/bsearch.c failed'
  shar_count="`wc -c < 'programs/04-Introduction-to-Recursion/bsearch.c'`"
  test 4770 -eq "$shar_count" ||
    echo "programs/04-Introduction-to-Recursion/bsearch.c: original size 4770, current size $shar_count"
fi
# ============= programs/04-Introduction-to-Recursion/fact.c ==============
if test -f 'programs/04-Introduction-to-Recursion/fact.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/04-Introduction-to-Recursion/fact.c (file already exists)'
else
  echo 'x - extracting programs/04-Introduction-to-Recursion/fact.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/04-Introduction-to-Recursion/fact.c' &&
/*
X * File: fact.c
X * ------------
X * This program includes the factorial function and a test
X * program that prints the factorials of the numbers between
X * the limits LowerLimit and UpperLimit, inclusive.
X */
X
#include <stdio.h>
#include "genlib.h"
X
/*
X * Constants
X * ---------
X * LowerLimit -- Starting value for factorial table
X * UpperLimit -- Final value for factorial table
X */
X
#define LowerLimit 0
#define UpperLimit 7
X
/* Function prototypes */
X
int Fact(int n);
X
/* Main program */
X
main()
{
X    int i;
X
X    for (i = LowerLimit; i <= UpperLimit; i++) {
X        printf("%d! = %5d\n", i, Fact(i));
X    }
}
X
/*
X * Function: Fact
X * Usage: f = Fact(n);
X * -------------------
X * This function returns the factorial of the argument n (n!),
X * recursively applying the following mathematical definition:
X *
X *            /  1, if n = 0
X *    n!  =  <
X *            \  n * (n-1)!, if n > 0
X */
X
int Fact(int n)
{
X    if (n == 0) {
X        return (1);
X    } else {
X        return (n * Fact(n - 1));
X    }
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/04-Introduction-to-Recursion/fact.c' &&
  chmod 0644 'programs/04-Introduction-to-Recursion/fact.c' ||
  echo 'restore of programs/04-Introduction-to-Recursion/fact.c failed'
  shar_count="`wc -c < 'programs/04-Introduction-to-Recursion/fact.c'`"
  test 1011 -eq "$shar_count" ||
    echo "programs/04-Introduction-to-Recursion/fact.c: original size 1011, current size $shar_count"
fi
# ============= programs/04-Introduction-to-Recursion/fastfib.c ==============
if test -f 'programs/04-Introduction-to-Recursion/fastfib.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/04-Introduction-to-Recursion/fastfib.c (file already exists)'
else
  echo 'x - extracting programs/04-Introduction-to-Recursion/fastfib.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/04-Introduction-to-Recursion/fastfib.c' &&
/*
X * File: fastfib.c
X * ---------------
X * This program is identical in its operation to fib.c but
X * implements the Fibonacci function in a more efficient way.
X */
X
#include <stdio.h>
#include "genlib.h"
X
/*
X * Constants
X * ---------
X * MinIndex -- Index of first term to generate
X * MaxIndex -- Index of last term to generate
X */
X
#define MinIndex  0
#define MaxIndex 12
X
/* Private function prototypes */
X
static int Fib(int n);
static int AdditiveSequence(int n, int t0, int t1);
X
/* Main program */
X
main()
{
X    int i;
X
X    printf("This program lists the Fibonacci sequence.\n");
X    for (i = MinIndex; i <= MaxIndex; i++) {
X        printf("Fib(%d)", i);
X        if (i < 10) printf(" ");
X        printf(" = %4d\n", Fib(i));
X    }
}
X
/*
X * Function: Fib
X * Usage: t = Fib(n);
X * ------------------
X * This function returns the nth term in the Fibonacci
X * sequence.  In this implementation, the function Fib is
X * a simple wrapper that supplies additional arguments to
X * the more general function AdditiveSequence, which
X * does all the actual work.
X */
X
static int Fib(int n)
{
X    return (AdditiveSequence(n, 0, 1));
}
X
/*
X * Function: AdditiveSequence
X * Usage: t = AdditiveSequence(n, t0, t1);
X * ---------------------------------------
X * This function returns the nth term in any additive
X * sequence in which the first two terms are t0 and t1
X * and all subsequent  terms are the sum of the preceding
X * two terms.  The recursive  insight is that the nth term
X * in such a series is the (n-1)st term in the series that
X * begins with t1 and t0 + t1.
X */
X
static int AdditiveSequence(int n, int t0, int t1)
{
X    if (n == 0) return (t0);
X    if (n == 1) return (t1);
X    return (AdditiveSequence(n - 1, t1, t0 + t1));
}
X
SHAR_EOF
  $shar_touch -am 0903182097 'programs/04-Introduction-to-Recursion/fastfib.c' &&
  chmod 0644 'programs/04-Introduction-to-Recursion/fastfib.c' ||
  echo 'restore of programs/04-Introduction-to-Recursion/fastfib.c failed'
  shar_count="`wc -c < 'programs/04-Introduction-to-Recursion/fastfib.c'`"
  test 1734 -eq "$shar_count" ||
    echo "programs/04-Introduction-to-Recursion/fastfib.c: original size 1734, current size $shar_count"
fi
# ============= programs/04-Introduction-to-Recursion/fib.c ==============
if test -f 'programs/04-Introduction-to-Recursion/fib.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/04-Introduction-to-Recursion/fib.c (file already exists)'
else
  echo 'x - extracting programs/04-Introduction-to-Recursion/fib.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/04-Introduction-to-Recursion/fib.c' &&
/*
X * File: fib.c
X * -----------
X * This program lists the terms in the Fibonacci sequence with
X * indices ranging from MinIndex to MaxIndex.
X */
X
#include <stdio.h>
#include "genlib.h"
X
/* Constants */
X
#define MinIndex  0
#define MaxIndex 12
X
/* Function prototypes */
X
int Fib(int n);
X
/* Main program */
X
main()
{
X    int i;
X
X    printf("This program lists the Fibonacci sequence.\n");
X    for (i = MinIndex; i <= MaxIndex; i++) {
X        printf("Fib(%d)", i);
X        if (i < 10) printf(" ");
X        printf(" = %4d\n", Fib(i));
X    }
}
X
/*
X * Function: Fib
X * Usage: t = Fib(n);
X * ------------------
X * This function returns the nth term in the Fibonacci sequence
X * using a recursive implementation of the recurrence relation
X *
X *      Fib(n) = Fib(n - 1) + Fib(n - 2)
X */
X
int Fib(int n)
{
X    if (n < 2) {
X        return (n);
X    } else {
X        return (Fib(n - 1) + Fib(n - 2));
X    }
}
X
SHAR_EOF
  $shar_touch -am 0903182097 'programs/04-Introduction-to-Recursion/fib.c' &&
  chmod 0644 'programs/04-Introduction-to-Recursion/fib.c' ||
  echo 'restore of programs/04-Introduction-to-Recursion/fib.c failed'
  shar_count="`wc -c < 'programs/04-Introduction-to-Recursion/fib.c'`"
  test 901 -eq "$shar_count" ||
    echo "programs/04-Introduction-to-Recursion/fib.c: original size 901, current size $shar_count"
fi
# ============= programs/04-Introduction-to-Recursion/ifact.c ==============
if test -f 'programs/04-Introduction-to-Recursion/ifact.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/04-Introduction-to-Recursion/ifact.c (file already exists)'
else
  echo 'x - extracting programs/04-Introduction-to-Recursion/ifact.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/04-Introduction-to-Recursion/ifact.c' &&
/*
X * File: ifact.c
X * -------------
X * This program includes the Fact function and a test
X * program that prints the factorials of the numbers between
X * the limits LowerLimit and UpperLimit, inclusive.
X */
X
#include <stdio.h>
#include "genlib.h"
X
/*
X * Constants
X * ---------
X * LowerLimit -- Starting value for factorial table
X * UpperLimit -- Final value for factorial table
X */
X
#define LowerLimit 0
#define UpperLimit 7
X
/* Function prototypes */
X
static int Fact(int n);
X
/* Main program */
X
main()
{
X    int i;
X
X    for (i = LowerLimit; i <= UpperLimit; i++) {
X        printf("%d! = %5d\n", i, Fact(i));
X    }
}
X
X
/*
X * Function: Fact
X * Usage: f = Fact(n);
X * -------------------
X * This function returns the factorial of n, which is defined
X * as the product of all integers from 1 up to n.
X */
X
static int Fact(int n)
{
X    int product, i;
X
X    product = 1;
X    for (i = 1; i <= n; i++) {
X        product *= i;
X    }
X    return (product);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/04-Introduction-to-Recursion/ifact.c' &&
  chmod 0644 'programs/04-Introduction-to-Recursion/ifact.c' ||
  echo 'restore of programs/04-Introduction-to-Recursion/ifact.c failed'
  shar_count="`wc -c < 'programs/04-Introduction-to-Recursion/ifact.c'`"
  test 952 -eq "$shar_count" ||
    echo "programs/04-Introduction-to-Recursion/ifact.c: original size 952, current size $shar_count"
fi
# ============= programs/04-Introduction-to-Recursion/oddeven.c ==============
if test -f 'programs/04-Introduction-to-Recursion/oddeven.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/04-Introduction-to-Recursion/oddeven.c (file already exists)'
else
  echo 'x - extracting programs/04-Introduction-to-Recursion/oddeven.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/04-Introduction-to-Recursion/oddeven.c' &&
/*
X * File: oddeven.c
X * ---------------
X * This file defines mutually recursive IsOdd and IsEven
X * functions.
X */
X
#include <stdio.h>
#include <string.h>
#include "genlib.h"
#include "simpio.h"
X
/*
X * Constants
X * ---------
X * LowerLimit -- Starting value for odd/even table
X * UpperLimit -- Final value for odd/even table
X */
X
#define LowerLimit  0
#define UpperLimit 10
X
/* Function prototypes */
X
static bool IsEven(unsigned n);
static bool IsOdd(unsigned n);
X
/* Main program */
X
main()
{
X    unsigned i;
X
X    for (i = LowerLimit; i <= UpperLimit; i++) {
X        if (IsEven(i)) {
X            printf("%2d is even.\n", i);
X        } else {
X            printf("%2d is odd.\n", i);
X        }
X    }
}
X
/*
X * Function: IsEven
X * Usage: if (IsEven(n)) . . .
X * ---------------------------
X * This function returns TRUE if n is even.  The number 0
X * is considered even by definition; any other number is
X * even if its predecessor is odd.  Note that this function
X * is defined to take an unsigned argument and is therefore
X * not applicable to negative integers.
X */
X
static bool IsEven(unsigned n)
{
X    if (n == 0) {
X        return (TRUE);
X    } else {
X        return (IsOdd(n - 1));
X    }
}
X
/*
X * Function: IsOdd
X * Usage: if (IsOdd(n)) . . .
X * --------------------------
X * This function returns TRUE if n is odd, where a number
X * is defined to be odd if it is not even.  Note that this
X * function is defined to take an unsigned argument and is
X * therefore not applicable to negative integers.
X */
X
static bool IsOdd(unsigned n)
{
X    return (!IsEven(n));
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/04-Introduction-to-Recursion/oddeven.c' &&
  chmod 0644 'programs/04-Introduction-to-Recursion/oddeven.c' ||
  echo 'restore of programs/04-Introduction-to-Recursion/oddeven.c failed'
  shar_count="`wc -c < 'programs/04-Introduction-to-Recursion/oddeven.c'`"
  test 1567 -eq "$shar_count" ||
    echo "programs/04-Introduction-to-Recursion/oddeven.c: original size 1567, current size $shar_count"
fi
# ============= programs/04-Introduction-to-Recursion/palin.c ==============
if test -f 'programs/04-Introduction-to-Recursion/palin.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/04-Introduction-to-Recursion/palin.c (file already exists)'
else
  echo 'x - extracting programs/04-Introduction-to-Recursion/palin.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/04-Introduction-to-Recursion/palin.c' &&
/*
X * File: palin.c
X * -------------
X * This file tests a recursive implementation of IsPalindrome.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "simpio.h"
#include "strlib.h"
X
/* Function prototypes */
X
static bool IsPalindrome(string str);
X
/* Main program */
X
main()
{
X    string str;
X
X    printf("This program checks for palindromes.\n");
X    printf("Indicate end of input with a blank line.\n");
X    while (TRUE) {
X        printf("Enter a string: ");
X        str = GetLine();
X        if (StringEqual(str, "")) break;
X        if (IsPalindrome(str)) {
X            printf("'%s' is a palindrome.\n", str);
X        } else {
X            printf("'%s' is not a palindrome.\n", str);
X        }
X    }
}
X
/*
X * Function: IsPalindrome
X * Usage: if (IsPalindrome(str)) . . .
X * -----------------------------------
X * This function returns TRUE if the string is a palindrome.
X * This implementation operates recursively by noting that all
X * strings of length 0 or 1 are palindromes (the simple case)
X * and that longer strings are palindromes only if their first
X * and last characters match and the remaining substring is a
X * palindrome.
X */
X
static bool IsPalindrome(string str)
{
X    int len;
X
X    len = StringLength(str);
X    if (len <= 1) {
X        return (TRUE);
X    } else {
X        return (IthChar(str, 0) == IthChar(str, len - 1)
X                && IsPalindrome(SubString(str, 1, len - 2)));
X    }
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/04-Introduction-to-Recursion/palin.c' &&
  chmod 0644 'programs/04-Introduction-to-Recursion/palin.c' ||
  echo 'restore of programs/04-Introduction-to-Recursion/palin.c failed'
  shar_count="`wc -c < 'programs/04-Introduction-to-Recursion/palin.c'`"
  test 1410 -eq "$shar_count" ||
    echo "programs/04-Introduction-to-Recursion/palin.c: original size 1410, current size $shar_count"
fi
# ============= programs/04-Introduction-to-Recursion/palin2.c ==============
if test -f 'programs/04-Introduction-to-Recursion/palin2.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/04-Introduction-to-Recursion/palin2.c (file already exists)'
else
  echo 'x - extracting programs/04-Introduction-to-Recursion/palin2.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/04-Introduction-to-Recursion/palin2.c' &&
/*
X * File: palin2.c
X * --------------
X * This file tests a recursive implementation of IsPalindrome.
X * This implementation uses the array representation of strings
X * rather than the strlib.h library.
X */
X
#include <stdio.h>
#include <string.h>
#include "genlib.h"
#include "simpio.h"
X
/* Function prototypes */
X
static bool IsPalindrome(char str[]);
static bool CheckPalindrome(char str[], int len);
X
/* Main program */
X
main()
{
X    string str;
X
X    printf("This program checks for palindromes.\n");
X    printf("Indicate end of input with a blank line.\n");
X    while (TRUE) {
X        printf("Enter a string: ");
X        str = GetLine();
X        if (strlen(str) == 0) break;
X        if (IsPalindrome(str)) {
X            printf("'%s' is a palindrome.\n", str);
X        } else {
X            printf("'%s' is not a palindrome.\n", str);
X        }
X    }
}
X
/*
X * Function: IsPalindrome
X * Usage: if (IsPalindrome(str)) . . .
X * -----------------------------------
X * This function returns TRUE if the character string str
X * is a palindrome.  This level of the implementation is
X * just a wrapper for the CheckPalindrome function, which
X * does the real work.
X */
X
static bool IsPalindrome(char str[])
{
X    return (CheckPalindrome(str, strlen(str)));
}
X
/*
X * Function: CheckPalindrome
X * Usage: if (CheckPalindrome(str, len)) . . .
X * -------------------------------------------
X * This function returns TRUE if the next len characters
X * in the character array str form a palindrome.  The
X * implementation uses the recursive insight that all
X * strings of length 0 or 1 are palindromes (the simple
X * case) and that longer strings are palindromes only if
X * their first and last characters match and the remaining
X * substring is a palindrome.  Extracting the substring
X * is performed by array arithmetic.  The new substring
X * begins at str+1 and proceeds for len-2 characters.
X */
X
static bool CheckPalindrome(char str[], int len)
{
X    if (len <= 1) {
X        return (TRUE);
X    } else {
X        return (str[0] == str[len - 1]
X                && CheckPalindrome(str + 1, len - 2));
X    }
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/04-Introduction-to-Recursion/palin2.c' &&
  chmod 0644 'programs/04-Introduction-to-Recursion/palin2.c' ||
  echo 'restore of programs/04-Introduction-to-Recursion/palin2.c failed'
  shar_count="`wc -c < 'programs/04-Introduction-to-Recursion/palin2.c'`"
  test 2097 -eq "$shar_count" ||
    echo "programs/04-Introduction-to-Recursion/palin2.c: original size 2097, current size $shar_count"
fi
# ============= programs/04-Introduction-to-Recursion/Makefile ==============
if test -f 'programs/04-Introduction-to-Recursion/Makefile' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/04-Introduction-to-Recursion/Makefile (file already exists)'
else
  echo 'x - extracting programs/04-Introduction-to-Recursion/Makefile (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/04-Introduction-to-Recursion/Makefile' &&
# Makefile for programs in directory 04-Introduction-to-Recursion
# ***************************************************************
X
PROGRAMS = \
X    bsearch \
X    fact \
X    fastfib \
X    fib \
X    ifact \
X    oddeven \
X    palin \
X    palin2
X
# ***************************************************************
# Parameters to control Makefile operation
# Note that the gccx command script must be defined
X
CC = gccx
CFLAGS = 
X
# ***************************************************************
# Entry to bring the package up to date
X
all: $(PROGRAMS)
X
# ***************************************************************
# Standard entries to remove files from the directories
#    tidy    -- eliminate unwanted files
#    scratch -- delete derived files in preparation for rebuild
X
tidy:
X	rm -f ,* .,* *~ core a.out graphics.ps
X
scratch: tidy
X	rm -f *.o *.a $(PROGRAMS)
X
# ***************************************************************
# C compilations
X
bsearch.o: bsearch.c
X	$(CC) $(CFLAGS) -c bsearch.c
X
fact.o: fact.c
X	$(CC) $(CFLAGS) -c fact.c
X
fastfib.o: fastfib.c
X	$(CC) $(CFLAGS) -c fastfib.c
X
fib.o: fib.c
X	$(CC) $(CFLAGS) -c fib.c
X
ifact.o: ifact.c
X	$(CC) $(CFLAGS) -c ifact.c
X
oddeven.o: oddeven.c
X	$(CC) $(CFLAGS) -c oddeven.c
X
palin.o: palin.c
X	$(CC) $(CFLAGS) -c palin.c
X
palin2.o: palin2.c
X	$(CC) $(CFLAGS) -c palin2.c
X
X
# ***************************************************************
# Executable programs
X
bsearch: bsearch.o
X	$(CC) $(CFLAGS) -o bsearch bsearch.o
X
fact: fact.o
X	$(CC) $(CFLAGS) -o fact fact.o
X
fastfib: fastfib.o
X	$(CC) $(CFLAGS) -o fastfib fastfib.o
X
fib: fib.o
X	$(CC) $(CFLAGS) -o fib fib.o
X
ifact: ifact.o
X	$(CC) $(CFLAGS) -o ifact ifact.o
X
oddeven: oddeven.o
X	$(CC) $(CFLAGS) -o oddeven oddeven.o
X
palin: palin.o
X	$(CC) $(CFLAGS) -o palin palin.o
X
palin2: palin2.o
X	$(CC) $(CFLAGS) -o palin2 palin2.o
X
SHAR_EOF
  $shar_touch -am 0905205197 'programs/04-Introduction-to-Recursion/Makefile' &&
  chmod 0644 'programs/04-Introduction-to-Recursion/Makefile' ||
  echo 'restore of programs/04-Introduction-to-Recursion/Makefile failed'
  shar_count="`wc -c < 'programs/04-Introduction-to-Recursion/Makefile'`"
  test 1840 -eq "$shar_count" ||
    echo "programs/04-Introduction-to-Recursion/Makefile: original size 1840, current size $shar_count"
fi
# ============= programs/05-Recursive-Procedures/archway.c ==============
if test ! -d 'programs/05-Recursive-Procedures'; then
  echo 'x - creating directory programs/05-Recursive-Procedures'
  mkdir 'programs/05-Recursive-Procedures'
fi
if test -f 'programs/05-Recursive-Procedures/archway.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/05-Recursive-Procedures/archway.c (file already exists)'
else
  echo 'x - extracting programs/05-Recursive-Procedures/archway.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/05-Recursive-Procedures/archway.c' &&
/*
X * File: archway.c
X * ---------------
X * This program is a simple example of the graphics library
X * that draws an archway composed of a 1" square in which the
X * top side has been replaced by a semicircle.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "graphics.h"
X
main()
{
X    InitGraphics();
X    MovePen(2.0, 0.5);
X    DrawLine(1.0, 0.0);
X    DrawLine(0.0, 1.0);
X    DrawArc(0.5, 0, 180);
X    DrawLine(0.0, -1.0);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/05-Recursive-Procedures/archway.c' &&
  chmod 0644 'programs/05-Recursive-Procedures/archway.c' ||
  echo 'restore of programs/05-Recursive-Procedures/archway.c failed'
  shar_count="`wc -c < 'programs/05-Recursive-Procedures/archway.c'`"
  test 430 -eq "$shar_count" ||
    echo "programs/05-Recursive-Procedures/archway.c: original size 430, current size $shar_count"
fi
# ============= programs/05-Recursive-Procedures/hanoi.c ==============
if test -f 'programs/05-Recursive-Procedures/hanoi.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/05-Recursive-Procedures/hanoi.c (file already exists)'
else
  echo 'x - extracting programs/05-Recursive-Procedures/hanoi.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/05-Recursive-Procedures/hanoi.c' &&
/*
X * File: hanoi.c
X * -------------
X * This program solves the Tower of Hanoi problem.
X */
X
#include <stdio.h>
#include "genlib.h"
X
/*
X * Constants
X * ---------
X * NDisks -- Number of disks in the original tower
X */
X
#define NDisks 3
X
/* Function prototypes */
X
static void MoveTower(int n, char start, char finish, char temp);
static void MoveSingleDisk(char start, char finish);
X
/* Main program */
X
main()
{
X    int n;
X
X    MoveTower(NDisks, 'A', 'B', 'C');
}
X
/*
X * Function: MoveTower
X * Usage: MoveTower(n, start, finish, temp);
X * -----------------------------------------
X * This function is the heart of the recursive solution to the
X * Tower of Hanoi problem.  Calling
X *
X *       MoveTower(n, start, finish, temp)
X *
X * corresponds to the English command "Move a tower of size n
X * from start to finish using temp for intermediate storage."
X */
X
static void MoveTower(int n, char start, char finish, char temp)
{
X    if (n == 1) {
X        MoveSingleDisk(start, finish);
X    } else {
X        MoveTower(n - 1, start, temp, finish);
X        MoveSingleDisk(start, finish);
X        MoveTower(n - 1, temp, finish, start);
X    }
}
X
/*
X * Function: MoveSingleDisk
X * Usage: MoveSingleDisk(start, finish);
X * -------------------------------------
X * This function encapsulates the operation of moving a single
X * disk.  In this implementation, the function simply displays
X * instructions to the user.  In a more sophisticated program,
X * this function might update a graphical display.
X */
X
static void MoveSingleDisk(char start, char finish)
{
X    printf("%c -> %c\n", start, finish);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/05-Recursive-Procedures/hanoi.c' &&
  chmod 0644 'programs/05-Recursive-Procedures/hanoi.c' ||
  echo 'restore of programs/05-Recursive-Procedures/hanoi.c failed'
  shar_count="`wc -c < 'programs/05-Recursive-Procedures/hanoi.c'`"
  test 1592 -eq "$shar_count" ||
    echo "programs/05-Recursive-Procedures/hanoi.c: original size 1592, current size $shar_count"
fi
# ============= programs/05-Recursive-Procedures/koch.c ==============
if test -f 'programs/05-Recursive-Procedures/koch.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/05-Recursive-Procedures/koch.c (file already exists)'
else
  echo 'x - extracting programs/05-Recursive-Procedures/koch.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/05-Recursive-Procedures/koch.c' &&
/*
X * File: koch.c
X * ---------------
X * This program draws a Koch fractal.
X */
X
#include <stdio.h>
#include <math.h>
#include "genlib.h"
#include "simpio.h"
#include "graphics.h"
X
/* Mathematical constants */
X
#define Pi 3.1415926535
X
/* Private function prototypes */
X
static void KochFractal(double size, int order);
static void DrawFractalLine(double len, double theta, int order);
static void DrawPolarLine(double r, double theta);
X
/* Main program */
X
main()
{
X    double size;
X    int order;
X
X    InitGraphics();
X    printf("Program to draw Koch fractals\n");
X    printf("Enter edge length in inches: ");
X    size = GetReal();
X    printf("Enter order of fractal: ");
X    order = GetInteger();
X    KochFractal(size, order);
}
X
/*
X * Function: KochFractal
X * Usage: KochFractal(size, order);
X * --------------------------------
X * This function draws a Koch fractal snowflake centered in
X * the graphics window of the indicated size and order.
X */
X
static void KochFractal(double size, int order)
{
X    double x0, y0;
X
X    x0 = GetWindowWidth() / 2 - size / 2;
X    y0 = GetWindowHeight() / 2 - sqrt(3) * size / 6;
X    MovePen(x0, y0);
X    DrawFractalLine(size, 0, order);
X    DrawFractalLine(size, 120, order);
X    DrawFractalLine(size, 240, order);
}
X
/*
X * Function: DrawFractalLine
X * Usage: DrawFractalLine(len, theta, order);
X * ------------------------------------------
X * This function draws a fractal line of the given length, starting
X * from the current point and moving in direction theta.  If order
X * is 0, the fractal line is just a straight line.  If order is
X * greater than zero, the line is divided into four line segments,
X * each of which is a fractal line of the next lower order.  The
X * four segments connect the same endpoints as the straight line,
X * but include a triangular wedge replacing the center third of
X * the segment.
X */
X
static void DrawFractalLine(double len, double theta, int order)
{
X    if (order == 0) {
X        DrawPolarLine(len, theta);
X    } else {
X        DrawFractalLine(len/3, theta, order - 1);
X        DrawFractalLine(len/3, theta - 60, order - 1);
X        DrawFractalLine(len/3, theta + 60, order - 1);
X        DrawFractalLine(len/3, theta, order - 1);
X    }
}
X
/*
X * Function: DrawPolarLine
X * Usage: DrawPolarLine(r, theta);
X * -------------------------------
X * This function draws a line of length r in the direction
X * specified by the angle theta.  As in the DrawArc function,
X * theta is measured in degrees counterclockwise from the +x
X * axis.  This style of measurement is called "polar coordinates."
X */
X
static void DrawPolarLine(double r, double theta)
{
X    double radians;
X
X    radians = theta / 180 * Pi;
X    DrawLine(r * cos(radians), r * sin(radians));
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/05-Recursive-Procedures/koch.c' &&
  chmod 0644 'programs/05-Recursive-Procedures/koch.c' ||
  echo 'restore of programs/05-Recursive-Procedures/koch.c failed'
  shar_count="`wc -c < 'programs/05-Recursive-Procedures/koch.c'`"
  test 2731 -eq "$shar_count" ||
    echo "programs/05-Recursive-Procedures/koch.c: original size 2731, current size $shar_count"
fi
# ============= programs/05-Recursive-Procedures/mondrian.c ==============
if test -f 'programs/05-Recursive-Procedures/mondrian.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/05-Recursive-Procedures/mondrian.c (file already exists)'
else
  echo 'x - extracting programs/05-Recursive-Procedures/mondrian.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/05-Recursive-Procedures/mondrian.c' &&
/*
X * File: mondrian.c
X * ----------------
X * This program creates a random line drawing in a style reminiscent
X * of the Dutch painter Piet Mondrian.  The picture is generated by
X * recursively subdividing the canvas into successively smaller
X * rectangles with randomly chosen horizontal and vertical lines.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "random.h"
#include "graphics.h"
X
/*
X * Constants
X * ---------
X * MinArea -- Smallest square that will be split
X * MinEdge -- Minimum fraction on each side of dividing line
X */
X
#define MinArea  0.5
#define MinEdge  0.15
X
/* Private function prototypes */
X
static void SubdivideCanvas(double x, double y,
X                            double width, double height);
X
/* Main program */
X
main()
{
X    InitGraphics();
X    Randomize();
X    SubdivideCanvas(0, 0, GetWindowWidth(), GetWindowHeight());
}
X
/*
X * Function: SubdivideCanvas
X * Usage: SubdivideCanvas(x, y, width, height);
X * --------------------------------------------
X * This function decomposes a canvas by recursive subdivision.  The
X * lower left corner of the canvas is the point (x, y), and the
X * dimensions are given by the width and height parameters.  The
X * function first checks for the simple case, which is obtained
X * when the size of the rectangular canvas is too small to subdivide
X * (area < MinArea).  In the simple case, the function does nothing.
X * If the area is larger than the minimum, the function first
X * decides whether to split the canvas horizontally or vertically,
X * choosing the larger dimension.  The function then chooses a
X * random dividing line, making sure to leave at least MinEdge on
X * each side.  The program then uses a divide-and-conquer strategy
X * to subdivide the two new rectangles.
X */
X
static void SubdivideCanvas(double x, double y,
X                            double width, double height)
{
X    double divider;
X
X    if (width * height >= MinArea) {
X        if (width > height) {
X            divider = width * RandomReal(MinEdge, 1 - MinEdge);
X            MovePen(x + divider, y);
X            DrawLine(0, height);
X            SubdivideCanvas(x, y, divider, height);
X            SubdivideCanvas(x + divider, y, width - divider, height);
X        } else {
X            divider = height * RandomReal(MinEdge, 1 - MinEdge);
X            MovePen(x, y + divider);
X            DrawLine(width, 0);
X            SubdivideCanvas(x, y, width, divider);
X            SubdivideCanvas(x, y + divider, width, height - divider);
X        }
X    }
}
X
SHAR_EOF
  $shar_touch -am 0903182097 'programs/05-Recursive-Procedures/mondrian.c' &&
  chmod 0644 'programs/05-Recursive-Procedures/mondrian.c' ||
  echo 'restore of programs/05-Recursive-Procedures/mondrian.c failed'
  shar_count="`wc -c < 'programs/05-Recursive-Procedures/mondrian.c'`"
  test 2499 -eq "$shar_count" ||
    echo "programs/05-Recursive-Procedures/mondrian.c: original size 2499, current size $shar_count"
fi
# ============= programs/05-Recursive-Procedures/permute.c ==============
if test -f 'programs/05-Recursive-Procedures/permute.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/05-Recursive-Procedures/permute.c (file already exists)'
else
  echo 'x - extracting programs/05-Recursive-Procedures/permute.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/05-Recursive-Procedures/permute.c' &&
/*
X * File: permute.c
X * ---------------
X * This file implements and tests the ListPermutation function.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "strlib.h"
#include "simpio.h"
X
/* Private function prototypes */
X
static void ListPermutations(string str);
static void RecursivePermute(string str, int k);
static void ExchangeCharacters(string str, int p1, int p2);
X
/* Main program */
X
main()
{
X    string str;
X
X    printf("This program lists all permutations of a string.\n");
X    printf("Enter a string: ");
X    str = GetLine();
X    ListPermutations(str);
}
X
/*
X * Function: ListPermutations
X * Usage: ListPermutations(str)
X * ----------------------------
X * This function lists all permutations of the characters
X * in the string str.
X */
X
static void ListPermutations(string str)
{
X    RecursivePermute(str, 0);
}
X
/*
X * Function: RecursivePermute
X * Usage: RecursivePermute(str, k);
X * --------------------------------
X * This function implements the recursive permutation algorithm.
X * In English, this function corresponds to the imperative
X * statement: Generate and print all permutations of the string
X * str, holding the first k character fixed.  The recursive insight
X * is that the permutations of n characters consist of each of
X * those characters followed by all permutations of the remaining
X * n-1 characters.
X */
X
static void RecursivePermute(string str, int k)
{
X    int i;
X
X    if (k == StringLength(str)) {
X        printf("%s\n", str);
X    } else {
X        for (i = k; i < StringLength(str); i++) {
X            ExchangeCharacters(str, k, i);
X            RecursivePermute(str, k + 1);
X            ExchangeCharacters(str, k, i);
X        }
X    }
}
X
/*
X * Function: ExchangeCharacters
X * Usage: ExchangeCharacters(str, p1, p2);
X * ---------------------------------------
X * This function exchanges the characters at positions p1
X * and p2 of the string s.
X */
X
static void ExchangeCharacters(string str, int p1, int p2)
{
X    char tmp;
X
X    tmp = str[p1];
X    str[p1] = str[p2];
X    str[p2] = tmp;
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/05-Recursive-Procedures/permute.c' &&
  chmod 0644 'programs/05-Recursive-Procedures/permute.c' ||
  echo 'restore of programs/05-Recursive-Procedures/permute.c failed'
  shar_count="`wc -c < 'programs/05-Recursive-Procedures/permute.c'`"
  test 2029 -eq "$shar_count" ||
    echo "programs/05-Recursive-Procedures/permute.c: original size 2029, current size $shar_count"
fi
# ============= programs/05-Recursive-Procedures/Makefile ==============
if test -f 'programs/05-Recursive-Procedures/Makefile' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/05-Recursive-Procedures/Makefile (file already exists)'
else
  echo 'x - extracting programs/05-Recursive-Procedures/Makefile (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/05-Recursive-Procedures/Makefile' &&
# Makefile for programs in directory 05-Recursive-Procedures
# ***************************************************************
X
PROGRAMS = \
X    archway \
X    hanoi \
X    koch \
X    mondrian \
X    permute
X
# ***************************************************************
# Parameters to control Makefile operation
# Note that the gccx command script must be defined
X
CC = gccx
CFLAGS = 
X
# ***************************************************************
# Entry to bring the package up to date
X
all: $(PROGRAMS)
X
# ***************************************************************
# Standard entries to remove files from the directories
#    tidy    -- eliminate unwanted files
#    scratch -- delete derived files in preparation for rebuild
X
tidy:
X	rm -f ,* .,* *~ core a.out graphics.ps
X
scratch: tidy
X	rm -f *.o *.a $(PROGRAMS)
X
# ***************************************************************
# C compilations
X
archway.o: archway.c
X	$(CC) $(CFLAGS) -c archway.c
X
hanoi.o: hanoi.c
X	$(CC) $(CFLAGS) -c hanoi.c
X
koch.o: koch.c
X	$(CC) $(CFLAGS) -c koch.c
X
mondrian.o: mondrian.c
X	$(CC) $(CFLAGS) -c mondrian.c
X
permute.o: permute.c
X	$(CC) $(CFLAGS) -c permute.c
X
X
# ***************************************************************
# Executable programs
X
archway: archway.o
X	$(CC) $(CFLAGS) -o archway archway.o
X
hanoi: hanoi.o
X	$(CC) $(CFLAGS) -o hanoi hanoi.o
X
koch: koch.o
X	$(CC) $(CFLAGS) -o koch koch.o
X
mondrian: mondrian.o
X	$(CC) $(CFLAGS) -o mondrian mondrian.o
X
permute: permute.o
X	$(CC) $(CFLAGS) -o permute permute.o
X
SHAR_EOF
  $shar_touch -am 0905205197 'programs/05-Recursive-Procedures/Makefile' &&
  chmod 0644 'programs/05-Recursive-Procedures/Makefile' ||
  echo 'restore of programs/05-Recursive-Procedures/Makefile failed'
  shar_count="`wc -c < 'programs/05-Recursive-Procedures/Makefile'`"
  test 1527 -eq "$shar_count" ||
    echo "programs/05-Recursive-Procedures/Makefile: original size 1527, current size $shar_count"
fi
# ============= programs/06-Backtracking-Algorithms/example.maz ==============
if test ! -d 'programs/06-Backtracking-Algorithms'; then
  echo 'x - creating directory programs/06-Backtracking-Algorithms'
  mkdir 'programs/06-Backtracking-Algorithms'
fi
if test -f 'programs/06-Backtracking-Algorithms/example.maz' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/06-Backtracking-Algorithms/example.maz (file already exists)'
else
  echo 'x - extracting programs/06-Backtracking-Algorithms/example.maz (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/06-Backtracking-Algorithms/example.maz' &&
+-+-+-+-+-+-+-+
| |       |   |
+ + +-+-+ +-+ +
|   |   |   | |
+ + + + +-+ + +
| | | | | |   |
+ +-+-+ + +-+ +
| |    S|   | |
+ + +-+ +-+ + +
| |   |     | |
+ +-+ +-+-+ + +
|   |     |   |
+ + +-+-+ +-+-+
| |     |     |
+-+-+-+ +-+-+-+
SHAR_EOF
  $shar_touch -am 0906095797 'programs/06-Backtracking-Algorithms/example.maz' &&
  chmod 0644 'programs/06-Backtracking-Algorithms/example.maz' ||
  echo 'restore of programs/06-Backtracking-Algorithms/example.maz failed'
  shar_count="`wc -c < 'programs/06-Backtracking-Algorithms/example.maz'`"
  test 240 -eq "$shar_count" ||
    echo "programs/06-Backtracking-Algorithms/example.maz: original size 240, current size $shar_count"
fi
# ============= programs/06-Backtracking-Algorithms/maze.c ==============
if test -f 'programs/06-Backtracking-Algorithms/maze.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/06-Backtracking-Algorithms/maze.c (file already exists)'
else
  echo 'x - extracting programs/06-Backtracking-Algorithms/maze.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/06-Backtracking-Algorithms/maze.c' &&
/*
X * File: maze.c
X * ------------
X * This program solves a maze by recursive backtracking.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "mazelib.h"
X
/*
X * Constants
X * ---------
X * MazeFile -- Name of the file containing the maze
X */
X
#define MazeFile "example.maz"
X
/* Private function prototypes */
X
static bool SolveMaze(pointT pt);
static pointT AdjacentPoint(pointT pt, directionT dir);
X
/* Main program */
X
main()
{
X    ReadMazeMap(MazeFile);
X    if (SolveMaze(GetStartPosition())) {
X        printf("The marked squares show a solution path.\n");
X    } else {
X        printf("No solution exists.\n");
X    }
}
X
/*
X * Function: SolveMaze
X * Usage: if (SolveMaze(pt)) . . .
X * -------------------------------
X * This function attempts to generate a solution to the current
X * maze from point pt.  SolveMaze returns TRUE if the maze has
X * a solution and FALSE otherwise.  The implementation uses
X * recursion to solve the submazes that result from marking the
X * current square and moving one step along each open passage.
X */
X
static bool SolveMaze(pointT pt)
{
X    directionT dir;
X
X    if (OutsideMaze(pt)) return (TRUE);
X    if (IsMarked(pt)) return (FALSE);
X    MarkSquare(pt);
X    for (dir = North; dir <= West; dir++) {
X        if (!WallExists(pt, dir)) {
X            if (SolveMaze(AdjacentPoint(pt, dir))) {
X                return (TRUE);
X            }
X        }
X    }
X    UnmarkSquare(pt);
X    return (FALSE);
}
X
/*
X * Function: AdjacentPoint
X * Usage: newpt = AdjacentPoint(pt, dir);
X * --------------------------------------
X * This function returns the pointT that results from moving
X * one square from pt in the direction specified by dir.  For
X * example, if pt is the point (1,1), AdjacentPoint(pt, East)
X * would return the point (2,1).
X */
X
static pointT AdjacentPoint(pointT pt, directionT dir)
{
X    pointT newpt;
X
X    newpt = pt;
X    switch (dir) {
X      case North: newpt.y++; break;
X      case East:  newpt.x++; break;
X      case South: newpt.y--; break;
X      case West:  newpt.x--; break;;
X    }
X    return (newpt);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/06-Backtracking-Algorithms/maze.c' &&
  chmod 0644 'programs/06-Backtracking-Algorithms/maze.c' ||
  echo 'restore of programs/06-Backtracking-Algorithms/maze.c failed'
  shar_count="`wc -c < 'programs/06-Backtracking-Algorithms/maze.c'`"
  test 2053 -eq "$shar_count" ||
    echo "programs/06-Backtracking-Algorithms/maze.c: original size 2053, current size $shar_count"
fi
# ============= programs/06-Backtracking-Algorithms/mazelib.h ==============
if test -f 'programs/06-Backtracking-Algorithms/mazelib.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/06-Backtracking-Algorithms/mazelib.h (file already exists)'
else
  echo 'x - extracting programs/06-Backtracking-Algorithms/mazelib.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/06-Backtracking-Algorithms/mazelib.h' &&
/*
X * File: mazelib.h
X * ---------------
X * This interface provides a library of primitive operations
X * to simplify the solution to the maze problem.
X */
X
#ifndef _mazelib_h
#define _mazelib_h
X
#include "genlib.h"
X
/*
X * Type: pointT
X * ------------
X * The type pointT is used to encapsulate a pair of integer
X * coordinates into a single value with x and y components.
X */
X
typedef struct {
X    int x, y;
} pointT;
X
/*
X * Type: directionT
X * ----------------
X * This type is used to represent the four compass directions.
X */
X
typedef enum { North, East, South, West } directionT;
X
/*
X * Function: ReadMazeMap
X * Usage: ReadMazeMap(filename);
X * -----------------------------
X * This function reads in a map of the maze from the specified
X * file and stores it in private data structures maintained by
X * this module.  In the data file, the characters '+', '-', and
X * '|' represent corners, horizontal walls, and vertical walls,
X * respectively; spaces represent open passageway squares.  The
X * starting position is indicated by the character 'S'.  For
X * example, the following data file defines a simple maze:
X *
X *       +-+-+-+-+-+
X *       |     |
X *       + +-+ + +-+
X *       |S  |     |
X *       +-+-+-+-+-+
X *
X * Coordinates are numbered starting at (0,0) in the lower left.
X */
X
void ReadMazeMap(string filename);
X
/*
X * Function: GetStartPosition
X * Usage: pt = GetStartPosition();
X * -------------------------------
X * This function returns a pointT indicating the coordinates of
X * the start square.
X */
X
pointT GetStartPosition(void);
X
/*
X * Function: OutsideMaze
X * Usage: if (OutsideMaze(pt)) . . .
X * ---------------------------------
X * This function returns TRUE if the specified point is outside
X * the boundary of the maze.
X */
X
bool OutsideMaze(pointT pt);
X
/*
X * Function: WallExists
X * Usage: if (WallExists(pt, dir)) . . .
X * -------------------------------------
X * This function returns TRUE if there is a wall in the indicated
X * direction from the square at position pt.
X */
X
bool WallExists(pointT pt, directionT dir);
X
/*
X * Functions: MarkSquare, UnmarkSquare, IsMarked
X * Usage: MarkSquare(pt);
X *        UnmarkSquare(pt);
X *        if (IsMarked(pt)) . . .
X * ------------------------------
X * These functions mark, unmark, and test the status of the
X * square specified by the coordinates pt.
X */
X
void MarkSquare(pointT pt);
void UnmarkSquare(pointT pt);
bool IsMarked(pointT pt);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/06-Backtracking-Algorithms/mazelib.h' &&
  chmod 0644 'programs/06-Backtracking-Algorithms/mazelib.h' ||
  echo 'restore of programs/06-Backtracking-Algorithms/mazelib.h failed'
  shar_count="`wc -c < 'programs/06-Backtracking-Algorithms/mazelib.h'`"
  test 2428 -eq "$shar_count" ||
    echo "programs/06-Backtracking-Algorithms/mazelib.h: original size 2428, current size $shar_count"
fi
# ============= programs/06-Backtracking-Algorithms/nim.c ==============
if test -f 'programs/06-Backtracking-Algorithms/nim.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/06-Backtracking-Algorithms/nim.c (file already exists)'
else
  echo 'x - extracting programs/06-Backtracking-Algorithms/nim.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/06-Backtracking-Algorithms/nim.c' &&
/*
X * File: nim.c
X * -----------
X * This program simulates a simple variant of the game of nim.
X * In this version, the game starts with a pile of 13 coins
X * on a table.  Players then take turns removing 1, 2, or 3
X * coins from the pile.  The player who takes the last coin
X * loses.  This simulation allows a human player to compete
X * against the computer.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "simpio.h"
#include "strlib.h"
X
/*
X * Constants
X * ---------
X * InitialCoins -- Initial number of coins
X * MaxTake      -- The maximum number of coins a player may take
X * NoGoodMove   -- Sentinel indicating no good move is available
X */
X
#define InitialCoins 13
#define MaxTake       3
#define NoGoodMove   -1
X
/*
X * Type: playerT
X * -------------
X * This enumeration type distinguishes the turns for the human
X * player from those for the computer.
X */
X
typedef enum { Human, Computer } playerT;
X
/* Private function prototypes */
X
static void GiveInstructions(void);
static void AnnounceWinner(int nCoins, playerT whoseTurn);
static int GetUserMove(int nCoins);
static bool MoveIsLegal(int nTaken, int nCoins);
static int ChooseComputerMove(int nCoins);
static int FindGoodMove(int nCoins);
static bool IsBadPosition(int nCoins);
X
/*
X * Main program
X * ------------
X * This program plays the game of nim.  In this implementation,
X * the human player always goes first.
X */
X
main()
{
X    int nCoins, nTaken;
X    playerT whoseTurn;
X
X    GiveInstructions();
X    nCoins = InitialCoins;
X    whoseTurn = Human;
X    while (nCoins > 1) {
X        printf("There are %d coins in the pile.\n", nCoins);
X        switch (whoseTurn) {
X          case Human:
X            nTaken = GetUserMove(nCoins);
X            whoseTurn = Computer;
X            break;
X          case Computer:
X            nTaken = ChooseComputerMove(nCoins);
X            printf("I'll take %d.\n", nTaken);
X            whoseTurn = Human;
X            break;
X        }
X        nCoins -= nTaken;
X    }
X    AnnounceWinner(nCoins, whoseTurn);
}
X
/*
X * Function: GiveInstructions
X * Usage: GiveInstructions();
X * --------------------------
X * This function explains the rules of the game to the user.
X */
X
static void GiveInstructions(void)
{
X    printf("Hello.  Welcome to the game of nim.\n");
X    printf("In this game, we will start with a pile of\n");
X    printf("%d coins on the table.  ", InitialCoins);
X    printf("On each turn, you\n");
X    printf("and I will alternately take between 1 and\n");
X    printf("%d coins from the table.  ", MaxTake);
X    printf("The player who\n");
X    printf("takes the last coin loses.\n");
X    printf("\n");
}
X
/*
X * Function: AnnounceWinner
X * Usage: AnnounceWinner(nCoins, whoseTurn);
X * -----------------------------------------
X * This function announces the final result of the game.
X */
X
static void AnnounceWinner(int nCoins, playerT whoseTurn)
{
X    if (nCoins == 0) {
X        printf("You took the last coin.  You lose.\n");
X    } else {
X        printf("There is only one coin left.\n");
X        switch (whoseTurn) {
X          case Human:    printf("I win.\n"); break;
X          case Computer: printf("I lose.\n"); break;
X        }
X    }
}
X
/*
X * Function: GetUserMove
X * Usage: nTaken = GetUserMove(nCoins);
X * ------------------------------------
X * This function is responsible for the human player's turn.
X * It takes the number of coins left in the pile as an argument,
X * and returns the number of coins that the player removes
X * from the pile.  The function checks the move for legality
X * and gives the player repeated chances to enter a legal move.
X */
X
static int GetUserMove(int nCoins)
{
X    int nTaken, limit;
X
X    while (TRUE) {
X        printf("How many would you like? ");
X        nTaken = GetInteger();
X        if (MoveIsLegal(nTaken, nCoins)) break;
X        limit = (nCoins < MaxTake) ? nCoins : MaxTake;
X        printf("That's cheating!  Please choose a number");
X        printf(" between 1 and %d.\n", limit);
X        printf("There are %d coins in the pile.\n", nCoins);
X    }
X    return (nTaken);
}
X
/*
X * Function: MoveIsLegal
X * Usage: if (MoveIsLegal(nTaken, nCoins)) . . .
X * ---------------------------------------------
X * This predicate function returns TRUE if it is legal to take
X * nTaken coins from a pile of nCoins.
X */
X
static bool MoveIsLegal(int nTaken, int nCoins)
{
X    return (nTaken > 0 && nTaken <= MaxTake && nTaken <= nCoins);
}
X
/*
X * Function: ChooseComputerMove
X * Usage: nTaken = ChooseComputerMove(nCoins);
X * -------------------------------------------
X * This function figures out what move is best for the computer
X * player and returns the number of coins taken.  The function
X * first calls FindGoodMove to see if a winning move exists.
X * If none does, the program takes only one coin to give the
X * human player more chances to make a mistake.
X */
X
static int ChooseComputerMove(int nCoins)
{
X    int nTaken;
X
X    nTaken = FindGoodMove(nCoins);
X    if (nTaken == NoGoodMove) nTaken = 1;
X    return (nTaken);
}
X
/*
X * Function: FindGoodMove
X * Usage: nTaken = FindGoodMove(nCoins);
X * -------------------------------------
X * This function looks for a winning move, given the specified
X * number of coins.  If there is a winning move in that
X * position, the function returns that value; if not, the
X * function returns the constant NoWinningMove.  This function
X * depends on the recursive insight that a good move is one
X * that leaves your opponent in a bad position and a bad
X * position is one that offers no good moves.
X */
X
static int FindGoodMove(int nCoins)
{
X    int nTaken;
X
X    for (nTaken = 1; nTaken <= MaxTake; nTaken++) {
X        if (IsBadPosition(nCoins - nTaken)) return (nTaken);
X    }
X    return (NoGoodMove);
}
X
/*
X * Function: IsBadPosition
X * Usage: if (IsBadPosition(nCoins)) . . .
X * ---------------------------------------
X * This function returns TRUE if nCoins is a bad position.
X * A bad position is one in which there is no good move.
X * Being left with a single coin is clearly a bad position
X * and represents the simple case of the recursion.
X */
X
static bool IsBadPosition(int nCoins)
{
X    if (nCoins == 1) return (TRUE);
X    return (FindGoodMove(nCoins) == NoGoodMove);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/06-Backtracking-Algorithms/nim.c' &&
  chmod 0644 'programs/06-Backtracking-Algorithms/nim.c' ||
  echo 'restore of programs/06-Backtracking-Algorithms/nim.c failed'
  shar_count="`wc -c < 'programs/06-Backtracking-Algorithms/nim.c'`"
  test 6173 -eq "$shar_count" ||
    echo "programs/06-Backtracking-Algorithms/nim.c: original size 6173, current size $shar_count"
fi
# ============= programs/06-Backtracking-Algorithms/tictac.c ==============
if test -f 'programs/06-Backtracking-Algorithms/tictac.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/06-Backtracking-Algorithms/tictac.c (file already exists)'
else
  echo 'x - extracting programs/06-Backtracking-Algorithms/tictac.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/06-Backtracking-Algorithms/tictac.c' &&
/*
X * File: tictac.c
X * --------------
X * This program plays a game of tic-tac-toe with the user.
X * The program is designed to emphasize the separation between
X * those aspects of the code that are common to all games and
X * those that are specific to tic-tac-toe.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "simpio.h"
#include "strlib.h"
X
/*
X * Constants: WinningPosition, NeutralPosition, LosingPosition
X * -----------------------------------------------------------
X * These constants define a rating system for game positions.
X * A rating is an integer centered at 0 as the neutral score:
X * ratings greater than 0 are good for the cuurent player,
X * ratings less than 0 are good for the opponent.  The
X * constants WinningPosition and LosingPosition are opposite
X * in value and indicate a position that is a forced win or
X * loss, respectively.  In a game in which the analysis is
X * complete, no intermediate values ever arise.  If the full
X * tree is too large to analyze, the EvaluatePosition function
X * returns integers that fall between the two extremes.
X */
X
#define WinningPosition  1000
#define NeutralPosition  0
#define LosingPosition   (-WinningPosition)
X
/*
X * Type: playerT
X * -------------
X * This type is used to distinguish the human and computer
X * players and keep track of who has the current turn.
X */
X
typedef enum { Human, Computer } playerT;
X
/*
X * Type: moveT
X * -----------
X * For any particular game, the moveT type must keep track of the
X * information necessary to describe a move.  For tic-tac-toe,
X * a moveT is simply an integer identifying the number of one of
X * the nine squares.
X */
X
typedef int moveT;
X
/*
X * Type: stateT
X * ------------
X * For any game, the stateT structure records the current state
X * of the game.  For tic-tac-toe, the main component of the
X * state record is the board, which is an array of characters
X * using 'X' for the first player, 'O' for the second, and ' '
X * for empty squares.  Although the board array is logically
X * a two-dimensional structure, it is stored as a linear array
X * so that its indices match the numbers used by the human
X * player to refer to the squares, as follows:
X *
X *        1 | 2 | 3
X *       ---+---+---
X *        4 | 5 | 6
X *       ---+---+---
X *        7 | 8 | 9
X *
X * Note that element 0 is not used, which requires allocation
X * of an extra element.
X *
X * In addition to the board array, the code stores a playerT
X * value to indicate whose turn it is.  In this example, the
X * stateT structure also contains the total number of moves
X * so that functions can check this entry without counting
X * the number of occupied squares.
X */
X
typedef struct {
X    char board[(3 * 3) + 1];
X    playerT whoseTurn;
X    int turnsTaken;
} *stateT;
X
/*
X * Constant: MaxMoves
X * ------------------
X * This constant indicates the maximum number of legal moves
X * available on a turn and is used to allocate array space for
X * the legal move list.  This constant will change according
X * to the specifics of the game.  For tic-tac-toe, there are
X * never more than nine possible moves.
X */
X
#define MaxMoves 9
X
/*
X * Constant: MaxDepth
X * ------------------
X * This constant indicates the maximum depth to which the
X * recursive search for the best move is allowed to proceed.
X * The use of a very large number for this constant ensures
X * that the analysis is carried out to the end of the game.
X */
X
#define MaxDepth 10000
X
/*
X * Constant: FirstPlayer
X * ---------------------
X * This constant indicates whether the human or the computer
X * player goes first and should be one of the enumerated
X * constants: Human or Computer.
X */
X
#define FirstPlayer Computer
X
/*
X * Private variable: winningLines
X * ------------------------------
X * This two-dimensional array contains the index numbers of
X * the cells in each of the winning combinations.  Although
X * it is easy for the program to compute these values as it
X * runs, storing them in advance speeds up the execution.
X */
X
static int winningLines[][3] = {
X    { 1, 2, 3 },
X    { 4, 5, 6 },
X    { 7, 8, 9 },
X    { 1, 4, 7 },
X    { 2, 5, 8 },
X    { 3, 6, 9 },
X    { 1, 5, 9 },
X    { 3, 5, 7 }
};
static int nWinningLines = sizeof winningLines
X                           / sizeof winningLines[0];
X
/* Private function prototypes */
X
static moveT FindBestMove(stateT state, int depth, int *pRating);
static int EvaluatePosition(stateT state, int depth);
static stateT NewGame(void);
static void DisplayGame(stateT state);
static void DisplayMove(moveT move);
static void GiveInstructions(void);
static char PlayerMark(playerT player);
static moveT GetUserMove(stateT state);
static bool MoveIsLegal(moveT move, stateT state);
static moveT ChooseComputerMove(stateT state);
static int GenerateMoveList(stateT state, moveT moveArray[]);
static void MakeMove(stateT state, moveT move);
static void RetractMove(stateT state, moveT move);
static void AnnounceResult(stateT state);
static bool GameIsOver(stateT state);
static int EvaluateStaticPosition(stateT state);
static bool CheckForWin(stateT state, playerT player);
static playerT WhoseTurn(stateT state);
static playerT Opponent(playerT player);
X
/*
X * Main program
X * ------------
X * The main program, along with the functions FindBestMove and
X * EvaluatePosition, are general in their design and can be
X * used with most two-player games.  The specific details of
X * tic-tac-toe do not appear in these functions and are instead
X * encapsulated in the stateT and moveT data structures and a
X * a variety of subsidiary functions.
X */
X
main()
{
X    stateT state;
X    moveT move;
X
X    GiveInstructions();
X    state = NewGame();
X    while (!GameIsOver(state)) {
X        DisplayGame(state);
X        switch (WhoseTurn(state)) {
X          case Human:
X            move = GetUserMove(state);
X            break;
X          case Computer:
X            move = ChooseComputerMove(state);
X            DisplayMove(move);
X            break;
X        }
X        MakeMove(state, move);
X    }
X    AnnounceResult(state);
}
X
/*
X * Function: FindBestMove
X * Usage: move = FindBestMove(state, depth, pRating);
X * --------------------------------------------------
X * This function finds the best move for the current player, given
X * the specified state of the game.  The depth parameter and the
X * constant MaxDepth are used to limit the depth of the search
X * for games that are too difficult to analyze in full detail.
X * The function returns the best move and stores its rating in
X * the integer variable to which pRating points.
X */
X
static moveT FindBestMove(stateT state, int depth, int *pRating)
{
X    moveT moveArray[MaxMoves], move, bestMove;
X    int i, nMoves, rating, minRating;
X
X    nMoves = GenerateMoveList(state, moveArray);
X    if (nMoves == 0) Error("No moves available");
X    minRating = WinningPosition + 1;
X    for (i = 0; i < nMoves && minRating != LosingPosition; i++) {
X        move = moveArray[i];
X        MakeMove(state, move);
X        rating = EvaluatePosition(state, depth + 1);
X        if (rating < minRating) {
X            bestMove = move;
X            minRating = rating;
X        }
X        RetractMove(state, move);
X    }
X    *pRating = -minRating;
X    return (bestMove);
}
X
/*
X * Function: EvaluatePosition
X * Usage: rating = EvaluatePosition(state, depth);
X * -----------------------------------------------
X * This function evaluates a position by finding the rating of
X * the best move in that position.  The depth parameter and the
X * constant MaxDepth are used to limit the depth of the search.
X */
X
static int EvaluatePosition(stateT state, int depth)
{
X    int rating;
X
X    if (GameIsOver(state) || depth >= MaxDepth) {
X        return (EvaluateStaticPosition(state));
X    }
X    (void) FindBestMove(state, depth, &rating);
X    return (rating);
}
X
/*
X * Function: NewGame
X * Usage: state = NewGame();
X * -------------------------
X * This function starts a new game and returns a stateT that
X * has been initialized to the defined starting configuration.
X */
X
static stateT NewGame(void)
{
X    stateT state;
X    int i;
X
X    state = New(stateT);
X    for (i = 1; i <= 9; i++) {
X        state->board[i] = ' ';
X    }
X    state->whoseTurn = FirstPlayer;
X    state->turnsTaken = 0;
X    return (state);
}
X
/*
X * Function: DisplayGame
X * Usage: DisplayGame(state);
X * --------------------------
X * This function displays the current state of the game.
X */
X
static void DisplayGame(stateT state)
{
X    int row, col;
X
X    if (GameIsOver(state)) {
X        printf("\nThe final position looks like this:\n\n");
X    } else {
X        printf("\nThe game now looks like this:\n\n");
X    }
X    for (row = 0; row < 3; row++) {
X        if (row != 0) printf("---+---+---\n");
X        for (col = 0; col < 3; col++) {
X            if (col != 0) printf("|");
X            printf(" %c ", state->board[row * 3 + col + 1]);
X        }
X        printf("\n");
X    }
X    printf("\n");
}
X
/*
X * Function: DisplayMove
X * Usage: DisplayMove(move);
X * -------------------------
X * This function displays the computer's move.
X */
X
static void DisplayMove(moveT move)
{
X    printf("I'll move to square %d.\n", move);
}
X
/*
X * Function: GiveInstructions
X * Usage: GiveInstructions();
X * --------------------------
X * This function gives the player instructions about how to
X * play the game.
X */
X
static void GiveInstructions(void)
{
X    printf("Welcome to tic-tac-toe.  The object of the game\n");
X    printf("is to line up three symbols in a row, vertically,\n");
X    printf("horizontally, or diagonally.  You'll be %c and\n",
X           PlayerMark(Human));
X    printf("I'll be %c.\n", PlayerMark(Computer));
}
X
/*
X * Function: PlayerMark
X * Usage: mark = PlayerMark(player);
X * ---------------------------------
X * This function returns the mark used on the board to indicate
X * the specified player.  By convention, the first player is
X * always X, so the mark used for each player depends on who
X * goes first.
X */
X
static char PlayerMark(playerT player)
{
X    if (player == FirstPlayer) {
X        return ('X');
X    } else {
X        return ('O');
X    }
}
X
/*
X * Function: GetUserMove
X * Usage: move = GetUserMove(state);
X * ---------------------------------
X * This function allows the user to enter a move and returns the
X * number of the chosen square.  If the user specifies an illegal
X * move, this function gives the user the opportunity to enter
X * a legal one.
X */
X
static moveT GetUserMove(stateT state)
{
X    moveT move;
X
X    printf("Your move.\n");
X    while (TRUE) {
X        printf("What square? ");
X        move = GetInteger();
X        if (MoveIsLegal(move, state)) break;
X        printf("That move is illegal.  Try again.\n");
X    }
X    return (move);
}
X
/*
X * Function: MoveIsLegal
X * Usage: if (MoveIsLegal(move, state)) . . .
X * ------------------------------------------
X * This function returns TRUE if the specified move is legal
X * in the current state.
X */
X
static bool MoveIsLegal(moveT move, stateT state)
{
X    return (move >= 1 && move <= 9 && state->board[move] == ' ');
}
X
/*
X * Function: ChooseComputerMove
X * Usage: move = ChooseComputerMove(state);
X * ----------------------------------------
X * This function chooses the computer's move and is primarily
X * a wrapper for FindBestMove.  This function also makes it
X * possible to display any game-specific messages that need
X * to appear at the beginning of the computer's turn.  The
X * rating value returned by FindBestMove is simply discarded.
X */
X
static moveT ChooseComputerMove(stateT state)
{
X    int rating;
X
X    printf("My move.\n");
X    return (FindBestMove(state, 0, &rating));
}
X
/*
X * Function: GenerateMoveList
X * Usage: n = GenerateMoveList(state, moveArray);
X * ----------------------------------------------
X * This function generates a list of the legal moves available in
X * the specified state.  The list of moves is returned in the
X * array moveArray, which must be allocated by the client.  The
X * function returns the number of legal moves.
X */
X
static int GenerateMoveList(stateT state, moveT moveArray[])
{
X    int i, nMoves;
X
X    nMoves = 0;
X    for (i = 1; i <= 9; i++) {
X        if (state->board[i] == ' ') {
X            moveArray[nMoves++] = (moveT) i;
X        }
X    }
X    return (nMoves);
}
X
/*
X * Function: MakeMove
X * Usage: MakeMove(state, move);
X * -----------------------------
X * This function changes the state of the game by making the
X * indicated move.
X */
X
static void MakeMove(stateT state, moveT move)
{
X    state->board[move] = PlayerMark(state->whoseTurn);
X    state->whoseTurn = Opponent(state->whoseTurn);
X    state->turnsTaken++;
}
X
/*
X * Function: RetractMove
X * Usage: RetractMove(state, move);
X * --------------------------------
X * This function changes the state of the game by "unmaking" the
X * indicated move.
X */
X
static void RetractMove(stateT state, moveT move)
{
X    state->board[move] = ' ';
X    state->whoseTurn = Opponent(state->whoseTurn);
X    state->turnsTaken--;
}
X
/*
X * Function: AnnounceResult
X * Usage: AnnounceResult(state);
X * -----------------------------
X * This function announces the result of the game.
X */
X
static void AnnounceResult(stateT state)
{
X    DisplayGame(state);
X    if (CheckForWin(state, Human)) {
X        printf("You win\n");
X    } else if (CheckForWin(state, Computer)) {
X        printf("I win\n");
X    } else {
X        printf("Cat's game\n");
X    }
}
X
/*
X * Function: GameIsOver
X * Usage: if (GameIsOver(state)) . . .
X * -----------------------------------
X * This function returns TRUE if the game is complete.
X */
X
static bool GameIsOver(stateT state)
{
X    return (state->turnsTaken == 9
X            || CheckForWin(state, state->whoseTurn)
X            || CheckForWin(state, Opponent(state->whoseTurn)));
}
X
/*
X * Function: EvaluateStaticPosition
X * Usage: rating = EvaluateStaticPosition(state);
X * ----------------------------------------------
X * This function gives the rating of a position without looking
X * ahead any further in the game tree.  Although this function
X * duplicates much of the computation of GameIsOver and therefore
X * introduces some runtime inefficiency, it makes the algorithm
X * somewhat easier to follow.
X */
X
static int EvaluateStaticPosition(stateT state)
{
X    if (CheckForWin(state, state->whoseTurn)) {
X        return (WinningPosition);
X    }
X    if (CheckForWin(state, Opponent(state->whoseTurn))) {
X        return (LosingPosition);
X    }
X    return (NeutralPosition);
}
X
/*
X * Function: CheckForWin
X * Usage: if (CheckForWin(state, player)) . . .
X * --------------------------------------------
X * This function returns TRUE if the specified player has won
X * the game.  The check on turnsTaken increases efficiency,
X * because neither player can win the game until the fifth move.
X */
X
static bool CheckForWin(stateT state, playerT player)
{
X    int i;
X    char mark;
X
X    if (state->turnsTaken < 5) return (FALSE);
X    mark = PlayerMark(player);
X    for (i = 0; i < nWinningLines; i++) {
X        if (mark == state->board[winningLines[i][0]]
X               && mark == state->board[winningLines[i][1]]
X               && mark == state->board[winningLines[i][2]]) {
X            return (TRUE);
X        }
X    }
X    return (FALSE);
}
X
/*
X * Function: WhoseTurn
X * Usage: player = WhoseTurn(state);
X * ---------------------------------
X * This function returns whose turn it is, given the current
X * state of the game.
X */
X
static playerT WhoseTurn(stateT state)
{
X    return (state->whoseTurn);
}
X
/*
X * Function: Opponent
X * Usage: opp = Opponent(player);
X * ------------------------------
X * This function returns the playerT value corresponding to the
X * opponent of the specified player.
X */
X
static playerT Opponent(playerT player)
{
X    switch (player) {
X      case Human:    return (Computer);
X      case Computer: return (Human);
X    }
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/06-Backtracking-Algorithms/tictac.c' &&
  chmod 0644 'programs/06-Backtracking-Algorithms/tictac.c' ||
  echo 'restore of programs/06-Backtracking-Algorithms/tictac.c failed'
  shar_count="`wc -c < 'programs/06-Backtracking-Algorithms/tictac.c'`"
  test 15726 -eq "$shar_count" ||
    echo "programs/06-Backtracking-Algorithms/tictac.c: original size 15726, current size $shar_count"
fi
# ============= programs/06-Backtracking-Algorithms/Makefile ==============
if test -f 'programs/06-Backtracking-Algorithms/Makefile' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/06-Backtracking-Algorithms/Makefile (file already exists)'
else
  echo 'x - extracting programs/06-Backtracking-Algorithms/Makefile (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/06-Backtracking-Algorithms/Makefile' &&
# Makefile for programs in directory 06-Backtracking-Algorithms
# ***************************************************************
X
PROGRAMS = \
X    maze \
X    nim \
X    tictac
X
# ***************************************************************
# Parameters to control Makefile operation
# Note that the gccx command script must be defined
X
CC = gccx
CFLAGS = 
X
# ***************************************************************
# Entry to bring the package up to date
X
all: $(PROGRAMS)
X
# ***************************************************************
# Standard entries to remove files from the directories
#    tidy    -- eliminate unwanted files
#    scratch -- delete derived files in preparation for rebuild
X
tidy:
X	rm -f ,* .,* *~ core a.out graphics.ps
X
scratch: tidy
X	rm -f *.o *.a $(PROGRAMS)
X
# ***************************************************************
# C compilations
X
maze.o: maze.c mazelib.h
X	$(CC) $(CFLAGS) -c maze.c
X
mazelib.o: mazelib.c mazelib.h
X	$(CC) $(CFLAGS) -c mazelib.c
X
nim.o: nim.c
X	$(CC) $(CFLAGS) -c nim.c
X
tictac.o: tictac.c
X	$(CC) $(CFLAGS) -c tictac.c
X
X
# ***************************************************************
# Executable programs
X
maze: maze.o mazelib.o
X	$(CC) $(CFLAGS) -o maze maze.o mazelib.o
X
nim: nim.o
X	$(CC) $(CFLAGS) -o nim nim.o
X
tictac: tictac.o
X	$(CC) $(CFLAGS) -o tictac tictac.o
X
SHAR_EOF
  $shar_touch -am 0906095697 'programs/06-Backtracking-Algorithms/Makefile' &&
  chmod 0644 'programs/06-Backtracking-Algorithms/Makefile' ||
  echo 'restore of programs/06-Backtracking-Algorithms/Makefile failed'
  shar_count="`wc -c < 'programs/06-Backtracking-Algorithms/Makefile'`"
  test 1342 -eq "$shar_count" ||
    echo "programs/06-Backtracking-Algorithms/Makefile: original size 1342, current size $shar_count"
fi
# ============= programs/06-Backtracking-Algorithms/mazelib.c ==============
if test -f 'programs/06-Backtracking-Algorithms/mazelib.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/06-Backtracking-Algorithms/mazelib.c (file already exists)'
else
  echo 'x - extracting programs/06-Backtracking-Algorithms/mazelib.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/06-Backtracking-Algorithms/mazelib.c' &&
/*
X * File: mazelib.c
X * ---------------
X * This file implements the mazelib.h interface.
X */
X
#include <stdio.h>
#include <ctype.h>
#include "genlib.h"
#include "strlib.h"
#include "simpio.h"
#include "extgraph.h"
#include "mazelib.h"
X
/*
X * Constants
X * ---------
X * LeftMargin    -- Margin between maze and left screen edge
X * BottomMargin  -- Margin at the bottom of the screen
X * SquareSize    -- Size of each square in inches
X * MarkSize      -- Size of the mark symbol
X * StartRadius   -- Radius of the start circle
X * PauseTime     -- Delay at each display point
X */
X
#define LeftMargin    0.15
#define BottomMargin  0.15
#define SquareSize    (20 / 72.0)
#define MarkSize      (4 / 72.0)
#define StartRadius   (5 / 72.0)
#define PauseTime     0.1
X
/*
X * Type: squareT
X * -------------
X * This type holds the state information required for each corner
X * in the maze.  The walls array is indexed with a directionT.
X */
X
typedef struct {
X    bool marked;
X    bool walls[4];
} squareT;
X
/*
X * Private data
X * ------------
X * maze         -- Dynamic 2-D array that stores the maze
X * mazeWidth    -- The width of the stored maze
X * mazeHeight   -- The height of the stored maze
X * startSquare  -- The pointT corresponding to the start square
X * initialized  -- Flag showing package has been initialized
X */
X
static squareT **maze;
static int mazeWidth, mazeHeight;
static pointT startSquare;
static bool initialized = FALSE;
X
/* Private function prototypes */
X
static void ComputeMazeSize(FILE *infile);
static void InitMazeArray(void);
static void ProcessMazeFile(FILE *infile);
static void ProcessDividerLine(string line, int y);
static void ProcessPassageLine(string line, int y);
static void SetHorizontalWall(pointT pt);
static void SetVerticalWall(pointT pt);
static void SetStartSquare(pointT pt);
static void DrawCenteredCircle(double x, double y, double r);
static void DrawMarkInSquare(pointT pt);
static bool InRange(int x, int y);
static void TrimTrailingSpace(char buffer[]);
static void FreeOldStorage(void);
X
/* Public entries */
X
void ReadMazeMap(string filename)
{
X    FILE *infile;
X
X    InitGraphics();
X    infile = fopen(filename, "r");
X    if (infile == NULL) Error("Can't open %s", filename);
X    ComputeMazeSize(infile);
X    fclose(infile);
X    InitMazeArray();
X    startSquare.x = -1;
X    infile = fopen(filename, "r");
X    if (infile == NULL) Error("Can't reopen maze file");
X    ProcessMazeFile(infile);
X    if (startSquare.x == -1) Error("Maze contains no start square");
X    initialized = TRUE;
}
X
pointT GetStartPosition(void)
{
X    if (!initialized) Error("ReadMazeMap has not been called");
X    return (startSquare);
}
X
bool OutsideMaze(pointT pt)
{
X    if (!initialized) Error("ReadMazeMap has not been called");
X    return (!InRange(pt.x, pt.y));
}
X
bool WallExists(pointT pt, directionT dir)
{
X    if (!initialized) Error("ReadMazeMap has not been called");
X    if (OutsideMaze(pt)) Error("Coordinates are out of range");
X    return (maze[pt.x][pt.y].walls[dir]);
}
X
void MarkSquare(pointT pt)
{
X    if (!initialized) Error("ReadMazeMap has not been called");
X    if (OutsideMaze(pt)) Error("Coordinates are out of range");
X    maze[pt.x][pt.y].marked = TRUE;
X    DrawMarkInSquare(pt);
}
X
void UnmarkSquare(pointT pt)
{
X    if (!initialized) Error("ReadMazeMap has not been called");
X    if (OutsideMaze(pt)) Error("Coordinates are out of range");
X    maze[pt.x][pt.y].marked = FALSE;
X    SetPenColor("White");
X    DrawMarkInSquare(pt);
X    SetPenColor("Black");
}
X
bool IsMarked(pointT pt)
{
X    if (!initialized) Error("ReadMazeMap has not been called");
X    if (OutsideMaze(pt)) Error("Coordinates are out of range");
X    return (maze[pt.x][pt.y].marked);
}
X
/* Private functions */
X
/*
X * Function: ComputeMazeSize
X * Usage: ComputeMazeSize(infile);
X * -------------------------------
X * This function reads the data file and computes the dimensions
X * of the maze.  The file must then be read a second time to read
X * the actual data.  The values indicating the size of the maze
X * are stored in the private variables mazeWidth and mazeHeight.
X */
X
static void ComputeMazeSize(FILE *infile)
{
X    string line;
X    int nLines, len;
X    bool trailing;
X
X    nLines = 0;
X    trailing = FALSE;
X    while ((line = ReadLine(infile)) != NULL) {
X        TrimTrailingSpace(line);
X        len = StringLength(line);
X        if (len == 0) {
X            trailing = TRUE;
X        } else if (trailing) {
X            Error("Illegal blank lines in data file");
X        } else if (nLines == 0) {
X            if (len % 2 != 1) Error("Illegal maze width");
X            mazeWidth = (len - 1) / 2;
X            nLines++;
X        } else {
X            nLines++;
X        }
X    }
X    if (nLines % 2 != 1) Error("Illegal maze height");
X    mazeHeight = (nLines - 1) / 2;
}
X
/*
X * Function: InitMazeArray
X * Usage: InitMazeArray();
X * -----------------------
X * This file initializes the maze array and must be called after
X * the dimensions of the maze have been set by ComputeMazeSize.
X */
X
static void InitMazeArray(void)
{
X    int x, y;
X    directionT dir;
X
X    if (initialized) FreeOldStorage();
X    maze = NewArray(mazeWidth, squareT *);
X    for (x = 0; x < mazeWidth; x++) {
X        maze[x] = NewArray(mazeHeight, squareT);
X        for (y = 0; y < mazeHeight; y++) {
X            maze[x][y].marked = FALSE;
X            for (dir = North; dir <= West; dir++) {
X                maze[x][y].walls[dir] = FALSE;
X            }
X        }
X    }
}
X
/*
X * Function: ProcessMazeFile
X * Usage: ProcessMazeFile(infile);
X * -------------------------------
X * This function reads the actual maze data from the file.  The
X * functions ComputeMazeSize and InitMazeArray must be called
X * prior to calling ProcessMazeFile.  It is also the caller's
X * responsibility to make sure that infile has been set back
X * to the beginning of the file.
X */
X
static void ProcessMazeFile(FILE *infile)
{
X    int y;
X
X    for (y = mazeHeight; y > 0; y--) {
X        ProcessDividerLine(ReadLine(infile), y);
X        ProcessPassageLine(ReadLine(infile), y - 1);
X    }
X    ProcessDividerLine(ReadLine(infile), 0);
}
X
/*
X * Function: ProcessDividerLine
X * Usage: ProcessDividerLine(line, y);
X * -----------------------------------
X * This function reads the odd-numbered lines in the data file,
X * which specify the positions of the horizontal walls.  The
X * line have the form
X *
X *     +-+-+-+-+-+-+-+-+
X *
X * where the - symbols may be replaced by spaces to indicate a
X * corridor square.  The y value gives the index of the squares
X * immediately to the north of this line.
X */
X
static void ProcessDividerLine(string line, int y)
{
X    pointT pt;
X
X    if (StringLength(line) != 2 * mazeWidth + 1) {
X        Error("Divider line has incorrect width");
X    }
X    pt.y = y;
X    for (pt.x = 0; pt.x < mazeWidth; pt.x++) {
X        if (line[2 * pt.x] != '+') Error("Missing corner symbol");
X        switch (line[2 * pt.x + 1]) {
X          case ' ': break;
X          case '-': SetHorizontalWall(pt); break;
X          default:  Error("Illegal character in maze file");
X        }
X    }
X    if (line[2 * mazeWidth] != '+') Error("Missing corner symbol");
}
X
/*
X * Function: ProcessPassageLine
X * Usage: ProcessPassageLine(line, y);
X * -----------------------------------
X * This function reads the even-numbered lines in the data file,
X * which specify the passageways and locations of the vertical
X * walls.  These lines have the form
X *
X *     | | | | | | | | |
X *
X * where the | symbols may be replaced by spaces to indicate a
X * corridor square.  One of the open passageway squares in the
X * file may also be marked with an 'S' to indicate the start
X * square.  The y argument gives the index of the squares on
X * this line.
X */
X
static void ProcessPassageLine(string line, int y)
{
X    pointT pt;
X    int len;
X
X    pt.y = y;
X    len = StringLength(line);
X    for (pt.x = 0; pt.x < (len - 1) / 2; pt.x++) {
X        if (line[2 * pt.x] == '|') {
X            SetVerticalWall(pt);
X        }
X        switch (line[2 * pt.x + 1]) {
X          case ' ': case '\0': break;
X          case 'S': SetStartSquare(pt); break;
X          default:  Error("Illegal character in maze file");
X        }
X    }
X    if (len % 2 == 1 && line[len - 1] == '|') {
X        pt.x = (len - 1) / 2;
X        SetVerticalWall(pt);
X    }
}
X
/*
X * Function: SetHorizontalWall
X * Usage: SetHorizontalWall(pt);
X * -----------------------------
X * This function sets a horizontal wall to the south of the square
X * at pt.  To maintain consistency in the data structure, it is
X * usually also necessary to create a wall to the north of the
X * square just south of this one.
X */
X
static void SetHorizontalWall(pointT pt)
{
X    if (InRange(pt.x, pt.y)) {
X        maze[pt.x][pt.y].walls[South] = TRUE;
X    }
X    if (InRange(pt.x, pt.y - 1)) {
X        maze[pt.x][pt.y - 1].walls[North] = TRUE;
X    }
X    MovePen(LeftMargin + pt.x * SquareSize,
X            BottomMargin + pt.y * SquareSize);
X    DrawLine(SquareSize, 0);
}
X
/*
X * Function: SetVerticalWall
X * Usage: SetVerticalWall(pt);
X * ---------------------------
X * This function sets a vertical wall to the west of the square
X * at pt.  To maintain consistency in the data structure, it is
X * usually also necessary to create a wall to the east of the
X * square just west of this one.
X */
X
static void SetVerticalWall(pointT pt)
{
X    if (InRange(pt.x, pt.y)) {
X        maze[pt.x][pt.y].walls[West] = TRUE;
X    }
X    if (InRange(pt.x - 1, pt.y)) {
X        maze[pt.x - 1][pt.y].walls[East] = TRUE;
X    }
X    MovePen(LeftMargin + pt.x * SquareSize,
X            BottomMargin + pt.y * SquareSize);
X    DrawLine(0, SquareSize);
}
X
/*
X * Function: SetStartSquare
X * Usage: SetStartSquare(pt);
X * --------------------------
X * This function sets the start square to the indicated point and
X * draws a circle on the screen.
X */
X
static void SetStartSquare(pointT pt)
{
X    if (startSquare.x != -1) {
X        Error("Multiple start squares specified");
X    }
X    startSquare = pt;
X    DrawCenteredCircle(LeftMargin + (pt.x + 0.5) * SquareSize,
X                       BottomMargin + (pt.y + 0.5) * SquareSize,
X                       StartRadius);
}
X
/*
X * Function: DrawCenteredCircle
X * Usage: DrawCenteredCircle(x, y, r);
X * -----------------------------------
X * This function draws a circle of radius r with its
X * center at (x, y).
X */
X
static void DrawCenteredCircle(double x, double y, double r)
{
X    MovePen(x + r, y);
X    DrawArc(r, 0, 360);
}
X
/*
X * Function: DrawMarkInSquare
X * Usage: DrawMarkInSquare(pt);
X * ----------------------------
X * This function draws a mark symbol in the specified square.
X */
X
static void DrawMarkInSquare(pointT pt)
{
X    double x, y;
X
X    x = LeftMargin + (pt.x + 0.5) * SquareSize;
X    y = BottomMargin + (pt.y + 0.5) * SquareSize;
X    MovePen(x - MarkSize / 2, y - MarkSize / 2);
X    DrawLine(MarkSize, MarkSize);
X    MovePen(x - MarkSize / 2, y + MarkSize / 2);
X    DrawLine(MarkSize, -MarkSize);
X    if (PauseTime != 0) Pause(PauseTime);
}
X
/*
X * Function: InRange
X * Usage: if (InRange(x, y)) . . .
X * -------------------------------
X * This function checks to see if a particular coordinate pair
X * is inside the maze.  This function is included because it is
X * often more convenient than OutsideMaze, which takes a point.
X */
X
static bool InRange(int x, int y)
{
X    return (x >= 0 && x < mazeWidth && y >= 0 && y < mazeHeight);
}
X
/*
X * Function: TrimTrailingSpace
X * Usage: TrimTrailingSpace(buffer);
X * ---------------------------------
X * This function removes any trailing spaces from a string buffer.
X */
X
static void TrimTrailingSpace(char buffer[])
{
X    int cp;
X
X    cp = StringLength(buffer) - 1;
X    while (cp >= 0 && isspace(buffer[cp])) {
X        cp--;
X    }
X    buffer[cp + 1] = '\0';
}
X
X
/*
X * Function: FreeOldStorage
X * Usage: FreeOldStorage();
X * ------------------------
X * This function frees any memory allocated to the maze and is
X * called only if more than one maze is read in during the same
X * session.
X */
X
static void FreeOldStorage(void)
{
X    int x;
X
X    for (x = 0; x < mazeWidth; x++) {
X        FreeBlock(maze[x]);
X    }
X    FreeBlock(maze);
}
X
SHAR_EOF
  $shar_touch -am 0906095297 'programs/06-Backtracking-Algorithms/mazelib.c' &&
  chmod 0664 'programs/06-Backtracking-Algorithms/mazelib.c' ||
  echo 'restore of programs/06-Backtracking-Algorithms/mazelib.c failed'
  shar_count="`wc -c < 'programs/06-Backtracking-Algorithms/mazelib.c'`"
  test 12103 -eq "$shar_count" ||
    echo "programs/06-Backtracking-Algorithms/mazelib.c: original size 12103, current size $shar_count"
fi
# ============= programs/07-Algorithmic-Analysis/msort.c ==============
if test ! -d 'programs/07-Algorithmic-Analysis'; then
  echo 'x - creating directory programs/07-Algorithmic-Analysis'
  mkdir 'programs/07-Algorithmic-Analysis'
fi
if test -f 'programs/07-Algorithmic-Analysis/msort.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/07-Algorithmic-Analysis/msort.c (file already exists)'
else
  echo 'x - extracting programs/07-Algorithmic-Analysis/msort.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/07-Algorithmic-Analysis/msort.c' &&
/*
X * File: msort.c
X * -------------
X * This file implements the sort.h interface using the merge
X * sort algorithm.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "sort.h"
X
/* Private function prototypes */
X
static void Merge(int array[], int arr1[], int n1,
X                               int arr2[], int n2);
static int *CopySubArray(int array[], int start, int n);
X
/* Implementation */
X
/*
X * Function: SortIntegerArray
X * Usage: SortIntegerArray(array, n);
X * ----------------------------------
X * This function sorts the first n elements of array into
X * increasing numerical order using the merge sort algorithm,
X * which requires (1) dividing the array into two halves,
X * (2) sorting each half, and (3) merging the halves together.
X */
X
void SortIntegerArray(int array[], int n)
{
X    int n1, n2, *arr1, *arr2;
X
X    if (n <= 1) return;
X    n1 = n / 2;
X    n2 = n - n1;
X    arr1 = CopySubArray(array, 0, n1);
X    arr2 = CopySubArray(array, n1, n2);
X    SortIntegerArray(arr1, n1);
X    SortIntegerArray(arr2, n2);
X    Merge(array, arr1, n1, arr2, n2);
X    FreeBlock(arr1);
X    FreeBlock(arr2);
}
X
/*
X * Function: Merge
X * Usage: Merge(array, arr1, n1, arr2, n2);
X * ----------------------------------------
X * This function merges two sorted arrays (arr1 and arr2) into a
X * single output array.  Because the input arrays are sorted, the
X * implementation can always select the first unused element in
X * one of the input arrays to fill the next position in array.
X */
X
static void Merge(int array[], int arr1[], int n1,
X                                  int arr2[], int n2)
{
X    int p, p1, p2;
X
X    p = p1 = p2 = 0;
X    while (p1 < n1 && p2 < n2) {
X        if (arr1[p1] < arr2[p2]) {
X            array[p++] = arr1[p1++];
X        } else {
X            array[p++] = arr2[p2++];
X        }
X    }
X    while (p1 < n1) array[p++] = arr1[p1++];
X    while (p2 < n2) array[p++] = arr2[p2++];
}
X
/*
X * Function: CopySubArray
X * Usage: CopySubArray(array, start, n);
X * -------------------------------------
X * This function makes a copy of a subset of an integer array
X * and returns a pointer to a new dynamic array containing the
X * new elements.  The array begins at the indicated start
X * position in the original array and continues for n elements.
X */
X
static int *CopySubArray(int array[], int start, int n)
{
X    int i, *result;
X
X    result = NewArray(n, int);
X    for (i = 0; i < n; i++) {
X        result[i] = array[start + i];
X    }
X    return (result);
}
X
SHAR_EOF
  $shar_touch -am 0903182097 'programs/07-Algorithmic-Analysis/msort.c' &&
  chmod 0644 'programs/07-Algorithmic-Analysis/msort.c' ||
  echo 'restore of programs/07-Algorithmic-Analysis/msort.c failed'
  shar_count="`wc -c < 'programs/07-Algorithmic-Analysis/msort.c'`"
  test 2471 -eq "$shar_count" ||
    echo "programs/07-Algorithmic-Analysis/msort.c: original size 2471, current size $shar_count"
fi
# ============= programs/07-Algorithmic-Analysis/qsort.c ==============
if test -f 'programs/07-Algorithmic-Analysis/qsort.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/07-Algorithmic-Analysis/qsort.c (file already exists)'
else
  echo 'x - extracting programs/07-Algorithmic-Analysis/qsort.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/07-Algorithmic-Analysis/qsort.c' &&
/*
X * File: qsort.c
X * -------------
X * This file implements a pure Quicksort algorithm with no
X * enhancements for efficiency.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "sort.h"
X
/* Private function prototypes */
X
static int Partition(int array[], int n);
X
/*
X * Implementation notes: SortIntegerArray
X * --------------------------------------
X * This implementation of SortIntegerArray uses the Quicksort
X * algorithm, which begins by "partitioning" the array so that
X * all elements smaller than a designated pivot element appear
X * to the left of a boundary and all equal or larger values
X * appear to the right.  Sorting the subarrays to the left and
X * right of boundary ensures that the entire array is sorted.
X */
X
void SortIntegerArray(int array[], int n)
{
X    int boundary;
X
X    if (n < 2) return;
X    boundary = Partition(array, n);
X    SortIntegerArray(array, boundary);
X    SortIntegerArray(array + boundary + 1, n - boundary - 1);
}
X
/*
X * Function: Partition
X * Usage: boundary = Partition(array, n);
X * --------------------------------------
X * This function rearranges the elements of array relative to
X * a pivot value, which is taken from array[0].  The Partition
X * function returns a boundary index such that array[i] < pivot
X * for all i < boundary, array[i] == pivot for i == boundary,
X * and array[i] >= pivot for all i > boundary.
X */
X
static int Partition(int array[], int n)
{
X    int lh, rh, pivot, temp;
X
X    pivot = array[0];
X    lh = 1;
X    rh = n - 1;
X    while (TRUE) {
X        while (lh < rh && array[rh] >= pivot) rh--;
X        while (lh < rh && array[lh] < pivot) lh++;
X        if (lh == rh) break;
X        temp = array[lh];
X        array[lh] = array[rh];
X        array[rh] = temp;
X    }
X    if (array[lh] >= pivot) return (0);
X    array[0] = array[lh];
X    array[lh] = pivot;
X    return (lh);
}
X
SHAR_EOF
  $shar_touch -am 0903182097 'programs/07-Algorithmic-Analysis/qsort.c' &&
  chmod 0644 'programs/07-Algorithmic-Analysis/qsort.c' ||
  echo 'restore of programs/07-Algorithmic-Analysis/qsort.c failed'
  shar_count="`wc -c < 'programs/07-Algorithmic-Analysis/qsort.c'`"
  test 1845 -eq "$shar_count" ||
    echo "programs/07-Algorithmic-Analysis/qsort.c: original size 1845, current size $shar_count"
fi
# ============= programs/07-Algorithmic-Analysis/sort.h ==============
if test -f 'programs/07-Algorithmic-Analysis/sort.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/07-Algorithmic-Analysis/sort.h (file already exists)'
else
  echo 'x - extracting programs/07-Algorithmic-Analysis/sort.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/07-Algorithmic-Analysis/sort.h' &&
/*
X * File: sort.h
X * ------------
X * This file provides an interface to a simple procedure
X * for sorting an integer array into increasing order.
X */
X
#ifndef _sort_h
#define _sort_h
X
/*
X * Function: SortIntegerArray
X * Usage: SortIntegerArray(array, n);
X * ----------------------------------
X * This function sorts the first n elements in array into
X * increasing numerical order.  In order to use this procedure,
X * you must declare the array in the calling program and pass
X * the effective number of elements as the parameter n.
X * In most cases, the array will have a larger allocated
X * size.
X */
X
void SortIntegerArray(int array[], int n);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/07-Algorithmic-Analysis/sort.h' &&
  chmod 0644 'programs/07-Algorithmic-Analysis/sort.h' ||
  echo 'restore of programs/07-Algorithmic-Analysis/sort.h failed'
  shar_count="`wc -c < 'programs/07-Algorithmic-Analysis/sort.h'`"
  test 656 -eq "$shar_count" ||
    echo "programs/07-Algorithmic-Analysis/sort.h: original size 656, current size $shar_count"
fi
# ============= programs/07-Algorithmic-Analysis/ssort.c ==============
if test -f 'programs/07-Algorithmic-Analysis/ssort.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/07-Algorithmic-Analysis/ssort.c (file already exists)'
else
  echo 'x - extracting programs/07-Algorithmic-Analysis/ssort.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/07-Algorithmic-Analysis/ssort.c' &&
/*
X * File: ssort.c
X * -------------
X * This file implements the sort.h interface using the
X * selection sort algorithm.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "sort.h"
X
/*
X * Function: SortIntegerArray
X * --------------------------
X * This implementation uses an algorithm called selection sort,
X * which can be described in English as follows.  With your left
X * hand (lh), point at each element in the array in turn,
X * starting at index 0.  At each step in the cycle:
X *
X * 1. Find the smallest element in the range between your left
X *    hand and the end of the array, and point at that element
X *    with your right hand (rh).
X *
X * 2. Move that element into its correct position by exchanging
X *    the elements indicated by your left and right hands.
X */
X
void SortIntegerArray(int array[], int n)
{
X    int lh, rh, i, temp;
X
X    for (lh = 0; lh < n; lh++) {
X        rh = lh;
X        for (i = lh + 1; i < n; i++) {
X            if (array[i] < array[rh]) rh = i;
X        }
X        temp = array[lh];
X        array[lh] = array[rh];
X        array[rh] = temp;
X    }
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/07-Algorithmic-Analysis/ssort.c' &&
  chmod 0644 'programs/07-Algorithmic-Analysis/ssort.c' ||
  echo 'restore of programs/07-Algorithmic-Analysis/ssort.c failed'
  shar_count="`wc -c < 'programs/07-Algorithmic-Analysis/ssort.c'`"
  test 1085 -eq "$shar_count" ||
    echo "programs/07-Algorithmic-Analysis/ssort.c: original size 1085, current size $shar_count"
fi
# ============= programs/07-Algorithmic-Analysis/testsort.c ==============
if test -f 'programs/07-Algorithmic-Analysis/testsort.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/07-Algorithmic-Analysis/testsort.c (file already exists)'
else
  echo 'x - extracting programs/07-Algorithmic-Analysis/testsort.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/07-Algorithmic-Analysis/testsort.c' &&
/*
X * File: testsort.c
X * ----------------
X * This program tests the sort.c implementation.  In this example
X * the array is considered to be a list of exam scores.  The
X * test program reads in a list of scores, sorts them, and then
X * displays the sorted list.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "simpio.h"
#include "sort.h"
X
/*
X * Constants
X * ---------
X * MaxScores -- Maximum number of scores
X * Sentinel  -- Value used to terminate input
X */
X
#define MaxScores 100
#define Sentinel   -1
X
/* Private function prototypes */
X
static int GetIntegerArray(int array[], int max, int sentinel);
static void PrintIntegerArray(int array[], int n);
X
/* Main program */
X
main()
{
X    int scores[MaxScores];
X    int n;
X
X    printf("Enter exam scores, one per line, ending\n");
X    printf("with the sentinel value %d.\n", Sentinel);
X    n = GetIntegerArray(scores, MaxScores, Sentinel);
X    SortIntegerArray(scores, n);
X    printf("\nThe sorted exam scores are:\n");
X    PrintIntegerArray(scores, n);
}
X
/*
X * Function: GetIntegerArray
X * Usage: n = GetIntegerArray(array, max, sentinel);
X * -------------------------------------------------
X * This function reads elements into an integer array by
X * reading values, one per line, from the keyboard.  The end
X * of the input data is indicated by the parameter sentinel.
X * The caller is responsible for declaring the array and
X * passing it as a parameter, along with its allocated
X * size.  The value returned is the number of elements
X * actually entered and therefore gives the effective size
X * of the array, which is typically less than the allocated
X * size given by max.  If the user types in more than max
X * elements, GetIntegerArray generates an error.
X */
X
static int GetIntegerArray(int array[], int max, int sentinel)
{
X    int n, value;
X
X    n = 0;
X    while (TRUE) {
X        printf(" ? ");
X        value = GetInteger();
X        if (value == sentinel) break;
X        if (n == max) Error("Too many input items for array");
X        array[n] = value;
X        n++;
X    }
X    return (n);
}
X
/*
X * Function: PrintIntegerArray
X * Usage: PrintIntegerArray(array, n);
X * -----------------------------------
X * This function displays the first n values in array,
X * one per line, on the console.
X */
X
static void PrintIntegerArray(int array[], int n)
{
X    int i;
X
X    for (i = 0; i < n; i++) {
X        printf("%d\n", array[i]);
X    }
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/07-Algorithmic-Analysis/testsort.c' &&
  chmod 0644 'programs/07-Algorithmic-Analysis/testsort.c' ||
  echo 'restore of programs/07-Algorithmic-Analysis/testsort.c failed'
  shar_count="`wc -c < 'programs/07-Algorithmic-Analysis/testsort.c'`"
  test 2402 -eq "$shar_count" ||
    echo "programs/07-Algorithmic-Analysis/testsort.c: original size 2402, current size $shar_count"
fi
# ============= programs/07-Algorithmic-Analysis/Makefile ==============
if test -f 'programs/07-Algorithmic-Analysis/Makefile' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/07-Algorithmic-Analysis/Makefile (file already exists)'
else
  echo 'x - extracting programs/07-Algorithmic-Analysis/Makefile (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/07-Algorithmic-Analysis/Makefile' &&
# Makefile for programs in directory 07-Algorithmic-Analysis
# ***************************************************************
X
PROGRAMS = \
X    testssort \
X    testmsort \
X    testqsort
X
# ***************************************************************
# Parameters to control Makefile operation
# Note that the gccx command script must be defined
X
CC = gccx
CFLAGS = 
X
# ***************************************************************
# Entry to bring the package up to date
X
all: $(PROGRAMS)
X
# ***************************************************************
# Standard entries to remove files from the directories
#    tidy    -- eliminate unwanted files
#    scratch -- delete derived files in preparation for rebuild
X
tidy:
X	rm -f ,* .,* *~ core a.out graphics.ps
X
scratch: tidy
X	rm -f *.o *.a $(PROGRAMS)
X
# ***************************************************************
# C compilations
X
msort.o: msort.c
X	$(CC) $(CFLAGS) -c msort.c
X
qsort.o: qsort.c
X	$(CC) $(CFLAGS) -c qsort.c
X
ssort.o: ssort.c
X	$(CC) $(CFLAGS) -c ssort.c
X
testsort.o: testsort.c
X	$(CC) $(CFLAGS) -c testsort.c
X
X
# ***************************************************************
# Executable programs
X
testssort: testsort.o ssort.o
X	$(CC) $(CFLAGS) -o testssort testsort.o ssort.o
X
testmsort: testsort.o msort.o
X	$(CC) $(CFLAGS) -o testmsort testsort.o msort.o
X
testqsort: testsort.o qsort.o
X	$(CC) $(CFLAGS) -o testqsort testsort.o qsort.o
SHAR_EOF
  $shar_touch -am 0903175397 'programs/07-Algorithmic-Analysis/Makefile' &&
  chmod 0644 'programs/07-Algorithmic-Analysis/Makefile' ||
  echo 'restore of programs/07-Algorithmic-Analysis/Makefile failed'
  shar_count="`wc -c < 'programs/07-Algorithmic-Analysis/Makefile'`"
  test 1419 -eq "$shar_count" ||
    echo "programs/07-Algorithmic-Analysis/Makefile: original size 1419, current size $shar_count"
fi
# ============= programs/08-Abstract-Data-Types/rpncalc.c ==============
if test ! -d 'programs/08-Abstract-Data-Types'; then
  echo 'x - creating directory programs/08-Abstract-Data-Types'
  mkdir 'programs/08-Abstract-Data-Types'
fi
if test -f 'programs/08-Abstract-Data-Types/rpncalc.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/08-Abstract-Data-Types/rpncalc.c (file already exists)'
else
  echo 'x - extracting programs/08-Abstract-Data-Types/rpncalc.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/08-Abstract-Data-Types/rpncalc.c' &&
/*
X * File: rpncalc.c
X * ---------------
X * This program simulates an electronic calculator that uses
X * reverse Polish notation, in which the operators come after
X * the operands to which they apply.
X */
X
#include <stdio.h>
#include <ctype.h>
#include "genlib.h"
#include "simpio.h"
#include "strlib.h"
#include "stack.h"
X
/* Private function prototypes */
X
static void ApplyOperator(char op, stackADT operandStack);
static void HelpCommand(void);
static void ClearStack(stackADT operandStack);
static void DisplayStack(stackADT operandStack);
X
/* Main program */
X
main()
{
X    stackADT operandStack;
X    string line;
X    char ch;
X
X    printf("RPN Calculator Simulation (type H for help)\n");
X    operandStack = NewStack();
X    while (TRUE) {
X        printf("> ");
X        line = GetLine();
X        ch = toupper(line[0]);
X        switch (ch) {
X          case 'Q': exit(0);
X          case 'H': HelpCommand(); break;
X          case 'C': ClearStack(operandStack); break;
X          case 'S': DisplayStack(operandStack); break;
X          default:
X            if (isdigit(ch)) {
X                Push(operandStack, StringToReal(line));
X            } else {
X                ApplyOperator(ch, operandStack);
X            }
X            break;
X        }
X    }
}
X
/* Private functions */
X
/*
X * Function: ApplyOperator
X * Usage: ApplyOperator(op, operandStack);
X * ---------------------------------------
X * This function applies the operator to the top two elements on
X * the operand stack.  Because the elements on the stack are
X * popped in reverse order, the right operand is popped before
X * the left operand.
X */
X
static void ApplyOperator(char op, stackADT operandStack)
{
X    double lhs, rhs, result;
X
X    rhs = Pop(operandStack);
X    lhs = Pop(operandStack);
X    switch (op) {
X      case '+': result = lhs + rhs; break;
X      case '-': result = lhs - rhs; break;
X      case '*': result = lhs * rhs; break;
X      case '/': result = lhs / rhs; break;
X      default:  Error("Illegal operator %c", op);
X    }
X    printf("%g\n", result);
X    Push(operandStack, result);
}
X
/*
X * Function: HelpCommand
X * Usage: HelpCommand();
X * ---------------------
X * This function generates a help message for the user.
X */
X
static void HelpCommand(void)
{
X    printf("Enter expressions in Reverse Polish Notation,\n");
X    printf("in which operators follow the operands to which\n");
X    printf("they apply.  Each line consists of a number, an\n");
X    printf("operator, or one of the following commands:\n");
X    printf("  Q -- Quit the program\n");
X    printf("  H -- Display this help message\n");
X    printf("  C -- Clear the calculator stack\n");
X    printf("  S -- Display all values in the stack\n");
}
X
/*
X * Function: ClearStack
X * Usage: ClearStack(stack);
X * -------------------------
X * This function clears the stack by popping elements until it is
X * empty.
X */
X
static void ClearStack(stackADT stack)
{
X    while (!StackIsEmpty(stack)) {
X        (void) Pop(stack);
X    }
}
X
/*
X * Function: DisplayStack
X * Usage: DisplayStack(stack);
X * ---------------------------
X * This function displays the contents of a stack.
X */
X
static void DisplayStack(stackADT stack)
{
X    int i, depth;
X
X    printf("Stack: ");
X    depth = StackDepth(stack);
X    if (depth == 0) {
X        printf("empty\n");
X    } else {
X        for (i = depth - 1; i >= 0; i--) {
X            if (i < depth - 1) printf(", ");
X            printf("%g", GetStackElement(stack, i));
X        }
X        printf("\n");
X    }
}
X
X
X
SHAR_EOF
  $shar_touch -am 0903182097 'programs/08-Abstract-Data-Types/rpncalc.c' &&
  chmod 0644 'programs/08-Abstract-Data-Types/rpncalc.c' ||
  echo 'restore of programs/08-Abstract-Data-Types/rpncalc.c failed'
  shar_count="`wc -c < 'programs/08-Abstract-Data-Types/rpncalc.c'`"
  test 3478 -eq "$shar_count" ||
    echo "programs/08-Abstract-Data-Types/rpncalc.c: original size 3478, current size $shar_count"
fi
# ============= programs/08-Abstract-Data-Types/scanadt.c ==============
if test -f 'programs/08-Abstract-Data-Types/scanadt.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/08-Abstract-Data-Types/scanadt.c (file already exists)'
else
  echo 'x - extracting programs/08-Abstract-Data-Types/scanadt.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/08-Abstract-Data-Types/scanadt.c' &&
/*
X * File: scanadt.c
X * ---------------
X * This file implements the scanadt.h interface.
X */
X
#include <stdio.h>
#include <ctype.h>
#include "genlib.h"
#include "strlib.h"
#include "scanadt.h"
X
/*
X * Type: scannerCDT
X * ----------------
X * This structure is the concrete representation of the type
X * scannerADT, which is exported by this interface.  Its purpose
X * is to maintain the state of the scanner between calls.  The
X * details of the representation are invisible to the client,
X * but consist of the following fields:
X *
X * str          -- Copy of string passed to SetScannerString
X * len          -- Length of string, saved for efficiency
X * cp           -- Current character position in the string
X * savedToken   -- String saved by SaveToken (NULL indicates none)
X * spaceOption  -- Setting of the space option extension
X */
X
struct scannerCDT {
X    string str;
X    int len;
X    int cp;
X    string savedToken;
X    spaceOptionT spaceOption;
};
X
/* Private function prototypes */
X
static void SkipSpaces(scannerADT scanner);
static int ScanToEndOfIdentifier(scannerADT scanner);
X
/* Exported entries */
X
scannerADT NewScanner(void)
{
X    scannerADT scanner;
X
X    scanner = New(scannerADT);
X    scanner->str = NULL;
X    scanner->spaceOption = PreserveSpaces;
X    return (scanner);
}
X
void FreeScanner(scannerADT scanner)
{
X    if (scanner->str != NULL) FreeBlock(scanner->str);
X    FreeBlock(scanner);
}
X
void SetScannerString(scannerADT scanner, string str)
{
X    if (scanner->str != NULL) FreeBlock(scanner->str);
X    scanner->str = CopyString(str);
X    scanner->len = StringLength(str);
X    scanner->cp = 0;
X    scanner->savedToken = NULL;
}
X
string ReadToken(scannerADT scanner)
{
X    char ch;
X    string token;
X    int start, finish;
X
X    if (scanner->str == NULL) {
X        Error("SetScannerString has not been called");
X    }
X    if (scanner->savedToken != NULL) {
X        token = scanner->savedToken;
X        scanner->savedToken = NULL;
X        return (token);
X    }
X    if (scanner->spaceOption == IgnoreSpaces) SkipSpaces(scanner);
X    start = finish = scanner->cp;
X    if (start >= scanner->len) return (CopyString(""));
X    ch = scanner->str[scanner->cp];
X    if (isalnum(ch)) {
X        finish = ScanToEndOfIdentifier(scanner);
X    } else {
X        scanner->cp++;
X    }
X    return (SubString(scanner->str, start, finish));
}
X
bool MoreTokensExist(scannerADT scanner)
{
X    if (scanner->str == NULL) {
X        Error("SetScannerString has not been called");
X    }
X    if (scanner->savedToken != NULL) {
X        return (!StringEqual(scanner->savedToken, ""));
X    }
X    if (scanner->spaceOption == IgnoreSpaces) SkipSpaces(scanner);
X    return (scanner->cp < scanner->len);
}
X
void SaveToken(scannerADT scanner, string token)
{
X    if (scanner->str == NULL) {
X        Error("SetScannerString has not been called");
X    }
X    if (scanner->savedToken != NULL) {
X        Error("Token has already been saved");
X    }
X    scanner->savedToken = token;
}
X
void SetScannerSpaceOption(scannerADT scanner, spaceOptionT option)
{
X    scanner->spaceOption = option;
}
X
spaceOptionT GetScannerSpaceOption(scannerADT scanner)
{
X    return (scanner->spaceOption);
}
X
/* Private functions */
X
/*
X * Function: SkipSpaces
X * Usage: SkipSpaces(scanner);
X * ---------------------------
X * This function advances the position of the scanner until the
X * current character is not a whitespace character.
X */
X
static void SkipSpaces(scannerADT scanner)
{
X    while (isspace(scanner->str[scanner->cp])) {
X        scanner->cp++;
X    }
}
X
/*
X * Function: ScanToEndOfIdentifier
X * Usage: finish = ScanToEndOfIdentifier(scanner);
X * -----------------------------------------------
X * This function advances the position of the scanner until it
X * reaches the end of a sequence of letters or digits that make
X * up an identifier.  The return value is the index of the last
X * character in the identifier; the value of the stored index
X * cp is the first character after that.
X */
X
static int ScanToEndOfIdentifier(scannerADT scanner)
{
X    while (isalnum(scanner->str[scanner->cp])) {
X        scanner->cp++;
X    }
X    return (scanner->cp - 1);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/08-Abstract-Data-Types/scanadt.c' &&
  chmod 0644 'programs/08-Abstract-Data-Types/scanadt.c' ||
  echo 'restore of programs/08-Abstract-Data-Types/scanadt.c failed'
  shar_count="`wc -c < 'programs/08-Abstract-Data-Types/scanadt.c'`"
  test 4137 -eq "$shar_count" ||
    echo "programs/08-Abstract-Data-Types/scanadt.c: original size 4137, current size $shar_count"
fi
# ============= programs/08-Abstract-Data-Types/scanadt.h ==============
if test -f 'programs/08-Abstract-Data-Types/scanadt.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/08-Abstract-Data-Types/scanadt.h (file already exists)'
else
  echo 'x - extracting programs/08-Abstract-Data-Types/scanadt.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/08-Abstract-Data-Types/scanadt.h' &&
/*
X * File: scanadt.h
X * ---------------
X * This file is the interface to a module that exports an abstract
X * data type to facilitate dividing a string into logical units
X * called "tokens," which are either
X *
X * 1. Strings of consecutive letters and digits representing words
X * 2. One-character strings representing punctuation or separators
X *
X * To use this package, you must first create an instance of a
X * scannerADT by calling
X *
X *      scanner = NewScanner();
X *
X * All other calls to the scanner package take this variable as their
X * first argument to identify a particular instance of the abstract
X * scanner type.
X *
X * You initialize the scanner to hold a particular string by calling
X *
X *      SetScannerString(scanner, str);
X *
X * where str is the string from which tokens should be read.  To
X * retrieve each individual token, you make the following call:
X *
X *      token = ReadToken(scanner);
X *
X * To determine whether any tokens remain to be read, you can call
X * the predicate function MoreTokensExist(scanner).  The ReadToken
X * function returns the empty string after the last token is read.
X *
X * The following code fragment serves as an idiom for processing
X * each token in the string inputString:
X *
X *      scanner = NewScanner();
X *      SetScannerString(scanner, inputString);
X *      while (MoreTokensExist(scanner)) {
X *          token = ReadToken(scanner);
X *          . . . process the token . . .
X *      }
X *
X * This version of scanadt.h also supports the following extensions,
X * which are documented later in the interface:
X *
X *   SaveToken
X *   SetScannerSpaceOption
X */
X
#ifndef _scanadt_h
#define _scanadt_h
X
#include "genlib.h"
X
/*
X * Type: scannerADT
X * ----------------
X * This type is the abstract type used to represent a single instance
X * of a scanner.  As with any abstract type, the details of the
X * internal representation are hidden from the client.
X */
X
typedef struct scannerCDT *scannerADT;
X
/*
X * Function: NewScanner
X * Usage: scanner = NewScanner();
X * ------------------------------
X * This function creates a new scanner instance.  All other functions
X * in this interface take this scanner value as their first argument
X * so that they can identify what particular instance of the scanner
X * is in use.  This design makes it possible for clients to have more
X * than one scanner process active at the same time.
X */
X
scannerADT NewScanner(void);
X
/*
X * Function: FreeScanner
X * Usage: FreeScanner(scanner);
X * ----------------------------
X * This function frees the storage associated with scanner.
X */
X
void FreeScanner(scannerADT scanner);
X
/*
X * Function: SetScannerString
X * Usage: SetScannerString(scanner, str);
X * --------------------------------------
X * This function initializes the scanner so that it will start
X * extracting tokens from the string str.
X */
X
void SetScannerString(scannerADT scanner, string str);
X
/*
X * Function: ReadToken
X * Usage: token = ReadToken(scanner);
X * ----------------------------------
X * This function returns the next token from scanner.  If
X * ReadToken is called when no tokens are available, it returns
X * the empty string.  The token returned by ReadToken is always
X * allocated in the heap, which means that clients can call
X * FreeBlock when the token is no longer needed.
X */
X
string ReadToken(scannerADT scanner);
X
/*
X * Function: MoreTokensExist
X * Usage: if (MoreTokensExist(scanner)) . . .
X * ------------------------------------------
X * This function returns TRUE as long as there are additional
X * tokens for the scanner to read.
X */
X
bool MoreTokensExist(scannerADT scanner);
X
/*
X * Function: SaveToken
X * Usage: SaveToken(scanner, token);
X * ---------------------------------
X * This function stores the token in the scanner data structure
X * in such a way that the next time ReadToken is called, it will
X * return that token without reading any additional characters
X * from the input.
X */
X
void SaveToken(scannerADT scanner, string token);
X
/*
X * Functions: SetScannerSpaceOption, GetScannerSpaceOption
X * Usage: SetScannerSpaceOption(scanner, option);
X *        option = GetScannerSpaceOption(scanner);
X * -----------------------------------------------
X * The SetScannerSpaceOption function controls whether the scanner
X * ignores whitespace characters or treats them as valid tokens.
X * By default, the ReadToken function treats whitespace characters,
X * such as spaces and tabs, just like any other punctuation mark.
X * If, however, you call
X *
X *    SetScannerSpaceOption(scanner, IgnoreSpaces);
X *
X * the scanner will skip over any white space before reading a token.
X * You can restore the original behavior by calling
X *
X *    SetScannerSpaceOption(scanner, PreserveSpaces);
X *
X * The GetScannerSpaceOption function returns the current setting
X * of this option.
X */
X
typedef enum { PreserveSpaces, IgnoreSpaces } spaceOptionT;
X
void SetScannerSpaceOption(scannerADT scanner, spaceOptionT option);
spaceOptionT GetScannerSpaceOption(scannerADT scanner);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/08-Abstract-Data-Types/scanadt.h' &&
  chmod 0644 'programs/08-Abstract-Data-Types/scanadt.h' ||
  echo 'restore of programs/08-Abstract-Data-Types/scanadt.h failed'
  shar_count="`wc -c < 'programs/08-Abstract-Data-Types/scanadt.h'`"
  test 5000 -eq "$shar_count" ||
    echo "programs/08-Abstract-Data-Types/scanadt.h: original size 5000, current size $shar_count"
fi
# ============= programs/08-Abstract-Data-Types/stack.c ==============
if test -f 'programs/08-Abstract-Data-Types/stack.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/08-Abstract-Data-Types/stack.c (file already exists)'
else
  echo 'x - extracting programs/08-Abstract-Data-Types/stack.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/08-Abstract-Data-Types/stack.c' &&
/*
X * File: stack.c
X * -------------
X * This file implements the stack.h interface.  Note that the
X * implementation is independent of the type of value stored
X * in the stack.  That type is defined by the interface as
X * the type name stackElementT.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "stack.h"
X
/*
X * Constant: InitialStackSize
X * --------------------------
X * This constant defines the initial size of the stack array.
X * Any positive value will work correctly, although changing
X * this parameter can affect performance.  Making this value
X * larger postpones the first reallocation but causes stacks
X * to consume more memory.
X */
X
#define InitialStackSize 100
X
/*
X * Type: stackCDT
X * --------------
X * The type stackCDT is the concrete representation of the type
X * stackADT defined by the interface.  In this implementation,
X * the elements are stored in a dynamic array that doubles in
X * size if the old stack becomes full.
X */
X
struct stackCDT {
X    stackElementT *elements;
X    int count;
X    int size;
};
X
/* Private function prototypes */
X
static void ExpandStack(stackADT stack);
X
/* Exported entries */
X
stackADT NewStack(void)
{
X    stackADT stack;
X
X    stack = New(stackADT);
X    stack->elements = NewArray(InitialStackSize, stackElementT);
X    stack->count = 0;
X    stack->size = InitialStackSize;
X    return (stack);
}
X
void FreeStack(stackADT stack)
{
X    FreeBlock(stack->elements);
X    FreeBlock(stack);
}
X
void Push(stackADT stack, stackElementT element)
{
X    if (stack->count == stack->size) ExpandStack(stack);
X    stack->elements[stack->count++] = element;
}
X
stackElementT Pop(stackADT stack)
{
X    if (StackIsEmpty(stack)) Error("Pop of an empty stack");
X    return (stack->elements[--stack->count]);
}
X
bool StackIsEmpty(stackADT stack)
{
X    return (stack->count == 0);
}
X
bool StackIsFull(stackADT stack)
{
X    return (FALSE);
}
X
int StackDepth(stackADT stack)
{
X    return (stack->count);
}
X
stackElementT GetStackElement(stackADT stack, int index)
{
X    if (index < 0 || index >= stack->count) {
X        Error("Non-existent stack element");
X    }
X    return (stack->elements[stack->count - index - 1]);
}
X
/* Private functions */
X
/* Function: ExpandStack
X * Usage: ExpandStack(stack);
X * --------------------------
X * This function expands a full stack by doubling the size of its
X * dynamic array, copying the old elements to the new array, and
X * then freeing the old array storage.
X */
X
static void ExpandStack(stackADT stack)
{
X    stackElementT *array;
X    int i, newSize;
X
X    newSize = stack->size * 2;
X    array = NewArray(newSize, stackElementT);
X    for (i = 0; i < stack->size; i++) {
X        array[i] = stack->elements[i];
X    }
X    FreeBlock(stack->elements);
X    stack->elements = array;
X    stack->size = newSize;
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/08-Abstract-Data-Types/stack.c' &&
  chmod 0644 'programs/08-Abstract-Data-Types/stack.c' ||
  echo 'restore of programs/08-Abstract-Data-Types/stack.c failed'
  shar_count="`wc -c < 'programs/08-Abstract-Data-Types/stack.c'`"
  test 2785 -eq "$shar_count" ||
    echo "programs/08-Abstract-Data-Types/stack.c: original size 2785, current size $shar_count"
fi
# ============= programs/08-Abstract-Data-Types/stack.h ==============
if test -f 'programs/08-Abstract-Data-Types/stack.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/08-Abstract-Data-Types/stack.h (file already exists)'
else
  echo 'x - extracting programs/08-Abstract-Data-Types/stack.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/08-Abstract-Data-Types/stack.h' &&
/*
X * File: stack.h
X * -------------
X * This interface defines an abstraction for stacks.  In any
X * single application that uses this interface, the values in
X * the stack are constrained to a single type, although it
X * is easy to change that type by changing the definition of
X * stackElementT in this interface.
X */
X
#ifndef _stack_h
#define _stack_h
X
#include "genlib.h"
X
/*
X * Type: stackElementT
X * -------------------
X * The type stackElementT is used in this interface to indicate
X * the type of values that can be stored in the stack.  Here the
X * stack is used to store values of type double, but that can
X * be changed by editing this definition line.
X */
X
typedef double stackElementT;
X
/*
X * Type: stackADT
X * --------------
X * The type stackADT represents the abstract type used to store
X * the elements that have been pushed.  Because stackADT is
X * defined only as a pointer to a concrete structure that is not
X * itself defined in the interface, clients have no access to
X * the underlying fields.
X */
X
typedef struct stackCDT *stackADT;
X
/*
X * Function: NewStack
X * Usage: stack = NewStack();
X * --------------------------
X * This function allocates and returns a new stack, which is
X * initially empty.
X */
X
stackADT NewStack(void);
X
/*
X * Function: FreeStack
X * Usage: FreeStack(stack);
X * ------------------------
X * This function frees the storage associated with the stack.
X */
X
void FreeStack(stackADT stack);
X
/*
X * Function: Push
X * Usage: Push(stack, element);
X * ----------------------------
X * This function pushes the specified element onto the stack.
X */
X
void Push(stackADT stack, stackElementT element);
X
/*
X * Function: Pop
X * Usage: element = Pop(stack);
X * ----------------------------
X * This function pops the top element from the stack and returns
X * that value.  The first value popped is always the last one
X * that was pushed.  If the stack is empty when Pop is called,
X * the function calls Error with an appropriate message.
X */
X
stackElementT Pop(stackADT stack);
X
/*
X * Functions: StackIsEmpty, StackIsFull
X * Usage: if (StackIsEmpty(stack)) . . .
X *        if (StackIsFull(stack)) . . .
X * -------------------------------------
X * This functions test whether the stack is empty or full.
X */
X
bool StackIsEmpty(stackADT stack);
bool StackIsFull(stackADT stack);
X
/*
X * Function: StackDepth
X * Usage: depth = StackDepth(stack);
X * ---------------------------------
X * This function returns the number of elements currently pushed
X * on the stack.
X */
X
int StackDepth(stackADT stack);
X
/*
X * Function: GetStackElement
X * Usage: element = GetStackElement(stack, index);
X * -----------------------------------------------
X * This function returns the element at the specified index in
X * the stack, where the top of the stack is defined as index 0.
X * For example, calling GetStackElement(stack, 0) returns the top
X * element on the stack without removing it.  If the caller tries
X * to select an out-of-range element, GetStackElement calls Error.
X * Note: This function is not a fundamental stack operation and
X * is instead provided principally to facilitate debugging.
X */
X
stackElementT GetStackElement(stackADT stack, int index);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/08-Abstract-Data-Types/stack.h' &&
  chmod 0644 'programs/08-Abstract-Data-Types/stack.h' ||
  echo 'restore of programs/08-Abstract-Data-Types/stack.h failed'
  shar_count="`wc -c < 'programs/08-Abstract-Data-Types/stack.h'`"
  test 3186 -eq "$shar_count" ||
    echo "programs/08-Abstract-Data-Types/stack.h: original size 3186, current size $shar_count"
fi
# ============= programs/08-Abstract-Data-Types/testscan.c ==============
if test -f 'programs/08-Abstract-Data-Types/testscan.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/08-Abstract-Data-Types/testscan.c (file already exists)'
else
  echo 'x - extracting programs/08-Abstract-Data-Types/testscan.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/08-Abstract-Data-Types/testscan.c' &&
/*
X * File: testscan.c
X * ----------------
X * This program tests the scanner abstraction by breaking
X * a single line into tokens.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "simpio.h"
#include "strlib.h"
#include "scanadt.h"
X
main()
{
X    scannerADT myScanner;
X    string token;
X    int nTokens;
X
X    myScanner = NewScanner();
X    printf("Enter input line: ");
X    SetScannerString(myScanner, GetLine());
X    nTokens = 0;
X    while (MoreTokensExist(myScanner)) {
X        token = ReadToken(myScanner);
X        nTokens++;
X        printf("%2d: \"%s\"\n", nTokens, token);
X    }
X    FreeScanner(myScanner);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/08-Abstract-Data-Types/testscan.c' &&
  chmod 0644 'programs/08-Abstract-Data-Types/testscan.c' ||
  echo 'restore of programs/08-Abstract-Data-Types/testscan.c failed'
  shar_count="`wc -c < 'programs/08-Abstract-Data-Types/testscan.c'`"
  test 616 -eq "$shar_count" ||
    echo "programs/08-Abstract-Data-Types/testscan.c: original size 616, current size $shar_count"
fi
# ============= programs/08-Abstract-Data-Types/Makefile ==============
if test -f 'programs/08-Abstract-Data-Types/Makefile' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/08-Abstract-Data-Types/Makefile (file already exists)'
else
  echo 'x - extracting programs/08-Abstract-Data-Types/Makefile (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/08-Abstract-Data-Types/Makefile' &&
# Makefile for programs in directory 08-Abstract-Data-Types
# ***************************************************************
X
PROGRAMS = \
X    rpncalc \
X    testscan
X
# ***************************************************************
# Parameters to control Makefile operation
# Note that the gccx command script must be defined
X
CC = gccx
CFLAGS = 
X
# ***************************************************************
# Entry to bring the package up to date
X
all: $(PROGRAMS)
X
# ***************************************************************
# Standard entries to remove files from the directories
#    tidy    -- eliminate unwanted files
#    scratch -- delete derived files in preparation for rebuild
X
tidy:
X	rm -f ,* .,* *~ core a.out graphics.ps
X
scratch: tidy
X	rm -f *.o *.a $(PROGRAMS)
X
# ***************************************************************
# C compilations
X
rpncalc.o: rpncalc.c stack.h
X	$(CC) $(CFLAGS) -c rpncalc.c
X
scanadt.o: scanadt.c scanadt.h
X	$(CC) $(CFLAGS) -c scanadt.c
X
stack.o: stack.c stack.h
X	$(CC) $(CFLAGS) -c stack.c
X
testscan.o: testscan.c scanadt.h
X	$(CC) $(CFLAGS) -c testscan.c
X
X
# ***************************************************************
# Executable programs
X
rpncalc: rpncalc.o stack.o
X	$(CC) $(CFLAGS) -o rpncalc rpncalc.o stack.o
X
testscan: testscan.o scanadt.o
X	$(CC) $(CFLAGS) -o testscan testscan.o scanadt.o
X
SHAR_EOF
  $shar_touch -am 0905205197 'programs/08-Abstract-Data-Types/Makefile' &&
  chmod 0644 'programs/08-Abstract-Data-Types/Makefile' ||
  echo 'restore of programs/08-Abstract-Data-Types/Makefile failed'
  shar_count="`wc -c < 'programs/08-Abstract-Data-Types/Makefile'`"
  test 1364 -eq "$shar_count" ||
    echo "programs/08-Abstract-Data-Types/Makefile: original size 1364, current size $shar_count"
fi
# ============= programs/09-Efficiency-and-ADTs/arraybuf.c ==============
if test ! -d 'programs/09-Efficiency-and-ADTs'; then
  echo 'x - creating directory programs/09-Efficiency-and-ADTs'
  mkdir 'programs/09-Efficiency-and-ADTs'
fi
if test -f 'programs/09-Efficiency-and-ADTs/arraybuf.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/09-Efficiency-and-ADTs/arraybuf.c (file already exists)'
else
  echo 'x - extracting programs/09-Efficiency-and-ADTs/arraybuf.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/09-Efficiency-and-ADTs/arraybuf.c' &&
/*
X * File: arraybuf.c
X * ----------------
X * This file implements the buffer.h abstraction using an
X * array to represent the buffer.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "buffer.h"
X
/*
X * Type: bufferCDT
X * ---------------
X * In this representation of the buffer, the characters are stored
X * in an array embedded within a structure that also holds the
X * length of the buffer and the cursor position as integers.
X * The cursor indicates the index position of the character that
X * follows where the cursor would appear on the screen.
X */
X
#define MaxBuffer 100
X
struct bufferCDT {
X    char text[MaxBuffer];
X    int length;
X    int cursor;
};
X
/* Exported entries */
X
bufferADT NewBuffer(void)
{
X    bufferADT buffer;
X
X    buffer = New(bufferADT);
X    buffer->length = buffer->cursor = 0;
X    return (buffer);
}
X
void FreeBuffer(bufferADT buffer)
{
X    FreeBlock(buffer);
}
X
void MoveCursorForward(bufferADT buffer)
{
X    if (buffer->cursor < buffer->length) buffer->cursor++;
}
X
void MoveCursorBackward(bufferADT buffer)
{
X    if (buffer->cursor > 0) buffer->cursor--;
}
X
void MoveCursorToStart(bufferADT buffer)
{
X    buffer->cursor = 0;
}
X
void MoveCursorToEnd(bufferADT buffer)
{
X    buffer->cursor = buffer->length;
}
X
/*
X * Implementation notes: InsertCharacter and DeleteCharacter
X * ---------------------------------------------------------
X * Each of the functions that inserts or deletes characters must
X * shift all subsequent characters in the array, either to make
X * room for new insertions or to close up space left by deletions.
X */
X
void InsertCharacter(bufferADT buffer, char ch)
{
X    int i;
X
X    if (buffer->length == MaxBuffer) Error("Buffer size exceeded");
X    for (i = buffer->length; i > buffer->cursor; i--) {
X        buffer->text[i] = buffer->text[i - 1];
X    }
X    buffer->text[buffer->cursor] = ch;
X    buffer->length++;
X    buffer->cursor++;
}
X
void DeleteCharacter(bufferADT buffer)
{
X    int i;
X
X    if (buffer->cursor < buffer->length) {
X        for (i = buffer->cursor+1; i < buffer->length; i++) {
X            buffer->text[i - 1] = buffer->text[i];
X        }
X        buffer->length--;
X    }
}
X
void DisplayBuffer(bufferADT buffer)
{
X    int i;
X
X    for (i = 0; i < buffer->length; i++) {
X        printf(" %c", buffer->text[i]);
X    }
X    printf("\n");
X    for (i = 0; i < buffer->cursor; i++) {
X        printf("  ");
X    }
X    printf("^\n");
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/09-Efficiency-and-ADTs/arraybuf.c' &&
  chmod 0644 'programs/09-Efficiency-and-ADTs/arraybuf.c' ||
  echo 'restore of programs/09-Efficiency-and-ADTs/arraybuf.c failed'
  shar_count="`wc -c < 'programs/09-Efficiency-and-ADTs/arraybuf.c'`"
  test 2397 -eq "$shar_count" ||
    echo "programs/09-Efficiency-and-ADTs/arraybuf.c: original size 2397, current size $shar_count"
fi
# ============= programs/09-Efficiency-and-ADTs/buffer.h ==============
if test -f 'programs/09-Efficiency-and-ADTs/buffer.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/09-Efficiency-and-ADTs/buffer.h (file already exists)'
else
  echo 'x - extracting programs/09-Efficiency-and-ADTs/buffer.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/09-Efficiency-and-ADTs/buffer.h' &&
/*
X * File: buffer.h
X * --------------
X * This file defines the interface for an editor buffer abstraction.
X */
X
#ifndef _buffer_h
#define _buffer_h
X
#include "genlib.h"
X
/*
X * Type: bufferADT
X * ---------------
X * This type defines the abstract type used to represent
X * an editor buffer.
X */
X
typedef struct bufferCDT *bufferADT;
X
/* Exported entries */
X
/*
X * Function: NewBuffer
X * Usage: buffer = NewBuffer();
X * ----------------------------
X * This function dynamically allocates enough memory for the
X * underlying representation of a bufferADT and initializes
X * it to represent an empty buffer.
X */
X
bufferADT NewBuffer(void);
X
/*
X * Function: FreeBuffer
X * Usage: FreeBuffer(buffer);
X * --------------------------
X * This function frees the storage associated with the buffer.
X */
X
void FreeBuffer(bufferADT buffer);
X
/*
X * Functions: MoveCursorForward, MoveCursorBackward
X * Usage: MoveCursorForward(buffer);
X *        MoveCursorBackward(buffer);
X * ----------------------------------
X * These functions move the cursor forward or backward one
X * character, respectively.  If you call MoveCursorForward
X * at the end of the buffer or MoveCursorBackward at the
X * beginning, the function call has no effect.
X */
X
void MoveCursorForward(bufferADT buffer);
void MoveCursorBackward(bufferADT buffer);
X
/*
X * Functions: MoveCursorToStart, MoveCursorToEnd
X * Usage: MoveCursorToStart(buffer);
X *        MoveCursorToEnd(buffer);
X * -------------------------------
X * These functions move the cursor to the start or the
X * end of the buffer, respectively.
X */
X
void MoveCursorToStart(bufferADT buffer);
void MoveCursorToEnd(bufferADT buffer);
X
/*
X * Function: InsertCharacter
X * Usage: InsertCharacter(buffer, ch);
X * -----------------------------------
X * This function inserts the single character ch into the
X * buffer at the current cursor position.  The cursor is
X * positioned after the inserted character, which allows
X * for consecutive insertions.
X */
X
void InsertCharacter(bufferADT buffer, char ch);
X
/*
X * Function: DeleteCharacter
X * Usage: DeleteCharacter(buffer);
X * -------------------------------
X * This function deletes the character immediately after
X * the cursor.  If the cursor is at the end of the buffer,
X * this function has no effect.
X */
X
void DeleteCharacter(bufferADT buffer);
X
/*
X * Function: DisplayBuffer
X * Usage: DisplayBuffer(buffer);
X * -----------------------------
X * This function displays the current contents of the buffer
X * on the console.
X */
X
void DisplayBuffer(bufferADT buffer);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/09-Efficiency-and-ADTs/buffer.h' &&
  chmod 0644 'programs/09-Efficiency-and-ADTs/buffer.h' ||
  echo 'restore of programs/09-Efficiency-and-ADTs/buffer.h failed'
  shar_count="`wc -c < 'programs/09-Efficiency-and-ADTs/buffer.h'`"
  test 2538 -eq "$shar_count" ||
    echo "programs/09-Efficiency-and-ADTs/buffer.h: original size 2538, current size $shar_count"
fi
# ============= programs/09-Efficiency-and-ADTs/editor.c ==============
if test -f 'programs/09-Efficiency-and-ADTs/editor.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/09-Efficiency-and-ADTs/editor.c (file already exists)'
else
  echo 'x - extracting programs/09-Efficiency-and-ADTs/editor.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/09-Efficiency-and-ADTs/editor.c' &&
/*
X * File: editor.c
X * --------------
X * This program implements a simple character editor, which
X * is used to test the buffer abstraction.  The editor reads
X * and executes simple commands entered by the user.
X */
X
#include <stdio.h>
#include <ctype.h>
#include "genlib.h"
#include "buffer.h"
#include "simpio.h"
X
/* Private function prototypes */
X
static void ExecuteCommand(bufferADT buffer, string line);
static void HelpCommand(void);
X
/* Main program */
X
main()
{
X    bufferADT buffer;
X
X    buffer = NewBuffer();
X    while (TRUE) {
X        printf("*");
X        ExecuteCommand(buffer, GetLine());
X        DisplayBuffer(buffer);
X    }
X    FreeBuffer(buffer);
}
X
/*
X * Function: ExecuteCommand
X * Usage: ExecuteCommand(buffer, line);
X * ------------------------------------
X * This function parses the user command in the string line
X * and executes it on the buffer.
X */
X
static void ExecuteCommand(bufferADT buffer, string line)
{
X    int i;
X
X    switch (toupper(line[0])) {
X      case 'I': for (i = 1; line[i] != '\0'; i++) {
X                    InsertCharacter(buffer, line[i]);
X                }
X                break;
X      case 'D': DeleteCharacter(buffer); break;
X      case 'F': MoveCursorForward(buffer); break;
X      case 'B': MoveCursorBackward(buffer); break;
X      case 'J': MoveCursorToStart(buffer); break;
X      case 'E': MoveCursorToEnd(buffer); break;
X      case 'H': HelpCommand(); break;
X      case 'Q': exit(0);
X      default:  printf("Illegal command\n"); break;
X    }
}
X
/*
X * Function: HelpCommand
X * Usage: HelpCommand();
X * ---------------------
X * This function lists the available editor commands.
X */
X
static void HelpCommand(void)
{
X    printf("Use the following commands to edit the buffer:\n");
X    printf("  I...   Inserts text up to the end of the line\n");
X    printf("  F      Moves forward a character\n");
X    printf("  B      Moves backward a character\n");
X    printf("  J      Jumps to the beginning of the buffer\n");
X    printf("  E      Jumps to the end of the buffer\n");
X    printf("  D      Deletes the next character\n");
X    printf("  H      Generates a help message\n");
X    printf("  Q      Quits the program\n");
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/09-Efficiency-and-ADTs/editor.c' &&
  chmod 0644 'programs/09-Efficiency-and-ADTs/editor.c' ||
  echo 'restore of programs/09-Efficiency-and-ADTs/editor.c failed'
  shar_count="`wc -c < 'programs/09-Efficiency-and-ADTs/editor.c'`"
  test 2173 -eq "$shar_count" ||
    echo "programs/09-Efficiency-and-ADTs/editor.c: original size 2173, current size $shar_count"
fi
# ============= programs/09-Efficiency-and-ADTs/listbuf.c ==============
if test -f 'programs/09-Efficiency-and-ADTs/listbuf.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/09-Efficiency-and-ADTs/listbuf.c (file already exists)'
else
  echo 'x - extracting programs/09-Efficiency-and-ADTs/listbuf.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/09-Efficiency-and-ADTs/listbuf.c' &&
/*
X * File: listbuf.c
X * ---------------
X * This file implements the buffer.h abstraction using a linked
X * list to represent the buffer.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "strlib.h"
#include "buffer.h"
X
/* Types */
X
typedef struct cellT {
X    char ch;
X    struct cellT *link;
} cellT;
X
struct bufferCDT {
X    cellT *start;
X    cellT *cursor;
};
X
/*
X * Implementation notes: NewBuffer
X * -------------------------------
X * This function allocates an empty editor buffer, represented
X * as a linked list.  To simplify the link list operation, this
X * implementation adopts the useful programming tactic of
X * keeping an extra "dummy" cell at the beginning of each list,
X * so that the empty buffer has the following representation:
X *
X *     +-------+          +------+
X *     |   o---+-----====>|      |
X *     +-------+    /     +------+
X *     |   o---+---/      | NULL |
X *     +-------+          +------+
X */
X
bufferADT NewBuffer(void)
{
X    bufferADT buffer;
X
X    buffer = New(bufferADT);
X    buffer->start = buffer->cursor = New(cellT *);
X    buffer->start->link = NULL;
X    return (buffer);
}
X
/*
X * Implementation notes: FreeBuffer
X * --------------------------------
X * FreeBuffer must free every cell in the buffer as well as
X * the buffer storage itself.  Note that the loop structure
X * is not exactly the standard idiom for processing every
X * cell within a linked list, because it is not legal to
X * free a cell and later look at its link field.  To avoid
X * selecting fields in the structure after it has been freed,
X * you have to copy the link pointer before calling FreeBlock.
X */
X
void FreeBuffer(bufferADT buffer)
{
X    cellT *cp, *next;
X
X    cp = buffer->start;
X    while (cp != NULL) {
X        next = cp->link;
X        FreeBlock(cp);
X        cp = next;
X    }
X    FreeBlock(buffer);
}
X
void MoveCursorForward(bufferADT buffer)
{
X    if (buffer->cursor->link != NULL) {
X        buffer->cursor = buffer->cursor->link;
X    }
}
X
void MoveCursorBackward(bufferADT buffer)
{
X    cellT *cp;
X
X    if (buffer->cursor != buffer->start) {
X        cp = buffer->start;
X        while (cp->link != buffer->cursor) {
X             cp = cp->link;
X        }
X        buffer->cursor = cp;
X    }
}
X
void MoveCursorToStart(bufferADT buffer)
{
X    buffer->cursor = buffer->start;
}
X
void MoveCursorToEnd(bufferADT buffer)
{
X    while (buffer->cursor->link != NULL) {
X        MoveCursorForward(buffer);
X    }
}
X
void InsertCharacter(bufferADT buffer, char ch)
{
X    cellT *cp;
X
X    cp = New(cellT *);
X    cp->ch = ch;
X    cp->link = buffer->cursor->link;
X    buffer->cursor->link = cp;
X    buffer->cursor = cp;
}
X
void DeleteCharacter(bufferADT buffer)
{
X    cellT *cp;
X
X    if (buffer->cursor->link != NULL) {
X        cp = buffer->cursor->link;
X        buffer->cursor->link = cp->link;
X        FreeBlock(cp);
X    }
}
X
void DisplayBuffer(bufferADT buffer)
{
X    cellT *cp;
X
X    for (cp = buffer->start->link; cp != NULL; cp = cp->link) {
X        printf(" %c", cp->ch);
X    }
X    printf("\n");
X    for (cp = buffer->start; cp != buffer->cursor; cp = cp->link) {
X        printf("  ");
X    }
X    printf("^\n");
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/09-Efficiency-and-ADTs/listbuf.c' &&
  chmod 0644 'programs/09-Efficiency-and-ADTs/listbuf.c' ||
  echo 'restore of programs/09-Efficiency-and-ADTs/listbuf.c failed'
  shar_count="`wc -c < 'programs/09-Efficiency-and-ADTs/listbuf.c'`"
  test 3125 -eq "$shar_count" ||
    echo "programs/09-Efficiency-and-ADTs/listbuf.c: original size 3125, current size $shar_count"
fi
# ============= programs/09-Efficiency-and-ADTs/stack.c ==============
if test -f 'programs/09-Efficiency-and-ADTs/stack.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/09-Efficiency-and-ADTs/stack.c (file already exists)'
else
  echo 'x - extracting programs/09-Efficiency-and-ADTs/stack.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/09-Efficiency-and-ADTs/stack.c' &&
/*
X * File: stack.c
X * -------------
X * This file implements the stack.h interface.  Note that the
X * implementation is independent of the type of value stored
X * in the stack.  That type is defined by the interface as
X * the type name stackElementT.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "stack.h"
X
/*
X * Constant: InitialStackSize
X * --------------------------
X * This constant defines the initial size of the stack array.
X * Any positive value will work correctly, although changing
X * this parameter can affect performance.  Making this value
X * larger postpones the first reallocation but causes stacks
X * to consume more memory.
X */
X
#define InitialStackSize 100
X
/*
X * Type: stackCDT
X * --------------
X * The type stackCDT is the concrete representation of the type
X * stackADT defined by the interface.  In this implementation,
X * the elements are stored in a dynamic array that doubles in
X * size if the old stack becomes full.
X */
X
struct stackCDT {
X    stackElementT *elements;
X    int count;
X    int size;
};
X
/* Private function prototypes */
X
static void ExpandStack(stackADT stack);
X
/* Exported entries */
X
stackADT NewStack(void)
{
X    stackADT stack;
X
X    stack = New(stackADT);
X    stack->elements = NewArray(InitialStackSize, stackElementT);
X    stack->count = 0;
X    stack->size = InitialStackSize;
X    return (stack);
}
X
void FreeStack(stackADT stack)
{
X    FreeBlock(stack->elements);
X    FreeBlock(stack);
}
X
void Push(stackADT stack, stackElementT element)
{
X    if (stack->count == stack->size) ExpandStack(stack);
X    stack->elements[stack->count++] = element;
}
X
stackElementT Pop(stackADT stack)
{
X    if (StackIsEmpty(stack)) Error("Pop of an empty stack");
X    return (stack->elements[--stack->count]);
}
X
bool StackIsEmpty(stackADT stack)
{
X    return (stack->count == 0);
}
X
bool StackIsFull(stackADT stack)
{
X    return (FALSE);
}
X
int StackDepth(stackADT stack)
{
X    return (stack->count);
}
X
stackElementT GetStackElement(stackADT stack, int index)
{
X    if (index < 0 || index >= stack->count) {
X        Error("Non-existent stack element");
X    }
X    return (stack->elements[stack->count - index - 1]);
}
X
/* Private functions */
X
/* Function: ExpandStack
X * Usage: ExpandStack(stack);
X * --------------------------
X * This function expands a full stack by doubling the size of its
X * dynamic array, copying the old elements to the new array, and
X * then freeing the old array storage.
X */
X
static void ExpandStack(stackADT stack)
{
X    stackElementT *array;
X    int i, newSize;
X
X    newSize = stack->size * 2;
X    array = NewArray(newSize, stackElementT);
X    for (i = 0; i < stack->size; i++) {
X        array[i] = stack->elements[i];
X    }
X    FreeBlock(stack->elements);
X    stack->elements = array;
X    stack->size = newSize;
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/09-Efficiency-and-ADTs/stack.c' &&
  chmod 0644 'programs/09-Efficiency-and-ADTs/stack.c' ||
  echo 'restore of programs/09-Efficiency-and-ADTs/stack.c failed'
  shar_count="`wc -c < 'programs/09-Efficiency-and-ADTs/stack.c'`"
  test 2785 -eq "$shar_count" ||
    echo "programs/09-Efficiency-and-ADTs/stack.c: original size 2785, current size $shar_count"
fi
# ============= programs/09-Efficiency-and-ADTs/stack.h ==============
if test -f 'programs/09-Efficiency-and-ADTs/stack.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/09-Efficiency-and-ADTs/stack.h (file already exists)'
else
  echo 'x - extracting programs/09-Efficiency-and-ADTs/stack.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/09-Efficiency-and-ADTs/stack.h' &&
/*
X * File: stack.h
X * -------------
X * This interface defines an abstraction for stacks.  In any
X * single application that uses this interface, the values in
X * the stack are constrained to a single type, although it
X * is easy to change that type by changing the definition of
X * stackElementT in this interface.
X */
X
#ifndef _stack_h
#define _stack_h
X
#include "genlib.h"
X
/*
X * Type: stackElementT
X * -------------------
X * The type stackElementT is used in this interface to indicate
X * the type of values that can be stored in the stack.  Here the
X * stack is used to store values of type char, but that can
X * be changed by editing this definition line.
X */
X
typedef char stackElementT;
X
/*
X * Type: stackADT
X * --------------
X * The type stackADT represents the abstract type used to store
X * the elements that have been pushed.  Because stackADT is
X * defined only as a pointer to a concrete structure that is not
X * itself defined in the interface, clients have no access to
X * the underlying fields.
X */
X
typedef struct stackCDT *stackADT;
X
/*
X * Function: NewStack
X * Usage: stack = NewStack();
X * --------------------------
X * This function allocates and returns a new stack, which is
X * initially empty.
X */
X
stackADT NewStack(void);
X
/*
X * Function: FreeStack
X * Usage: FreeStack(stack);
X * ------------------------
X * This function frees the storage associated with the stack.
X */
X
void FreeStack(stackADT stack);
X
/*
X * Function: Push
X * Usage: Push(stack, element);
X * ----------------------------
X * This function pushes the specified element onto the stack.
X */
X
void Push(stackADT stack, stackElementT element);
X
/*
X * Function: Pop
X * Usage: element = Pop(stack);
X * ----------------------------
X * This function pops the top element from the stack and returns
X * that value.  The first value popped is always the last one
X * that was pushed.  If the stack is empty when Pop is called,
X * the function calls Error with an appropriate message.
X */
X
stackElementT Pop(stackADT stack);
X
/*
X * Functions: StackIsEmpty, StackIsFull
X * Usage: if (StackIsEmpty(stack)) . . .
X *        if (StackIsFull(stack)) . . .
X * -------------------------------------
X * This functions test whether the stack is empty or full.
X */
X
bool StackIsEmpty(stackADT stack);
bool StackIsFull(stackADT stack);
X
/*
X * Function: StackDepth
X * Usage: depth = StackDepth(stack);
X * ---------------------------------
X * This function returns the number of elements currently pushed
X * on the stack.
X */
X
int StackDepth(stackADT stack);
X
/*
X * Function: GetStackElement
X * Usage: element = GetStackElement(stack, index);
X * -----------------------------------------------
X * This function returns the element at the specified index in
X * the stack, where the top of the stack is defined as index 0.
X * For example, calling GetStackElement(stack, 0) returns the top
X * element on the stack without removing it.  If the caller tries
X * to select an out-of-range element, GetStackElement calls Error.
X * Note: This function is not a fundamental stack operation and
X * is instead provided principally to facilitate debugging.
X */
X
stackElementT GetStackElement(stackADT stack, int index);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/09-Efficiency-and-ADTs/stack.h' &&
  chmod 0644 'programs/09-Efficiency-and-ADTs/stack.h' ||
  echo 'restore of programs/09-Efficiency-and-ADTs/stack.h failed'
  shar_count="`wc -c < 'programs/09-Efficiency-and-ADTs/stack.h'`"
  test 3182 -eq "$shar_count" ||
    echo "programs/09-Efficiency-and-ADTs/stack.h: original size 3182, current size $shar_count"
fi
# ============= programs/09-Efficiency-and-ADTs/stackbuf.c ==============
if test -f 'programs/09-Efficiency-and-ADTs/stackbuf.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/09-Efficiency-and-ADTs/stackbuf.c (file already exists)'
else
  echo 'x - extracting programs/09-Efficiency-and-ADTs/stackbuf.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/09-Efficiency-and-ADTs/stackbuf.c' &&
/*
X * File: stackbuf.c
X * ----------------
X * This file implements the buffer.h abstraction using a pair of
X * stacks to represent the buffer.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "buffer.h"
#include "stack.h"
X
/*
X * Type: bufferCDT
X * ---------------
X * In this representation of the buffer, all characters are stored
X * in one of two stacks.  Characters before the cursor are pushed
X * on the before stack; those after the cursor are pushed on the
X * after stack.  The cursor is represented implicitly by the
X * boundary between the stacks.  Characters are at deeper levels on
X * their respective stack if they are farther from the cursor.  As
X * an example, the buffer containing ABCDE with the cursor between
X * the C and the D would look like this:
X *
X *         C
X *         B         D
X *         A         E
X *      ------     -----
X *      before     after
X */
X
struct bufferCDT {
X    stackADT before;
X    stackADT after;
};
X
/* Exported entries */
X
bufferADT NewBuffer(void)
{
X    bufferADT buffer;
X
X    buffer = New(bufferADT);
X    buffer->before = NewStack();
X    buffer->after = NewStack();
X    return (buffer);
}
X
void FreeBuffer(bufferADT buffer)
{
X    FreeStack(buffer->before);
X    FreeStack(buffer->after);
X    FreeBlock(buffer);
}
X
void MoveCursorForward(bufferADT buffer)
{
X    if (!StackIsEmpty(buffer->after)) {
X        Push(buffer->before, Pop(buffer->after));
X    }
}
X
void MoveCursorBackward(bufferADT buffer)
{
X    if (!StackIsEmpty(buffer->before)) {
X        Push(buffer->after, Pop(buffer->before));
X    }
}
X
void MoveCursorToStart(bufferADT buffer)
{
X    while (!StackIsEmpty(buffer->before)) {
X        Push(buffer->after, Pop(buffer->before));
X    }
}
X
void MoveCursorToEnd(bufferADT buffer)
{
X    while (!StackIsEmpty(buffer->after)) {
X        Push(buffer->before, Pop(buffer->after));
X    }
}
X
void InsertCharacter(bufferADT buffer, char ch)
{
X    Push(buffer->before, ch);
}
X
void DeleteCharacter(bufferADT buffer)
{
X    if (!StackIsEmpty(buffer->after)) {
X        (void) Pop(buffer->after);
X    }
}
X
void DisplayBuffer(bufferADT buffer)
{
X    int i;
X
X    for (i = StackDepth(buffer->before) - 1; i >= 0; i--) {
X        printf(" %c", GetStackElement(buffer->before, i));
X    }
X    for (i = 0; i < StackDepth(buffer->after); i++) {
X        printf(" %c", GetStackElement(buffer->after, i));
X    }
X    printf("\n");
X    for (i = 0; i < StackDepth(buffer->before); i++) {
X        printf("  ");
X    }
X    printf("^\n");
}
X
SHAR_EOF
  $shar_touch -am 0903182097 'programs/09-Efficiency-and-ADTs/stackbuf.c' &&
  chmod 0644 'programs/09-Efficiency-and-ADTs/stackbuf.c' ||
  echo 'restore of programs/09-Efficiency-and-ADTs/stackbuf.c failed'
  shar_count="`wc -c < 'programs/09-Efficiency-and-ADTs/stackbuf.c'`"
  test 2467 -eq "$shar_count" ||
    echo "programs/09-Efficiency-and-ADTs/stackbuf.c: original size 2467, current size $shar_count"
fi
# ============= programs/09-Efficiency-and-ADTs/Makefile ==============
if test -f 'programs/09-Efficiency-and-ADTs/Makefile' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/09-Efficiency-and-ADTs/Makefile (file already exists)'
else
  echo 'x - extracting programs/09-Efficiency-and-ADTs/Makefile (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/09-Efficiency-and-ADTs/Makefile' &&
# Makefile for programs in directory 09-Efficiency-and-ADTs
# ***************************************************************
X
PROGRAMS = \
X    array-editor \
X    stack-editor \
X    list-editor
X
# ***************************************************************
# Parameters to control Makefile operation
# Note that the gccx command script must be defined
X
CC = gccx
CFLAGS = 
X
# ***************************************************************
# Entry to bring the package up to date
X
all: $(PROGRAMS)
X
# ***************************************************************
# Standard entries to remove files from the directories
#    tidy    -- eliminate unwanted files
#    scratch -- delete derived files in preparation for rebuild
X
tidy:
X	rm -f ,* .,* *~ core a.out graphics.ps
X
scratch: tidy
X	rm -f *.o *.a $(PROGRAMS)
X
# ***************************************************************
# C compilations
X
arraybuf.o: arraybuf.c buffer.h
X	$(CC) $(CFLAGS) -c arraybuf.c
X
editor.o: editor.c buffer.h
X	$(CC) $(CFLAGS) -c editor.c
X
listbuf.o: listbuf.c buffer.h
X	$(CC) $(CFLAGS) -c listbuf.c
X
stack.o: stack.c stack.h
X	$(CC) $(CFLAGS) -c stack.c
X
stackbuf.o: stackbuf.c buffer.h stack.h
X	$(CC) $(CFLAGS) -c stackbuf.c
X
X
# ***************************************************************
# Executable programs
X
array-editor: editor.o arraybuf.o
X	$(CC) $(CFLAGS) -o array-editor editor.o arraybuf.o
X
stack-editor: editor.o stackbuf.o stack.o
X	$(CC) $(CFLAGS) -o stack-editor editor.o stackbuf.o stack.o
X
list-editor: editor.o listbuf.o
X	$(CC) $(CFLAGS) -o list-editor editor.o listbuf.o
X
SHAR_EOF
  $shar_touch -am 0905205697 'programs/09-Efficiency-and-ADTs/Makefile' &&
  chmod 0644 'programs/09-Efficiency-and-ADTs/Makefile' ||
  echo 'restore of programs/09-Efficiency-and-ADTs/Makefile failed'
  shar_count="`wc -c < 'programs/09-Efficiency-and-ADTs/Makefile'`"
  test 1579 -eq "$shar_count" ||
    echo "programs/09-Efficiency-and-ADTs/Makefile: original size 1579, current size $shar_count"
fi
# ============= programs/10-Linear-Structures/checkout.c ==============
if test ! -d 'programs/10-Linear-Structures'; then
  echo 'x - creating directory programs/10-Linear-Structures'
  mkdir 'programs/10-Linear-Structures'
fi
if test -f 'programs/10-Linear-Structures/checkout.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/10-Linear-Structures/checkout.c (file already exists)'
else
  echo 'x - extracting programs/10-Linear-Structures/checkout.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/10-Linear-Structures/checkout.c' &&
/*
X * File: checkout.c
X * ----------------
X * This program simulates a checkout line, such as one you
X * might encounter in a grocery store.  Customers arrive at
X * the checkout stand and get in line.  Those customers wait
X * in the line until the cashier is free, at which point
X * they are served and occupy the cashier for some period
X * of time.  After the service time is complete, the cashier
X * is free to serve the next customer in the line.
X *
X * In each unit of time, up to the parameter SimulationTime,
X * the following operations are performed:
X *
X * 1. Determine whether a new customer has arrived.
X *    New customers arrive randomly, with a probability
X *    determined by the parameter ArrivalPercentage.
X *
X * 2. If the cashier is busy, note that the cashier has
X *    spent another minute with that customer.  Eventually,
X *    the customer's time request is satisfied, which frees
X *    the cashier.
X *
X * 3. If the cashier is free, serve the next customer in line.
X *    The service time is taken to be a random period between
X *    MinServiceTime and MaxServiceTime.
X *
X * At the end of the simulation, the program displays the
X * parameters and the following computed results:
X *
X * o  The number of customers served
X * o  The average time spent in line
X * o  The average number of people in line
X */
X
#include <stdio.h>
#include <stdlib.h>
#include "genlib.h"
#include "strlib.h"
#include "random.h"
#include "queue.h"
X
/* Simulation parameters */
X
#define SimulationTime     2000
#define ArrivalProbability    0.1
#define MinServiceTime        5
#define MaxServiceTime       15
X
/*
X * Type: customerT
X * ---------------
X * A customer is represented using a pointer to a record
X * containing the following information:
X *
X * o The customer number (for debugging traces)
X * o The arrival time (to compute the waiting time)
X * o The time required for service
X */
X
typedef struct {
X    int customerNumber;
X    int arrivalTime;
X    int serviceTime;
} *customerT;
X
/*
X * Type: simDataT
X * --------------
X * This type stores the data required for the simulation.  The
X * main program declares a variable of this type and then passes
X * it by reference to every other function in the program.
X */
X
typedef struct {
X    queueADT queue;
X    customerT activeCustomer;
X    int time;
X    int numCustomers;
X    int numServed;
X    long totalWaitTime;
X    long totalLineLength;
} simDataT;
X
/*
X * Debugging option: traceFlag
X * ---------------------------
X * This variable controls whether the simulation produces a
X * debugging trace.
X */
X
static bool traceFlag = FALSE;
X
/* Private function declarations */
X
static void InitializeSimulation(simDataT *sdp);
static void RunSimulation(simDataT *sdp);
static void EnqueueCustomer(simDataT *sdp);
static void ProcessQueue(simDataT *sdp);
static void ServeCustomer(simDataT *sdp);
static void DismissCustomer(simDataT *sdp);
static void ReportResults(simDataT *sdp);
X
/* Main program */
X
main()
{
X    simDataT simData;
X
X    Randomize();
X    InitializeSimulation(&simData);
X    RunSimulation(&simData);
X    ReportResults(&simData);
}
X
/*
X * Function: InitializeSimulation
X * Usage: InitializeSimulation(&simData);
X * --------------------------------------
X * This function initializes the simulation data block whose
X * address is passed as the argument.
X */
X
static void InitializeSimulation(simDataT *sdp)
{
X    sdp->queue = NewQueue();
X    sdp->activeCustomer = NULL;
X    sdp->numServed = 0;
X    sdp->totalWaitTime = 0;
X    sdp->totalLineLength = 0;
}
X
/*
X * Function: RunSimulation
X * Usage: RunSimulation(&simData);
X * -------------------------------
X * This function runs the actual simulation.  In each time unit,
X * the program first checks to see whether a new customer arrives.
X * Then, if the cashier is busy (indicated by having a non-NULL
X * pointer in the activeCustomer field), the program decrements
X * the service time counter for that customer.  Finally, if the
X * cashier is free, it serves another customer from the queue
X * and updates the necessary bookkeeping data.
X */
X
static void RunSimulation(simDataT *sdp)
{
X    for (sdp->time = 0; sdp->time < SimulationTime; sdp->time++) {
X        if (RandomChance(ArrivalProbability)) {
X            EnqueueCustomer(sdp);
X        }
X        ProcessQueue(sdp);
X    }
}
X
/*
X * Function: EnqueueCustomer
X * Usage: EnqueueCustomer(&simData);
X * ---------------------------------
X * This function simulates the arrival of a new customer.
X */
X
static void EnqueueCustomer(simDataT *sdp)
{
X    customerT c;
X
X    sdp->numCustomers++;
X    c = New(customerT);
X    c->customerNumber = sdp->numCustomers;
X    c->arrivalTime = sdp->time;
X    c->serviceTime = RandomInteger(MinServiceTime, MaxServiceTime);
X    Enqueue(sdp->queue, c);
X    if (traceFlag) {
X        printf("%4d: Customer %d arrives and gets in line\n",
X               sdp->time, sdp->numCustomers);
X    }
}
X
/*
X * Function: ProcessQueue
X * Usage: ProcessQueue(&simData);
X * ------------------------------
X * This function processes a single time cycle for the queue.
X */
X
static void ProcessQueue(simDataT *sdp)
{
X    if (sdp->activeCustomer == NULL) {
X        if (!QueueIsEmpty(sdp->queue)) {
X            ServeCustomer(sdp);
X        }
X    } else {
X        if (sdp->activeCustomer->serviceTime == 0) {
X            DismissCustomer(sdp);
X        } else {
X            sdp->activeCustomer->serviceTime--;
X        }
X    }
X    sdp->totalLineLength += QueueLength(sdp->queue);
}
X
/*
X * Function: ServeCustomer
X * Usage: ServeCustomer(&simData);
X * -------------------------------
X * This function is called when the cashier is free and a
X * customer is waiting.  The effect is to serve the first
X * customer in the line and update the total waiting time.
X */
X
static void ServeCustomer(simDataT *sdp)
{
X    customerT c;
X
X    c = Dequeue(sdp->queue);
X    sdp->activeCustomer = c;
X    sdp->numServed++;
X    sdp->totalWaitTime += (sdp->time - c->arrivalTime);
X    if (traceFlag) {
X        printf("%4d: Customer %d reaches cashier\n",
X               sdp->time, c->customerNumber);
X    }
}
X
/*
X * Function: DismissCustomer
X * Usage: DismissCustomer(&simData);
X * ---------------------------------
X * This function is called when the active customer's service
X * time has dropped to 0. The cashier becomes free and the
X * program no longer needs to hold the customer's storage.
X */
X
static void DismissCustomer(simDataT *sdp)
{
X    if (traceFlag) {
X        printf("%4d: Customer %d leaves cashier\n",
X               sdp->time, sdp->activeCustomer->customerNumber);
X    }
X    FreeBlock(sdp->activeCustomer);
X    sdp->activeCustomer = NULL;
}
X
/*
X * Function: ReportResults
X * Usage: ReportResults(&simData);
X * -------------------------------
X * This function reports the results of the simulation.
X */
X
static void ReportResults(simDataT *sdp)
{
X    printf("Simulation results given the following parameters:\n");
X    printf("  SimulationTime:     %4d\n", (int) SimulationTime);
X    printf("  ArrivalProbability: %7.2f\n",
X                                   (double) ArrivalProbability);
X    printf("  MinServiceTime:     %4d\n", (int) MinServiceTime);
X    printf("  MaxServiceTime:     %4d\n", (int) MaxServiceTime);
X    printf("\n");
X    printf("Customers served:     %4d\n", sdp->numServed);
X    printf("Average waiting time: %7.2f\n",
X           (double) sdp->totalWaitTime / sdp->numServed);
X    printf("Average line length:  %7.2f\n",
X           (double) sdp->totalLineLength / SimulationTime);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/10-Linear-Structures/checkout.c' &&
  chmod 0644 'programs/10-Linear-Structures/checkout.c' ||
  echo 'restore of programs/10-Linear-Structures/checkout.c failed'
  shar_count="`wc -c < 'programs/10-Linear-Structures/checkout.c'`"
  test 7458 -eq "$shar_count" ||
    echo "programs/10-Linear-Structures/checkout.c: original size 7458, current size $shar_count"
fi
# ============= programs/10-Linear-Structures/dstack.c ==============
if test -f 'programs/10-Linear-Structures/dstack.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/10-Linear-Structures/dstack.c (file already exists)'
else
  echo 'x - extracting programs/10-Linear-Structures/dstack.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/10-Linear-Structures/dstack.c' &&
#include "stack.c"
SHAR_EOF
  $shar_touch -am 0903182097 'programs/10-Linear-Structures/dstack.c' &&
  chmod 0644 'programs/10-Linear-Structures/dstack.c' ||
  echo 'restore of programs/10-Linear-Structures/dstack.c failed'
  shar_count="`wc -c < 'programs/10-Linear-Structures/dstack.c'`"
  test 19 -eq "$shar_count" ||
    echo "programs/10-Linear-Structures/dstack.c: original size 19, current size $shar_count"
fi
# ============= programs/10-Linear-Structures/qarray.c ==============
if test -f 'programs/10-Linear-Structures/qarray.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/10-Linear-Structures/qarray.c (file already exists)'
else
  echo 'x - extracting programs/10-Linear-Structures/qarray.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/10-Linear-Structures/qarray.c' &&
/*
X * File: qarray.c
X * --------------
X * This file implements the queue.h abstraction using an array.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "queue.h"
X
/*
X * Constants:
X * ----------
X * MaxQueueSize   -- Maximum number of elements in the queue
X * QueueArraySize -- Size of the internal array
X */
X
#define MaxQueueSize   100
#define QueueArraySize (MaxQueueSize + 1)
X
/*
X * Type: queueCDT
X * --------------
X * This type defines the concrete representation of a queue.
X * This implementation uses a ring buffer to implement the
X * queue.  The next item to be dequeued is found at the array
X * element indexed by head.  The tail index indicates the next
X * free position.  When head and tail are equal, the queue is
X * empty.  The head and tail indices each move from the end of
X * the array back to the beginning, giving rise to the name
X * "ring buffer."  The functions use modular arithmetic to
X * implement this wrap-around behavior.
X */
X
struct queueCDT {
X    queueElementT elements[QueueArraySize];
X    int head;
X    int tail;
};
X
/* Exported entries */
X
queueADT NewQueue(void)
{
X    queueADT queue;
X
X    queue = New(queueADT);
X    queue->head = queue->tail = 0;
X    return (queue);
}
X
void FreeQueue(queueADT queue)
{
X    FreeBlock(queue);
}
X
void Enqueue(queueADT queue, queueElementT element)
{
X    if (QueueIsFull(queue)) Error("Enqueue: queue is full");
X    queue->elements[queue->tail] = element;
X    queue->tail = (queue->tail + 1) % QueueArraySize;
}
X
queueElementT Dequeue(queueADT queue)
{
X    queueElementT result;
X
X    if (QueueIsEmpty(queue)) Error("Dequeue: queue is empty");
X    result = queue->elements[queue->head];
X    queue->head = (queue->head + 1) % QueueArraySize;
X    return (result);
}
X
bool QueueIsEmpty(queueADT queue)
{
X    return (queue->head == queue->tail);
}
X
bool QueueIsFull(queueADT queue)
{
X    return ((queue->tail + 1) % QueueArraySize == queue->head);
}
X
/*
X * Implementation note: QueueLength
X * --------------------------------
X * This function determines the number of elements by computing
X * (tail - head) % size.  The size of the queue is added in at
X * the beginning to ensure that the left operand to % is always
X * positive.
X */
X
int QueueLength(queueADT queue)
{
X    return ((QueueArraySize + queue->tail - queue->head)
X              % QueueArraySize);
}
X
queueElementT GetQueueElement(queueADT queue, int index)
{
X    if (index < 0 || index >= QueueLength(queue)) {
X        Error("Queue element is out of range");
X    }
X    return (queue->elements[(queue->head + index)
X                             % QueueArraySize]);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/10-Linear-Structures/qarray.c' &&
  chmod 0644 'programs/10-Linear-Structures/qarray.c' ||
  echo 'restore of programs/10-Linear-Structures/qarray.c failed'
  shar_count="`wc -c < 'programs/10-Linear-Structures/qarray.c'`"
  test 2589 -eq "$shar_count" ||
    echo "programs/10-Linear-Structures/qarray.c: original size 2589, current size $shar_count"
fi
# ============= programs/10-Linear-Structures/qlist.c ==============
if test -f 'programs/10-Linear-Structures/qlist.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/10-Linear-Structures/qlist.c (file already exists)'
else
  echo 'x - extracting programs/10-Linear-Structures/qlist.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/10-Linear-Structures/qlist.c' &&
/*
X * File: qlist.c
X * -------------
X * This file implements the queue.h abstraction using a linked
X * list of cells.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "queue.h"
X
X
/*
X * Type: cellT
X * -----------
X * This type defines the cells used for the linked list that
X * stores the items in the queue.
X */
X
typedef struct cellT {
X    queueElementT value;
X    struct cellT *link;
} cellT;
X
/*
X * Type: queueCDT
X * --------------
X * This type defines the concrete representation of a queue.
X * In this representation, the queue is a linked list of cells.
X * The next item to be dequeued is found at the cell addressed
X * by the head field.  The tail field points to the last element
X * in the queue, which allows Enqueue to operate in constant time.
X * The empty queue is indicated by a NULL head pointer.
X */
X
struct queueCDT {
X    cellT *head;
X    cellT *tail;
};
X
/* Exported entries */
X
queueADT NewQueue(void)
{
X    queueADT queue;
X
X    queue = New(queueADT);
X    queue->head = NULL;
X    return (queue);
}
X
void FreeQueue(queueADT queue)
{
X    cellT *cp, *next;
X
X    cp = queue->head;
X    while (cp != NULL) {
X        next = cp->link;
X        FreeBlock(cp);
X        cp = next;
X    }
X    FreeBlock(queue);
}
X
void Enqueue(queueADT queue, queueElementT element)
{
X    cellT *cp;
X
X    cp = New(cellT *);
X    cp->value = element;
X    cp->link = NULL;
X    if (queue->head == NULL) {
X        queue->head = cp;
X    } else {
X        queue->tail->link = cp;
X    }
X    queue->tail = cp;
}
X
queueElementT Dequeue(queueADT queue)
{
X    queueElementT result;
X    cellT *cp;
X
X    cp = queue->head;
X    if (cp == NULL) {
X        Error("Dequeue: queue is empty");
X    }
X    result = cp->value;
X    queue->head = cp->link;
X    FreeBlock(cp);
X    return (result);
}
X
bool QueueIsEmpty(queueADT queue)
{
X    return (queue->head == NULL);
}
X
bool QueueIsFull(queueADT queue)
{
X    return (FALSE);
}
X
int QueueLength(queueADT queue)
{
X    int n;
X    cellT *cp;
X
X    n = 0;
X    for (cp = queue->head; cp != NULL; cp = cp->link) n++;
X    return (n);
}
X
queueElementT GetQueueElement(queueADT queue, int index)
{
X    int i;
X    cellT *cp;
X
X    if (index < 0 || index >= QueueLength(queue)) {
X        Error("Queue element is out of range");
X    }
X    cp = queue->head;
X    for (i = 0; i < index; i++) cp = cp->link;
X    return (cp->value);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/10-Linear-Structures/qlist.c' &&
  chmod 0644 'programs/10-Linear-Structures/qlist.c' ||
  echo 'restore of programs/10-Linear-Structures/qlist.c failed'
  shar_count="`wc -c < 'programs/10-Linear-Structures/qlist.c'`"
  test 2329 -eq "$shar_count" ||
    echo "programs/10-Linear-Structures/qlist.c: original size 2329, current size $shar_count"
fi
# ============= programs/10-Linear-Structures/qtest.c ==============
if test -f 'programs/10-Linear-Structures/qtest.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/10-Linear-Structures/qtest.c (file already exists)'
else
  echo 'x - extracting programs/10-Linear-Structures/qtest.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/10-Linear-Structures/qtest.c' &&
/*
X * File: qtest.c
X * -------------
X * This program tests the queue package by allowing the user to
X * keep track of a waiting list.  The commands are listed in the
X * function GiveInstructions.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "simpio.h"
#include "strlib.h"
#include "scanadt.h"
#include "queue.h"
X
/* Private function prototypes */
X
static void GiveInstructions(void);
static void DisplayQueue(queueADT queue);
X
/* Main program */
X
main()
{
X    queueADT queue;
X    scannerADT scanner;
X    string line, cmd, value;
X
X    GiveInstructions();
X    scanner = NewScanner();
X    SetScannerSpaceOption(scanner, IgnoreSpaces);
X    queue = NewQueue();
X    while (TRUE) {
X        printf(":");
X        line = GetLine();
X        SetScannerString(scanner, line);
X        cmd = ConvertToLowerCase(ReadToken(scanner));
X        if (StringEqual(cmd, "enqueue")) {
X            value = ReadToken(scanner);
X            Enqueue(queue, value);
X        } else if (StringEqual(cmd, "dequeue")) {
X            printf("%s\n", Dequeue(queue));
X        } else if (StringEqual(cmd, "display")) {
X            DisplayQueue(queue);
X        } else if (StringEqual(cmd, "quit")) {
X            break;
X        } else {
X            printf("Unrecognized command: %s\n", line);
X        }
X    }
X    FreeQueue(queue);
X    FreeScanner(scanner);
}
X
/*
X * Function: GiveInstructions
X * Usage: GiveInstructions();
X * --------------------------
X * This function displays a message to the user showing
X * what options are available in the test program.
X */
X
static void GiveInstructions(void)
{
X    printf("Enter commands in the following forms:\n");
X    printf("  enqueue x   -- Enqueue the token x\n");
X    printf("  dequeue     -- Dequeue the value at the head of the queue\n");
X    printf("  display     -- Display the contents of the queue\n");
X    printf("  quit        -- Exit from the program\n");
}
X
/*
X * Function: DisplayQueue
X * Usage: DisplayQueue(queue);
X * ---------------------------
X * This function displays the contents of a string queue on
X * a single line.
X */
X
static void DisplayQueue(queueADT queue)
{
X    int i, len;
X
X    len = QueueLength(queue);
X    if (len == 0) {
X        printf("Queue is empty.");
X    } else {
X        printf("Queue contains: ");
X        for (i = 0; i < len; i++) {
X            if (i > 0) printf(", ");
X            printf("%s", GetQueueElement(queue, i));
X        }
X    }
X    printf("\n");
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/10-Linear-Structures/qtest.c' &&
  chmod 0644 'programs/10-Linear-Structures/qtest.c' ||
  echo 'restore of programs/10-Linear-Structures/qtest.c failed'
  shar_count="`wc -c < 'programs/10-Linear-Structures/qtest.c'`"
  test 2412 -eq "$shar_count" ||
    echo "programs/10-Linear-Structures/qtest.c: original size 2412, current size $shar_count"
fi
# ============= programs/10-Linear-Structures/queue.h ==============
if test -f 'programs/10-Linear-Structures/queue.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/10-Linear-Structures/queue.h (file already exists)'
else
  echo 'x - extracting programs/10-Linear-Structures/queue.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/10-Linear-Structures/queue.h' &&
/*
X * File: queue.h
X * -------------
X * This interface defines an abstraction for queues.  In any
X * single application that uses this interface, the values in
X * the queue are constrained to a single type, although it
X * is easy to change that type by changing the definition of
X * queueElementT in this interface.
X */
X
#ifndef _queue_h
#define _queue_h
X
#include "genlib.h"
X
/*
X * Type: queueElementT
X * -------------------
X * The type queueElementT is used in this interface to indicate
X * the type of values that can be stored in the queue.  Here the
X * queue is used to store values of type void *, but that can
X * be changed by editing this definition line.
X */
X
typedef void *queueElementT;
X
/*
X * Type: queueADT
X * --------------
X * The queueADT type is defined as a pointer to its concrete
X * counterpart, which is available only to the implementation,
X * not to clients.
X */
X
typedef struct queueCDT *queueADT;
X
/*
X * Function: NewQueue
X * Usage: queue = NewQueue();
X * --------------------------
X * This function allocates and returns an empty queue.
X */
X
queueADT NewQueue(void);
X
/*
X * Function: FreeQueue
X * Usage: FreeQueue(queue);
X * ------------------------
X * This function frees the storage associated with queue.
X */
X
void FreeQueue(queueADT queue);
X
/*
X * Function: Enqueue
X * Usage: Enqueue(queue, element);
X * -------------------------------
X * This function adds element to the end of the queue.
X */
X
void Enqueue(queueADT queue, queueElementT element);
X
/*
X * Function: Dequeue
X * Usage: element = Dequeue(queue);
X * --------------------------------
X * This function removes the data value at the head of the queue
X * and returns it to the client.  If the queue is empty, Dequeue
X * calls Error with an appropriate message.
X */
X
queueElementT Dequeue(queueADT queue);
X
/*
X * Functions: QueueIsEmpty, QueueIsFull
X * Usage: if (QueueIsEmpty(queue)) . . .
X *        if (QueueIsFull(queue)) . . .
X * -------------------------------------
X * These functions test whether the queue is empty or full.
X */
X
bool QueueIsEmpty(queueADT queue);
bool QueueIsFull(queueADT queue);
X
/*
X * Function: QueueLength
X * Usage: n = QueueLength(queue);
X * ------------------------------
X * This function returns the number of elements in the queue.
X */
X
int QueueLength(queueADT queue);
X
/*
X * Function: GetQueueElement
X * Usage: element = GetQueueElement(queue, index);
X * -----------------------------------------------
X * This function returns the element at the specified index in the
X * queue, where the head of the queue is defined as index 0. For
X * example, calling GetQueueElement(queue, 0) returns the initial
X * element from the queue without removing it.  If the caller tries
X * to select an element that is out of range, GetQueueElement calls
X * Error.  Note: This function is not a fundamental queue operation
X * and is instead provided mainly to facilitate debugging.
X */
X
queueElementT GetQueueElement(queueADT queue, int index);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/10-Linear-Structures/queue.h' &&
  chmod 0644 'programs/10-Linear-Structures/queue.h' ||
  echo 'restore of programs/10-Linear-Structures/queue.h failed'
  shar_count="`wc -c < 'programs/10-Linear-Structures/queue.h'`"
  test 2957 -eq "$shar_count" ||
    echo "programs/10-Linear-Structures/queue.h: original size 2957, current size $shar_count"
fi
# ============= programs/10-Linear-Structures/rpncalc.c ==============
if test -f 'programs/10-Linear-Structures/rpncalc.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/10-Linear-Structures/rpncalc.c (file already exists)'
else
  echo 'x - extracting programs/10-Linear-Structures/rpncalc.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/10-Linear-Structures/rpncalc.c' &&
/*
X * File: rpncalc.c
X * ---------------
X * This program simulates an electronic calculator that uses
X * reverse Polish notation, in which the operators come after
X * the operands to which they apply.
X */
X
#include <stdio.h>
#include <ctype.h>
#include "genlib.h"
#include "simpio.h"
#include "strlib.h"
#include "stack.h"
X
/* Private function prototypes */
X
static void ApplyOperator(char op, stackADT operandStack);
static void HelpCommand(void);
static void ClearStack(stackADT operandStack);
static void DisplayStack(stackADT operandStack);
X
/* Main program */
X
main()
{
X    stackADT operandStack;
X    string line;
X    char ch;
X
X    printf("RPN Calculator Simulation (type H for help)\n");
X    operandStack = NewStack();
X    while (TRUE) {
X        printf("> ");
X        line = GetLine();
X        ch = toupper(line[0]);
X        if (ch == 'Q') {
X            break;
X        } else if (ch == 'C') {
X            ClearStack(operandStack);
X        } else if (ch == 'H') {
X            HelpCommand();
X        } else if (ch == 'S') {
X            DisplayStack(operandStack);
X        } else if (isdigit(ch)) {
X            Push(operandStack, StringToReal(line));
X        } else {
X            ApplyOperator(ch, operandStack);
X        }
X    }
}
X
/* Private functions */
X
/*
X * Function: ApplyOperator
X * Usage: ApplyOperator(op, operandStack);
X * ---------------------------------------
X * This function applies the operator to the top two elements on
X * the operand stack.  Because the elements on the stack are
X * popped in reverse order, the right operand is popped before
X * the left operand.
X */
X
static void ApplyOperator(char op, stackADT operandStack)
{
X    double lhs, rhs, result;
X
X    rhs = Pop(operandStack);
X    lhs = Pop(operandStack);
X    switch (op) {
X      case '+': result = lhs + rhs; break;
X      case '-': result = lhs - rhs; break;
X      case '*': result = lhs * rhs; break;
X      case '/': result = lhs / rhs; break;
X      default:  Error("Illegal operator %c", op);
X    }
X    printf("%g\n", result);
X    Push(operandStack, result);
}
X
/*
X * Function: HelpCommand
X * Usage: HelpCommand();
X * ---------------------
X * This function generates a help message for the user.
X */
X
static void HelpCommand(void)
{
X    printf("Enter expressions in Reverse Polish Notation,\n");
X    printf("in which operators follow the operands to which\n");
X    printf("they apply.  Each line consists of a number, an\n");
X    printf("operator, or one of the following commands:\n");
X    printf("  Q -- Quit the program\n");
X    printf("  H -- Display this help message\n");
X    printf("  C -- Clear the calculator stack\n");
X    printf("  S -- Display all values in the stack\n");
}
X
/*
X * Function: ClearStack
X * Usage: ClearStack(stack);
X * -------------------------
X * This function clears the stack by popping elements until it is
X * empty.
X */
X
static void ClearStack(stackADT stack)
{
X    while (!StackIsEmpty(stack)) {
X        (void) Pop(stack);
X    }
}
X
/*
X * Function: DisplayStack
X * Usage: DisplayStack(stack);
X * ---------------------------
X * This function displays the contents of a stack.
X */
X
static void DisplayStack(stackADT stack)
{
X    int i, depth;
X
X    printf("Stack: ");
X    depth = StackDepth(stack);
X    if (depth == 0) {
X        printf("empty\n");
X    } else {
X        for (i = depth - 1; i >= 0; i--) {
X            if (i < depth - 1) printf(", ");
X            printf("%g", GetStackElement(stack, i));
X        }
X        printf("\n");
X    }
}
X
X
X
SHAR_EOF
  $shar_touch -am 0903182097 'programs/10-Linear-Structures/rpncalc.c' &&
  chmod 0644 'programs/10-Linear-Structures/rpncalc.c' ||
  echo 'restore of programs/10-Linear-Structures/rpncalc.c failed'
  shar_count="`wc -c < 'programs/10-Linear-Structures/rpncalc.c'`"
  test 3461 -eq "$shar_count" ||
    echo "programs/10-Linear-Structures/rpncalc.c: original size 3461, current size $shar_count"
fi
# ============= programs/10-Linear-Structures/scanadt.c ==============
if test -f 'programs/10-Linear-Structures/scanadt.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/10-Linear-Structures/scanadt.c (file already exists)'
else
  echo 'x - extracting programs/10-Linear-Structures/scanadt.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/10-Linear-Structures/scanadt.c' &&
/*
X * File: scanadt.c
X * ---------------
X * This file implements the scanadt.h interface.
X */
X
#include <stdio.h>
#include <ctype.h>
#include "genlib.h"
#include "strlib.h"
#include "scanadt.h"
X
/*
X * Type: scannerCDT
X * ----------------
X * This structure is the concrete representation of the type
X * scannerADT, which is exported by this interface.  Its purpose
X * is to maintain the state of the scanner between calls.  The
X * details of the representation are invisible to the client,
X * but consist of the following fields:
X *
X * str          -- Copy of string passed to SetScannerString
X * len          -- Length of string, saved for efficiency
X * cp           -- Current character position in the string
X * savedToken   -- String saved by SaveToken (NULL indicates none)
X * spaceOption  -- Setting of the space option extension
X * numberOption -- Setting of the number option extension
X * stringOption -- Setting of string option extension
X */
X
struct scannerCDT {
X    string str;
X    int len;
X    int cp;
X    string savedToken;
X    spaceOptionT spaceOption;
X    numberOptionT numberOption;
X    stringOptionT stringOption;
};
X
/* Private function prototypes */
X
static void SkipSpaces(scannerADT scanner);
static int ScanToEndOfIdentifier(scannerADT scanner);
static int ScanToEndOfInteger(scannerADT scanner);
static int ScanToEndOfReal(scannerADT scanner);
static string ScanQuotedString(scannerADT scanner);
static char ScanEscapeCharacter(scannerADT scanner);
X
/* Exported entries */
X
scannerADT NewScanner(void)
{
X    scannerADT scanner;
X
X    scanner = New(scannerADT);
X    scanner->str = NULL;
X    scanner->spaceOption = PreserveSpaces;
X    scanner->numberOption = ScanNumbersAsLetters;
X    scanner->stringOption = ScanQuotesAsPunctuation;
X    return (scanner);
}
X
void FreeScanner(scannerADT scanner)
{
X    if (scanner->str != NULL) FreeBlock(scanner->str);
X    FreeBlock(scanner);
}
X
void SetScannerString(scannerADT scanner, string str)
{
X    if (scanner->str != NULL) FreeBlock(scanner->str);
X    scanner->str = CopyString(str);
X    scanner->len = StringLength(str);
X    scanner->cp = 0;
X    scanner->savedToken = NULL;
}
X
string ReadToken(scannerADT scanner)
{
X    char ch;
X    string token;
X    int start, finish;
X
X    if (scanner->str == NULL) {
X        Error("SetScannerString has not been called");
X    }
X    if (scanner->savedToken != NULL) {
X        token = scanner->savedToken;
X        scanner->savedToken = NULL;
X        return (token);
X    }
X    if (scanner->spaceOption == IgnoreSpaces) SkipSpaces(scanner);
X    start = finish = scanner->cp;
X    if (start >= scanner->len) return (CopyString(""));
X    ch = scanner->str[scanner->cp];
X    if (scanner->stringOption == ScanQuotesAsStrings
X            && ch == '"') {
X        return (ScanQuotedString(scanner));
X    }
X    if (isdigit(ch)) {
X        switch (scanner->numberOption) {
X          case ScanNumbersAsLetters:
X            finish = ScanToEndOfIdentifier(scanner);
X            break;
X          case ScanNumbersAsIntegers:
X            finish = ScanToEndOfInteger(scanner);
X            break;
X          case ScanNumbersAsReals:
X            finish = ScanToEndOfReal(scanner);
X            break;
X        }
X    } else if (isalnum(ch)) {
X        finish = ScanToEndOfIdentifier(scanner);
X    } else {
X        scanner->cp++;
X    }
X    return (SubString(scanner->str, start, finish));
}
X
bool MoreTokensExist(scannerADT scanner)
{
X    if (scanner->str == NULL) {
X        Error("SetScannerString has not been called");
X    }
X    if (scanner->savedToken != NULL) {
X        return (!StringEqual(scanner->savedToken, ""));
X    }
X    if (scanner->spaceOption == IgnoreSpaces) SkipSpaces(scanner);
X    return (scanner->cp < scanner->len);
}
X
void SaveToken(scannerADT scanner, string token)
{
X    if (scanner->str == NULL) {
X        Error("SetScannerString has not been called");
X    }
X    if (scanner->savedToken != NULL) {
X        Error("Token has already been saved");
X    }
X    scanner->savedToken = token;
}
X
void SetScannerSpaceOption(scannerADT scanner, spaceOptionT option)
{
X    scanner->spaceOption = option;
}
X
spaceOptionT GetScannerSpaceOption(scannerADT scanner)
{
X    return (scanner->spaceOption);
}
X
void SetScannerNumberOption(scannerADT scanner, numberOptionT option)
{
X    scanner->numberOption = option;
}
X
numberOptionT GetScannerNumberOption(scannerADT scanner)
{
X    return (scanner->numberOption);
}
X
void SetScannerStringOption(scannerADT scanner, stringOptionT option)
{
X    scanner->stringOption = option;
}
X
stringOptionT GetScannerStringOption(scannerADT scanner)
{
X    return (scanner->stringOption);
}
X
/* Private functions */
X
/*
X * Function: SkipSpaces
X * Usage: SkipSpaces(scanner);
X * ---------------------------
X * This function advances the position of the scanner until the
X * current character is not a whitespace character.
X */
X
static void SkipSpaces(scannerADT scanner)
{
X    while (isspace(scanner->str[scanner->cp])) {
X        scanner->cp++;
X    }
}
X
/*
X * Function: ScanToEndOfIdentifier
X * Usage: finish = ScanToEndOfIdentifier(scanner);
X * -----------------------------------------------
X * This function advances the position of the scanner until it
X * reaches the end of a sequence of letters or digits that make
X * up an identifier.  The return value is the index of the last
X * character in the identifier; the value of the stored index
X * cp is the first character after that.
X */
X
static int ScanToEndOfIdentifier(scannerADT scanner)
{
X    while (isalnum(scanner->str[scanner->cp])) {
X        scanner->cp++;
X    }
X    return (scanner->cp - 1);
}
X
/*
X * Function: ScanToEndOfInteger
X * Usage: finish = ScanToEndOfInteger(scanner);
X * --------------------------------------------
X * This function advances the position of the scanner until it
X * reaches the end of a sequence of digits.  The return value is
X * the index of the last character in the integer; the value
X * of the stored index cp is the first character after that.
X */
X
static int ScanToEndOfInteger(scannerADT scanner)
{
X    while (isdigit(scanner->str[scanner->cp])) {
X        scanner->cp++;
X    }
X    return (scanner->cp - 1);
}
X
/*
X * Function: ScanToEndOfReal
X * Usage: finish = ScanToEndOfReal(scanner);
X * -----------------------------------------
X * This function advances the position of the scanner until it
X * reaches the end of a legal number.  The return value is the
X * index of the last character in the identifier; the value
X * of the stored index cp is the first character after that.
X *
X * The function operates by simulating what computer scientists
X * call a finite-state machine.  The program uses the variable
X * state to record the history of the process and determine
X * what characters would be legal at this point in time.
X */
X
#define InitialState        0
#define BeforeDecimalPoint  1
#define AfterDecimalPoint   2
#define StartingExponent    3
#define FoundExponentSign   4
#define ScanningExponent    5
#define FinalState         -1
X
static int ScanToEndOfReal(scannerADT scanner)
{
X    int state;
X    char ch;
X
X    state = InitialState;
X    while (state != FinalState) {
X        ch = scanner->str[scanner->cp];
X        switch (state) {
X          case InitialState:
X            if (!isdigit(ch)) Error("ScanToEndOfReal called on nonnumber");
X             state = BeforeDecimalPoint;
X            break;
X          case BeforeDecimalPoint:
X            if (ch == '.') {
X                state = AfterDecimalPoint;
X            } else if (ch == 'E' || ch == 'e') {
X                state = StartingExponent;
X            } else if (!isdigit(ch)) {
X                state = FinalState;
X            }
X            break;
X          case AfterDecimalPoint:
X            if (ch == 'E' || ch == 'e') {
X                state = StartingExponent;
X            } else if (!isdigit(ch)) {
X                state = FinalState;
X            }
X            break;
X          case StartingExponent:
X            if (ch == '+' || ch == '-') {
X                state = FoundExponentSign;
X            } else if (isdigit(ch)) {
X                state = ScanningExponent;
X            } else {
X                scanner->cp--;
X                state = FinalState;
X            }
X            break;
X          case FoundExponentSign:
X            if (isdigit(ch)) {
X                state = ScanningExponent;
X            } else {
X                scanner->cp -= 2;
X                state = FinalState;
X            }
X            break;
X          case ScanningExponent:
X            if (!isdigit(ch)) {
X                state = FinalState;
X            }
X            break;
X        }
X        if (state != FinalState) scanner->cp++;
X    }
X    return (scanner->cp - 1);
}
X
/*
X * Function: ScanQuotedString
X * Usage: str = ScanQuotedString(scanner);
X * ---------------------------------------
X * This function reads and returns a quoted string from the
X * scanner.  The current position of the scanner must be the
X * opening quotation mark.  At the end, the current position
X * marker will be set to the character position after the
X * closing quote.  The scanner generates an error if there
X * is no closing quotation mark before the end of the string.
X */
X
static string ScanQuotedString(scannerADT scanner)
{
X    string token;
X    char ch;
X
X    token = "\"";
X    scanner->cp++;
X    while ((ch = scanner->str[scanner->cp++]) != '"') {
X        if (ch == '\0') Error("Unterminated string");
X        if (ch == '\\') ch = ScanEscapeCharacter(scanner);
X        token = Concat(token, CharToString(ch));
X    }
X    return (Concat(token, "\""));
}
X
/*
X * Function: ScanEscapeCharacter
X * Usage: ch = ScanEscapeCharacter(scanner);
X * -----------------------------------------
X * This function is used by ScanQuotedString to read an escape
X * character sequence from the scanner string.  The opening
X * backslash character has already been read.  Most of the
X * complexity comes in reading the '\ddd' and '\xdd' forms.
X */
X
static char ScanEscapeCharacter(scannerADT scanner)
{
X    char ch, result;
X    int digit, base;
X
X    ch = scanner->str[scanner->cp];
X    if (isdigit(ch) || ch == 'x') {
X        base = 8;
X        if (ch == 'x') {
X            base = 16;
X            scanner->cp++;
X        }
X        result = 0;
X        while (TRUE) {
X            ch = scanner->str[scanner->cp];
X            if (isdigit(ch)) {
X                digit = ch - '0';
X            } else if (isalpha(ch)) {
X                digit = toupper(ch) - 'A' + 10;
X            } else {
X                digit = base;
X            }
X            if (digit >= base) break;
X            result = base * result + digit;
X            scanner->cp++;
X        }
X        return (result);
X    }
X    scanner->cp++;
X    switch (ch) {
X      case 'a':  return ('\a');
X      case 'b':  return ('\b');
X      case 'f':  return ('\f');
X      case 'n':  return ('\n');
X      case 'r':  return ('\r');
X      case 't':  return ('\t');
X      case 'v':  return ('\v');
X      case '\\': return ('\\');
X      case '"':  return ('"');
X    }
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/10-Linear-Structures/scanadt.c' &&
  chmod 0644 'programs/10-Linear-Structures/scanadt.c' ||
  echo 'restore of programs/10-Linear-Structures/scanadt.c failed'
  shar_count="`wc -c < 'programs/10-Linear-Structures/scanadt.c'`"
  test 10928 -eq "$shar_count" ||
    echo "programs/10-Linear-Structures/scanadt.c: original size 10928, current size $shar_count"
fi
# ============= programs/10-Linear-Structures/scanadt.h ==============
if test -f 'programs/10-Linear-Structures/scanadt.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/10-Linear-Structures/scanadt.h (file already exists)'
else
  echo 'x - extracting programs/10-Linear-Structures/scanadt.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/10-Linear-Structures/scanadt.h' &&
/*
X * File: scanadt.h
X * ---------------
X * This file is the interface to a module that exports an abstract
X * data type to facilitate dividing a string into logical units
X * called "tokens," which are either
X *
X * 1. Strings of consecutive letters and digits representing words
X * 2. One-character strings representing punctuation or separators
X *
X * To use this package, you must first create an instance of a
X * scannerADT by calling
X *
X *      scanner = NewScanner();
X *
X * All other calls to the scanner package take this variable as their
X * first argument to identify a particular instance of the abstract
X * scanner type.
X *
X * You initialize the scanner to hold a particular string by calling
X *
X *      SetScannerString(scanner, str);
X *
X * where str is the string from which tokens should be read.  To
X * retrieve each individual token, you make the following call:
X *
X *      token = ReadToken(scanner);
X *
X * To determine whether any tokens remain to be read, you can call
X * the predicate function MoreTokensExist(scanner).  The ReadToken
X * function returns the empty string after the last token is read.
X *
X * The following code fragment serves as an idiom for processing
X * each token in the string inputString:
X *
X *      scanner = NewScanner();
X *      SetScannerString(scanner, inputString);
X *      while (MoreTokensExist(scanner)) {
X *          token = ReadToken(scanner);
X *          . . . process the token . . .
X *      }
X *
X * This version of scanadt.h also supports the following extensions,
X * which are documented later in the interface:
X *
X *   SaveToken
X *   SetScannerSpaceOption
X *   SetScannerStringOption
X *   SetScannerNumberOption
X */
X
#ifndef _scanadt_h
#define _scanadt_h
X
#include "genlib.h"
X
/*
X * Type: scannerADT
X * ----------------
X * This type is the abstract type used to represent a single instance
X * of a scanner.  As with any abstract type, the details of the
X * internal representation are hidden from the client.
X */
X
typedef struct scannerCDT *scannerADT;
X
/*
X * Function: NewScanner
X * Usage: scanner = NewScanner();
X * ------------------------------
X * This function creates a new scanner instance.  All other functions
X * in this interface take this scanner value as their first argument
X * so that they can identify what particular instance of the scanner
X * is in use.  This design makes it possible for clients to have more
X * than one scanner process active at the same time.
X */
X
scannerADT NewScanner(void);
X
/*
X * Function: FreeScanner
X * Usage: FreeScanner(scanner);
X * ----------------------------
X * This function frees the storage associated with scanner.
X */
X
void FreeScanner(scannerADT scanner);
X
/*
X * Function: SetScannerString
X * Usage: SetScannerString(scanner, str);
X * --------------------------------------
X * This function initializes the scanner so that it will start
X * extracting tokens from the string str.
X */
X
void SetScannerString(scannerADT scanner, string str);
X
/*
X * Function: ReadToken
X * Usage: token = ReadToken(scanner);
X * ----------------------------------
X * This function returns the next token from scanner.  If
X * ReadToken is called when no tokens are available, it returns
X * the empty string.  The token returned by ReadToken is always
X * allocated in the heap, which means that clients can call
X * FreeBlock when the token is no longer needed.
X */
X
string ReadToken(scannerADT scanner);
X
/*
X * Function: MoreTokensExist
X * Usage: if (MoreTokensExist(scanner)) . . .
X * ------------------------------------------
X * This function returns TRUE as long as there are additional
X * tokens for the scanner to read.
X */
X
bool MoreTokensExist(scannerADT scanner);
X
/*
X * Function: SaveToken
X * Usage: SaveToken(scanner, token);
X * ---------------------------------
X * This function stores the token in the scanner data structure
X * in such a way that the next time ReadToken is called, it will
X * return that token without reading any additional characters
X * from the input.
X */
X
void SaveToken(scannerADT scanner, string token);
X
/*
X * Functions: SetScannerSpaceOption, GetScannerSpaceOption
X * Usage: SetScannerSpaceOption(scanner, option);
X *        option = GetScannerSpaceOption(scanner);
X * -----------------------------------------------
X * The SetScannerSpaceOption function controls whether the scanner
X * ignores whitespace characters or treats them as valid tokens.
X * By default, the ReadToken function treats whitespace characters,
X * such as spaces and tabs, just like any other punctuation mark.
X * If, however, you call
X *
X *    SetScannerSpaceOption(scanner, IgnoreSpaces);
X *
X * the scanner will skip over any white space before reading a token.
X * You can restore the original behavior by calling
X *
X *    SetScannerSpaceOption(scanner, PreserveSpaces);
X *
X * The GetScannerSpaceOption function returns the current setting
X * of this option.
X */
X
typedef enum { PreserveSpaces, IgnoreSpaces } spaceOptionT;
X
void SetScannerSpaceOption(scannerADT scanner, spaceOptionT option);
spaceOptionT GetScannerSpaceOption(scannerADT scanner);
X
/*
X * Functions: SetScannerNumberOption, GetScannerNumberOption
X * Usage: SetScannerNumberOption(scanner, option);
X *        option = GetScannerNumberOption(scanner);
X * ------------------------------------------------
X * This function controls whether the scanner treats numeric values
X * specially.  The default behavior for the scanner is to treat
X * digits as equivalent to letters.  If you call
X *
X *    SetScannerNumberOption(scanner, ScanNumbersAsIntegers);
X *
X * a token beginning with a digit will end at the first nondigit.
X * (Note that digits can still be scanned as part of a token as in
X * the token "x1".)  If you call
X *
X *    SetScannerNumberOption(scanner, ScanNumbersAsReals);
X *
X * the scanner will return the longest token string that represents
X * a real number, if the next character to be scanned is a digit.
X * The format for a real number is a sequence of digit characters
X * that may include at most one decimal point, optionally followed
X * by the letter 'E' in either upper- or lowercase, an optional sign,
X * and an exponent.  You can restore the default behavior by calling
X *
X *    SetScannerNumberOption(scanner, ScanNumbersAsLetters);
X *
X * Even if the number options are enabled, ReadToken always returns
X * its result as a string, which means that you need to call
X * StringToInteger or StringToReal to convert the token to a number.
X */
X
typedef enum {
X    ScanNumbersAsLetters,
X    ScanNumbersAsIntegers,
X    ScanNumbersAsReals
} numberOptionT;
X
void SetScannerNumberOption(scannerADT scanner, numberOptionT option);
numberOptionT GetScannerNumberOption(scannerADT scanner);
X
/*
X * Functions: SetScannerStringOption, GetScannerStringOption
X * Usage: SetScannerStringOption(scanner, option);
X *        option = GetScannerStringOption(scanner);
X * ------------------------------------------------
X * This function controls how the scanner treats double quotation
X * marks in the input.  The default behavior for the scanner is
X * to treat quotes just like any other punctuation character.
X * If, however, you call
X *
X *    SetScannerStringOption(scanner, ScanQuotesAsStrings);
X *
X * a token beginning with a quotation mark will be scanned up to
X * the closing quotation mark.  The quotation marks are returned
X * as part of the scanned token so that clients can differentiate
X * strings from other token types.  The original behavior can be
X * restored by calling
X *
X *    SetScannerStringOption(scanner, ScanQuotesAsPunctuation);
X *
X * When scanning a string, the scanner recognizes the standard
X * escape sequences from ANSI C, such as \n and \t.
X */
X
typedef enum {
X    ScanQuotesAsPunctuation,
X    ScanQuotesAsStrings
} stringOptionT;
X
void SetScannerStringOption(scannerADT scanner, stringOptionT option);
stringOptionT GetScannerStringOption(scannerADT scanner);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/10-Linear-Structures/scanadt.h' &&
  chmod 0644 'programs/10-Linear-Structures/scanadt.h' ||
  echo 'restore of programs/10-Linear-Structures/scanadt.h failed'
  shar_count="`wc -c < 'programs/10-Linear-Structures/scanadt.h'`"
  test 7862 -eq "$shar_count" ||
    echo "programs/10-Linear-Structures/scanadt.h: original size 7862, current size $shar_count"
fi
# ============= programs/10-Linear-Structures/stack.c ==============
if test -f 'programs/10-Linear-Structures/stack.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/10-Linear-Structures/stack.c (file already exists)'
else
  echo 'x - extracting programs/10-Linear-Structures/stack.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/10-Linear-Structures/stack.c' &&
/*
X * File: stack.c
X * -------------
X * This file implements the stack.h interface using linked lists.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "stack.h"
X
/*
X * Type: cellT
X * -----------
X * This type defines the linked list cell used for the stack.
X */
X
typedef struct cellT {
X    stackElementT element;
X    struct cellT *link;
} cellT;
X
/*
X * Type: stackCDT
X * --------------
X * This type defines the concrete structure of a stack.
X */
X
struct stackCDT {
X    cellT *start;
};
X
/* Exported entries */
X
stackADT NewStack(void)
{
X    stackADT stack;
X
X    stack = New(stackADT);
X    stack->start = NULL;
X    return (stack);
}
X
void FreeStack(stackADT stack)
{
X    cellT *cp, *next;
X
X    cp = stack->start;
X    while (cp != NULL) {
X        next = cp->link;
X        FreeBlock(cp);
X        cp = next;
X    }
X    FreeBlock(stack);
}
X
void Push(stackADT stack, stackElementT element)
{
X    cellT *cp;
X
X    cp = New(cellT *);
X    cp->element = element;
X    cp->link = stack->start;
X    stack->start = cp;
}
X
stackElementT Pop(stackADT stack)
{
X    stackElementT result;
X    cellT *cp;
X
X    if (StackIsEmpty(stack)) Error("Pop of an empty stack");
X    cp = stack->start;
X    result = cp->element;
X    stack->start = cp->link;
X    FreeBlock(cp);
X    return (result);
}
X
bool StackIsEmpty(stackADT stack)
{
X    return (stack->start == NULL);
}
X
bool StackIsFull(stackADT stack)
{
X    return (FALSE);
}
X
int StackDepth(stackADT stack)
{
X    int n;
X    cellT *cp;
X
X    n = 0;
X    for (cp = stack->start; cp != NULL; cp = cp->link) n++;
X    return (n);
}
X
stackElementT GetStackElement(stackADT stack, int depth)
{
X    int i;
X    cellT *cp;
X
X    if (depth < 0 || depth >= StackDepth(stack)) {
X        Error("Non-existent stack element");
X    }
X    cp = stack->start;
X    for (i = 0; i < depth; i++) cp = cp->link;
X    return (cp->element);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/10-Linear-Structures/stack.c' &&
  chmod 0644 'programs/10-Linear-Structures/stack.c' ||
  echo 'restore of programs/10-Linear-Structures/stack.c failed'
  shar_count="`wc -c < 'programs/10-Linear-Structures/stack.c'`"
  test 1839 -eq "$shar_count" ||
    echo "programs/10-Linear-Structures/stack.c: original size 1839, current size $shar_count"
fi
# ============= programs/10-Linear-Structures/stack.h ==============
if test -f 'programs/10-Linear-Structures/stack.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/10-Linear-Structures/stack.h (file already exists)'
else
  echo 'x - extracting programs/10-Linear-Structures/stack.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/10-Linear-Structures/stack.h' &&
/*
X * File: stack.h
X * -------------
X * This interface defines an abstraction for stacks.  In any
X * single application that uses this interface, the values in
X * the stack are constrained to a single type, although it
X * is easy to change that type by changing the definition of
X * stackElementT in this interface.
X */
X
#ifndef _stack_h
#define _stack_h
X
#include "genlib.h"
X
/*
X * Type: stackElementT
X * -------------------
X * The type stackElementT is used in this interface to indicate
X * the type of values that can be stored in the stack.  Here the
X * stack is used to store values of type double, but that can
X * be changed by editing this definition line.
X */
X
typedef double stackElementT;
X
/*
X * Type: stackADT
X * --------------
X * The type stackADT represents the abstract type used to store
X * the elements that have been pushed.  Because stackADT is
X * defined only as a pointer to a concrete structure that is not
X * itself defined in the interface, clients have no access to
X * the underlying fields.
X */
X
typedef struct stackCDT *stackADT;
X
/*
X * Function: NewStack
X * Usage: stack = NewStack();
X * --------------------------
X * This function allocates and returns a new stack, which is
X * initially empty.
X */
X
stackADT NewStack(void);
X
/*
X * Function: FreeStack
X * Usage: FreeStack(stack);
X * ------------------------
X * This function frees the storage associated with the stack.
X */
X
void FreeStack(stackADT stack);
X
/*
X * Function: Push
X * Usage: Push(stack, element);
X * ----------------------------
X * This function pushes the specified element onto the stack.
X */
X
void Push(stackADT stack, stackElementT element);
X
/*
X * Function: Pop
X * Usage: element = Pop(stack);
X * ----------------------------
X * This function pops the top element from the stack and returns
X * that value.  The first value popped is always the last one
X * that was pushed.  If the stack is empty when Pop is called,
X * the function calls Error with an appropriate message.
X */
X
stackElementT Pop(stackADT stack);
X
/*
X * Functions: StackIsEmpty, StackIsFull
X * Usage: if (StackIsEmpty(stack)) . . .
X *        if (StackIsFull(stack)) . . .
X * -------------------------------------
X * This functions test whether the stack is empty or full.
X */
X
bool StackIsEmpty(stackADT stack);
bool StackIsFull(stackADT stack);
X
/*
X * Function: StackDepth
X * Usage: depth = StackDepth(stack);
X * ---------------------------------
X * This function returns the number of elements currently pushed
X * on the stack.
X */
X
int StackDepth(stackADT stack);
X
/*
X * Function: GetStackElement
X * Usage: element = GetStackElement(stack, index);
X * -----------------------------------------------
X * This function returns the element at the specified index in
X * the stack, where the top of the stack is defined as index 0.
X * For example, calling GetStackElement(stack, 0) returns the top
X * element on the stack without removing it.  If the caller tries
X * to select an out-of-range element, GetStackElement calls Error.
X * Note: This function is not a fundamental stack operation and
X * is instead provided principally to facilitate debugging.
X */
X
stackElementT GetStackElement(stackADT stack, int index);
X
#endif
SHAR_EOF
  $shar_touch -am 0905210297 'programs/10-Linear-Structures/stack.h' &&
  chmod 0644 'programs/10-Linear-Structures/stack.h' ||
  echo 'restore of programs/10-Linear-Structures/stack.h failed'
  shar_count="`wc -c < 'programs/10-Linear-Structures/stack.h'`"
  test 3186 -eq "$shar_count" ||
    echo "programs/10-Linear-Structures/stack.h: original size 3186, current size $shar_count"
fi
# ============= programs/10-Linear-Structures/Makefile ==============
if test -f 'programs/10-Linear-Structures/Makefile' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/10-Linear-Structures/Makefile (file already exists)'
else
  echo 'x - extracting programs/10-Linear-Structures/Makefile (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/10-Linear-Structures/Makefile' &&
# Makefile for programs in directory 10-Linear-Structures
# ***************************************************************
X
PROGRAMS = \
X    checkout \
X    array-qtest \
X    list-qtest \
X    rpncalc
X
# ***************************************************************
# Parameters to control Makefile operation
# Note that the gccx command script must be defined
X
CC = gccx
CFLAGS = 
X
# ***************************************************************
# Entry to bring the package up to date
X
all: $(PROGRAMS)
X
# ***************************************************************
# Standard entries to remove files from the directories
#    tidy    -- eliminate unwanted files
#    scratch -- delete derived files in preparation for rebuild
X
tidy:
X	rm -f ,* .,* *~ core a.out graphics.ps
X
scratch: tidy
X	rm -f *.o *.a $(PROGRAMS)
X
# ***************************************************************
# C compilations
X
checkout.o: checkout.c queue.h
X	$(CC) $(CFLAGS) -c checkout.c
X
dstack.o: dstack.c stack.c
X	$(CC) $(CFLAGS) -c dstack.c
X
qarray.o: qarray.c queue.h
X	$(CC) $(CFLAGS) -c qarray.c
X
qlist.o: qlist.c queue.h
X	$(CC) $(CFLAGS) -c qlist.c
X
qtest.o: qtest.c queue.h scanadt.h
X	$(CC) $(CFLAGS) -c qtest.c
X
rpncalc.o: rpncalc.c stack.h
X	$(CC) $(CFLAGS) -c rpncalc.c
X
scanadt.o: scanadt.c scanadt.h
X	$(CC) $(CFLAGS) -c scanadt.c
X
stack.o: stack.c stack.h
X	$(CC) $(CFLAGS) -c stack.c
X
X
# ***************************************************************
# Executable programs
X
checkout: checkout.o qarray.o
X	$(CC) $(CFLAGS) -o checkout checkout.o qarray.o
X
array-qtest: qtest.o scanadt.o qarray.o
X	$(CC) $(CFLAGS) -o array-qtest qtest.o scanadt.o qarray.o
X
list-qtest: qtest.o scanadt.o qlist.o
X	$(CC) $(CFLAGS) -o list-qtest qtest.o scanadt.o qlist.o
X
rpncalc: rpncalc.o stack.o
X	$(CC) $(CFLAGS) -o rpncalc rpncalc.o stack.o
X
SHAR_EOF
  $shar_touch -am 0905210197 'programs/10-Linear-Structures/Makefile' &&
  chmod 0644 'programs/10-Linear-Structures/Makefile' ||
  echo 'restore of programs/10-Linear-Structures/Makefile failed'
  shar_count="`wc -c < 'programs/10-Linear-Structures/Makefile'`"
  test 1821 -eq "$shar_count" ||
    echo "programs/10-Linear-Structures/Makefile: original size 1821, current size $shar_count"
fi
# ============= programs/11-Symbol-Tables/cmddisp.c ==============
if test ! -d 'programs/11-Symbol-Tables'; then
  echo 'x - creating directory programs/11-Symbol-Tables'
  mkdir 'programs/11-Symbol-Tables'
fi
if test -f 'programs/11-Symbol-Tables/cmddisp.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/11-Symbol-Tables/cmddisp.c (file already exists)'
else
  echo 'x - extracting programs/11-Symbol-Tables/cmddisp.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/11-Symbol-Tables/cmddisp.c' &&
/*
X * File: cmddisp.c
X * ---------------
X * This program implements a command dispatch mechanism that
X * stores function pointers in a symbol table.
X */
X
#include <stdio.h>
#include <ctype.h>
X
#include "genlib.h"
#include "strlib.h"
#include "simpio.h"
#include "symtab.h"
X
/*
X * Type: commandFnT
X * ----------------
X * This type defines the class of command functions.
X */
X
typedef void (*commandFnT)(void);
X
/*
X * Type: commandEntryT
X * -------------------
X * This type consists of a structure containing only a command
X * function.  This extra level of structure is required because
X * function pointers are not compatible with void * in ANSI C.
X */
X
typedef struct {
X    commandFnT fn;
} *commandEntryT;
X
/*
X * Private variable: commandTable
X * ------------------------------
X * The entries in this table are used to hold the commands and
X * their corresponding actions.
X */
X
static symtabADT commandTable;
X
/* Local function declarations */
X
static void InitCommandTable(void);
static void DefineCommand(string cmd, commandFnT fn);
static void ExecuteCommand(string cmd);
static void ClearCmd(void);
static void RunCmd(void);
static void HelpCmd(void);
static void QuitCmd(void);
X
/* Main test program */
X
main()
{
X    string line;
X
X    InitCommandTable();
X    while (TRUE) {
X        printf("-> ");
X        line = GetLine();
X        ExecuteCommand(line);
X        if (StringEqual(line, "quit")) break;
X    }
}
X
static void InitCommandTable(void)
{
X    commandTable = NewSymbolTable();
X    DefineCommand("clear", ClearCmd);
X    DefineCommand("run", RunCmd);
X    DefineCommand("help", HelpCmd);
X    DefineCommand("quit", QuitCmd);
}
X
static void DefineCommand(string cmd, commandFnT fn)
{
X    commandEntryT entry;
X
X    entry = New(commandEntryT);
X    entry->fn = fn;
X    Enter(commandTable, cmd, entry);
}
X
static void ExecuteCommand(string cmd)
{
X    commandEntryT entry;
X
X    entry = Lookup(commandTable, cmd);
X    if (entry == UNDEFINED) {
X        printf("Undefined command: %s\n", cmd);
X        return;
X    }
X    entry->fn();
}
X
/* Command dispatch functions */
X
static void ClearCmd(void)
{
X    printf("Command = clear\n");
}
X
static void RunCmd(void)
{
X    printf("Command = run\n");
}
X
static void HelpCmd(void)
{
X    printf("Command = help\n");
}
X
static void QuitCmd(void)
{
X    printf("Command = quit\n");
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/11-Symbol-Tables/cmddisp.c' &&
  chmod 0644 'programs/11-Symbol-Tables/cmddisp.c' ||
  echo 'restore of programs/11-Symbol-Tables/cmddisp.c failed'
  shar_count="`wc -c < 'programs/11-Symbol-Tables/cmddisp.c'`"
  test 2320 -eq "$shar_count" ||
    echo "programs/11-Symbol-Tables/cmddisp.c: original size 2320, current size $shar_count"
fi
# ============= programs/11-Symbol-Tables/cmpfn.c ==============
if test -f 'programs/11-Symbol-Tables/cmpfn.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/11-Symbol-Tables/cmpfn.c (file already exists)'
else
  echo 'x - extracting programs/11-Symbol-Tables/cmpfn.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/11-Symbol-Tables/cmpfn.c' &&
/*
X * File: cmpfn.c
X * -------------
X * This file implements the comparison functions exported by
X * the cmpfn.h interface.  The reason to centralize them in
X * a single module is to allow the same functions to be
X * shared among many different modules.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "strlib.h"
#include "cmpfn.h"
X
/* Exported entries */
X
int IntCmpFn(const void *p1, const void *p2)
{
X    int v1, v2;
X
X    v1 = *((int *) p1);
X    v2 = *((int *) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : 1);
}
X
int ShortCmpFn(const void *p1, const void *p2)
{
X    short v1, v2;
X
X    v1 = *((short *) p1);
X    v2 = *((short *) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : 1);
}
X
int LongCmpFn(const void *p1, const void *p2)
{
X    long v1, v2;
X
X    v1 = *((long *) p1);
X    v2 = *((long *) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : 1);
}
X
int UnsignedCmpFn(const void *p1, const void *p2)
{
X    unsigned v1, v2;
X
X    v1 = *((unsigned *) p1);
X    v2 = *((unsigned *) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : 1);
}
X
int UnsignedShortCmpFn(const void *p1, const void *p2)
{
X    unsigned short v1, v2;
X
X    v1 = *((unsigned short *) p1);
X    v2 = *((unsigned short *) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : 1);
}
X
int UnsignedLongCmpFn(const void *p1, const void *p2)
{
X    unsigned long v1, v2;
X
X    v1 = *((unsigned long *) p1);
X    v2 = *((unsigned long *) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : 1);
}
X
int CharCmpFn(const void *p1, const void *p2)
{
X    unsigned char v1, v2;
X
X    v1 = *((unsigned char *) p1);
X    v2 = *((unsigned char *) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : 1);
}
X
int FloatCmpFn(const void *p1, const void *p2)
{
X    float v1, v2;
X
X    v1 = *((float *) p1);
X    v2 = *((float *) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : 1);
}
X
int DoubleCmpFn(const void *p1, const void *p2)
{
X    double v1, v2;
X
X    v1 = *((double *) p1);
X    v2 = *((double *) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : 1);
}
X
int StringCmpFn(const void *p1, const void *p2)
{
X    return (StringCompare(*((string *) p1), *((string *) p2)));
}
X
int PtrCmpFn(const void *p1, const void *p2)
{
X    void *v1, *v2;
X
X    v1 = *((void **) p1);
X    v2 = *((void **) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : 1);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/11-Symbol-Tables/cmpfn.c' &&
  chmod 0644 'programs/11-Symbol-Tables/cmpfn.c' ||
  echo 'restore of programs/11-Symbol-Tables/cmpfn.c failed'
  shar_count="`wc -c < 'programs/11-Symbol-Tables/cmpfn.c'`"
  test 2430 -eq "$shar_count" ||
    echo "programs/11-Symbol-Tables/cmpfn.c: original size 2430, current size $shar_count"
fi
# ============= programs/11-Symbol-Tables/cmpfn.h ==============
if test -f 'programs/11-Symbol-Tables/cmpfn.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/11-Symbol-Tables/cmpfn.h (file already exists)'
else
  echo 'x - extracting programs/11-Symbol-Tables/cmpfn.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/11-Symbol-Tables/cmpfn.h' &&
/*
X * File: cmpfn.h
X * -------------
X * This interface exports several comparison functions for use
X * with ANSI library functions like qsort and bsearch as well
X * as various functions in the extended library.
X */
X
#ifndef _cmpfn_h
#define _cmpfn_h
X
/*
X * Type: cmpFnT
X * ------------
X * This type defines the type space of comparison functions,
X * each of which take the addresses of their arguments and
X * return an integer from the set {-1, 0, +1} depending on
X * whether the first argument is less than, equal to, or
X * greater than the second.
X */
X
typedef int (*cmpFnT)(const void *p1, const void *p2);
X
/*
X * Standard comparison functions
X * -----------------------------
X * The remainder of this interface exports standard comparison
X * functions for the most common built-in types.
X */
X
int IntCmpFn(const void *p1, const void *p2);
int ShortCmpFn(const void *p1, const void *p2);
int LongCmpFn(const void *p1, const void *p2);
int UnsignedCmpFn(const void *p1, const void *p2);
int UnsignedShortCmpFn(const void *p1, const void *p2);
int UnsignedLongCmpFn(const void *p1, const void *p2);
int CharCmpFn(const void *p1, const void *p2);
int FloatCmpFn(const void *p1, const void *p2);
int DoubleCmpFn(const void *p1, const void *p2);
int StringCmpFn(const void *p1, const void *p2);
int PtrCmpFn(const void *p1, const void *p2);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/11-Symbol-Tables/cmpfn.h' &&
  chmod 0644 'programs/11-Symbol-Tables/cmpfn.h' ||
  echo 'restore of programs/11-Symbol-Tables/cmpfn.h failed'
  shar_count="`wc -c < 'programs/11-Symbol-Tables/cmpfn.h'`"
  test 1347 -eq "$shar_count" ||
    echo "programs/11-Symbol-Tables/cmpfn.h: original size 1347, current size $shar_count"
fi
# ============= programs/11-Symbol-Tables/dumpfreq.c ==============
if test -f 'programs/11-Symbol-Tables/dumpfreq.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/11-Symbol-Tables/dumpfreq.c (file already exists)'
else
  echo 'x - extracting programs/11-Symbol-Tables/dumpfreq.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/11-Symbol-Tables/dumpfreq.c' &&
/*
X * File: dumpfreq.c
X * ----------------
X * This program goes through a file and keeps track of how
X * often each word appears.  When the input is exhausted, the
X * program writes a data file containing a table of the words
X * and their frequency in the original file.
X */
X
#include <stdio.h>
#include <ctype.h>
#include "genlib.h"
#include "strlib.h"
#include "simpio.h"
#include "scanadt.h"
#include "symtab.h"
X
/*
X * Constant: OutputFileName
X * ------------------------
X * This program always writes its output the the file named by
X * the following constant.
X */
X
#define OutputFileName "dumpfreq.dat"
X
/*
X * Type: counterT
X * --------------
X * This type is used to record the count of each word in the
X * symbol table, which requires that values be pointers.
X */
X
typedef struct {
X    int count;
} *counterT;
X
/* Private function prototypes */
X
static void RecordWord(symtabADT table, string word);
static void DumpWordFrequencies(symtabADT table, string filename);
static void DumpEntry(string key, void *value, void *clientData);
X
/* Main program */
X
main()
{
X    FILE *infile;
X    string line, token, filename;
X    scannerADT scanner;
X    symtabADT table;
X
X    scanner = NewScanner();
X    table = NewSymbolTable();
X    printf("Input file: ");
X    filename = GetLine();
X    infile = fopen(filename, "r");
X    if (infile == NULL) Error("Can't open %s", filename);
X    while ((line = ReadLine(infile)) != NULL) {
X        SetScannerString(scanner, ConvertToLowerCase(line));
X        while (MoreTokensExist(scanner)) {
X            token = ReadToken(scanner);
X            if (isalpha(token[0])) RecordWord(table, token);
X        }
X    }
X    fclose(infile);
X    DumpWordFrequencies(table, OutputFileName);
}
X
/*
X * Function: RecordWord
X * Usage: RecordWord(table, word);
X * -------------------------------
X * This function records the fact that another instance of
X * word has appeared.  The implementation looks up the word
X * in the symbol table and increments the corresponding
X * count, creating a new entry if necessary.
X */
X
static void RecordWord(symtabADT table, string word)
{
X    counterT entry;
X
X    entry = Lookup(table, word);
X    if (entry == UNDEFINED) {
X        entry = New(counterT);
X        entry->count = 0;
X        Enter(table, word, entry);
X    }
X    entry->count++;
}
X
/*
X * Function: DumpWordFrequencies
X * Usage: DumpWordFrequencies(table, filename);
X * --------------------------------------------
X * This function dumps the count associated with each word
X * in the table to the specified data file.
X */
X
static void DumpWordFrequencies(symtabADT table, string filename)
{
X    FILE *outfile;
X
X    outfile = fopen(filename, "w");
X    if (outfile == NULL) Error("Can't open output file");
X    MapSymbolTable(DumpEntry, table, outfile);
X    fclose(outfile);
}
X
/*
X * Function: DumpEntry
X * Usage: Called by MapSymbolTable
X * -------------------------------
X * This callback function is passed to MapSymbolTable to dump
X * every entry in a symbol table to a file.  The original call
X * in the client is
X *
X *    MapSymbolTable(DumpEntry, table, outfile);
X *
X * The effect of this call is to invoke DumpEntry as follows
X * on each key/value pair in the table:
X *
X *    DumpEntry(key, value, clientData);
X *
X * where clientData has the same value as outfile, although it
X * is declared as a void * pointer.
X */
X
static void DumpEntry(string key, void *value, void *clientData)
{
X    FILE *outfile;
X
X    outfile = clientData;
X    fprintf(outfile, "%-15s%5d\n", key,
X            ((counterT) value)->count);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/11-Symbol-Tables/dumpfreq.c' &&
  chmod 0644 'programs/11-Symbol-Tables/dumpfreq.c' ||
  echo 'restore of programs/11-Symbol-Tables/dumpfreq.c failed'
  shar_count="`wc -c < 'programs/11-Symbol-Tables/dumpfreq.c'`"
  test 3530 -eq "$shar_count" ||
    echo "programs/11-Symbol-Tables/dumpfreq.c: original size 3530, current size $shar_count"
fi
# ============= programs/11-Symbol-Tables/iterator.c ==============
if test -f 'programs/11-Symbol-Tables/iterator.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/11-Symbol-Tables/iterator.c (file already exists)'
else
  echo 'x - extracting programs/11-Symbol-Tables/iterator.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/11-Symbol-Tables/iterator.c' &&
/*
X * File: iterator.c
X * ----------------
X * This file implements an iterator for the symbol table
X * abstraction.  In Chapter 14, this package is superseded
X * by a more general polymorphic iterator that also works for
X * other types that represent collections.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "strlib.h"
#include "symtab.h"
#include "iterator.h"
X
/*
X * Type: cellT
X * -----------
X * This type defines a linked list cell for the iterator.
X */
X
typedef struct cellT {
X    string key;
X    struct cellT *link;
} cellT;
X
/*
X * Type: iteratorCDT
X * -----------------
X * This type provides the concrete representation for the
X * iterator, which is simply a linked list.
X */
X
struct iteratorCDT {
X    cellT *start;
};
X
/* Private function declarations */
X
static void InsertKey(string key, void *value, void *clientData);
X
/* Public entries */
X
iteratorADT NewIterator(symtabADT table)
{
X    iteratorADT iterator;
X
X    iterator = New(iteratorADT);
X    iterator->start = NULL;
X    MapSymbolTable(InsertKey, table, iterator);
X    return (iterator);
}
X
bool StepIterator(iteratorADT iterator, string *pKey)
{
X    cellT *cp;
X
X    cp = iterator->start;
X    if (cp == NULL) return (FALSE);
X    *pKey = cp->key;
X    iterator->start = cp->link;
X    FreeBlock(cp);
X    return (TRUE);
}
X
void FreeIterator(iteratorADT iterator)
{
X    cellT *cp;
X
X    while ((cp = iterator->start) != NULL) {
X        iterator->start = cp->link;
X        FreeBlock(cp);
X    }
X    FreeBlock(iterator);
}
X
/* Private functions */
X
/*
X * Function: InsertKey
X * Usage: MapSymbolTable(InsertKey, table, iterator);
X * --------------------------------------------------
X * This function is a callback function called by MapSymbolTable
X * on every entry in a symbol table.  Its effect is to insert
X * the current key into the linked list so that the order of the
X * keys is maintained in sorted order.  The code is a simple
X * find-and-insert loop that ends with prev and next pointing to
X * the cells on each side of the insertion point.  As a special
X * case, a NULL value for prev indicates insertion at the beginning.
X */
X
static void InsertKey(string key, void *value, void *clientData)
{
X    iteratorADT iterator;
X    cellT *prev, *next, *cp;
X
X    iterator = (iteratorADT) clientData;
X    prev = NULL;
X    next = iterator->start;
X    while (next != NULL && StringCompare(key, next->key) > 0) {
X        prev = next;
X        next = next->link;
X    }
X    cp = New(cellT *);
X    cp->key = key;
X    cp->link = next;
X    if (prev == NULL) {
X        iterator->start = cp;
X    } else {
X        prev->link = cp;
X    }
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/11-Symbol-Tables/iterator.c' &&
  chmod 0644 'programs/11-Symbol-Tables/iterator.c' ||
  echo 'restore of programs/11-Symbol-Tables/iterator.c failed'
  shar_count="`wc -c < 'programs/11-Symbol-Tables/iterator.c'`"
  test 2595 -eq "$shar_count" ||
    echo "programs/11-Symbol-Tables/iterator.c: original size 2595, current size $shar_count"
fi
# ============= programs/11-Symbol-Tables/iterator.h ==============
if test -f 'programs/11-Symbol-Tables/iterator.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/11-Symbol-Tables/iterator.h (file already exists)'
else
  echo 'x - extracting programs/11-Symbol-Tables/iterator.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/11-Symbol-Tables/iterator.h' &&
/*
X * File: iterator.h
X * ----------------
X * This file implements an iterator for the symbol table
X * abstraction.  In the chapter on "Sets," this package is
X * superseded by a more general polymorphic iterator that
X * works for other collection types as well.
X */
X
#ifndef _iterator_h
#define _iterator_h
X
#include "genlib.h"
#include "symtab.h"
X
/*
X * Type: iteratorADT
X * -----------------
X * This abstract type is used to iterate over the elements
X * in a symbol table.
X */
X
typedef struct iteratorCDT *iteratorADT;
X
/* Exported entries */
X
/*
X * Functions: NewIterator, StepIterator, FreeIterator
X * Usage: iterator = NewIterator(table);
X *        while (StepIterator(iterator, &key)) {
X *            . . . body of loop involving key . . .
X *        }
X *        FreeIterator(iterator);
X * -------------------------------------------------
X * These functions make it possible to iterate over the keys
X * in a symbol table without having to call a mapping function.
X * The call to NewIterator creates a new iteratorADT that
X * contains all the keys in the table, arranged in ASCII order.
X * Each call to StepIterator advances the iterator and returns
X * the next key using the reference parameter.  StepIterator
X * returns TRUE until the keys are exhausted, after which it
X * returns FALSE.  The FreeIterator function releases any
X * storage associated with the iterator.
X */
X
iteratorADT NewIterator(symtabADT table);
bool StepIterator(iteratorADT iterator, string *pKey);
void FreeIterator(iteratorADT iterator);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/11-Symbol-Tables/iterator.h' &&
  chmod 0644 'programs/11-Symbol-Tables/iterator.h' ||
  echo 'restore of programs/11-Symbol-Tables/iterator.h failed'
  shar_count="`wc -c < 'programs/11-Symbol-Tables/iterator.h'`"
  test 1527 -eq "$shar_count" ||
    echo "programs/11-Symbol-Tables/iterator.h: original size 1527, current size $shar_count"
fi
# ============= programs/11-Symbol-Tables/macbeth.txt ==============
if test -f 'programs/11-Symbol-Tables/macbeth.txt' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/11-Symbol-Tables/macbeth.txt (file already exists)'
else
  echo 'x - extracting programs/11-Symbol-Tables/macbeth.txt (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/11-Symbol-Tables/macbeth.txt' &&
Tomorrow, and tomorrow, and tomorrow
Creeps in this petty pace from day to day
SHAR_EOF
  $shar_touch -am 0906100197 'programs/11-Symbol-Tables/macbeth.txt' &&
  chmod 0644 'programs/11-Symbol-Tables/macbeth.txt' ||
  echo 'restore of programs/11-Symbol-Tables/macbeth.txt failed'
  shar_count="`wc -c < 'programs/11-Symbol-Tables/macbeth.txt'`"
  test 79 -eq "$shar_count" ||
    echo "programs/11-Symbol-Tables/macbeth.txt: original size 79, current size $shar_count"
fi
# ============= programs/11-Symbol-Tables/mapfreq.c ==============
if test -f 'programs/11-Symbol-Tables/mapfreq.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/11-Symbol-Tables/mapfreq.c (file already exists)'
else
  echo 'x - extracting programs/11-Symbol-Tables/mapfreq.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/11-Symbol-Tables/mapfreq.c' &&
/*
X * File: mapfreq.c
X * ---------------
X * This program goes through a file and keeps track of how
X * often each word appears.  When the input is exhausted, the
X * program displays a table of the words and their frequency.
X */
X
#include <stdio.h>
#include <ctype.h>
#include "genlib.h"
#include "strlib.h"
#include "simpio.h"
#include "scanadt.h"
#include "symtab.h"
X
/*
X * Type: counterT
X * --------------
X * This type is used to record the count of each word in the
X * symbol table, which requires that values be pointers.
X */
X
typedef struct {
X    int count;
} *counterT;
X
/* Private function prototypes */
X
static void RecordWord(symtabADT table, string word);
static void DisplayWordFrequencies(symtabADT table);
static void DisplayEntry(string key, void *value, void *clientData);
X
/* Main program */
X
main()
{
X    FILE *infile;
X    string line, token, filename;
X    scannerADT scanner;
X    symtabADT table;
X
X    scanner = NewScanner();
X    table = NewSymbolTable();
X    printf("Input file: ");
X    filename = GetLine();
X    infile = fopen(filename, "r");
X    if (infile == NULL) Error("Can't open %s", filename);
X    while ((line = ReadLine(infile)) != NULL) {
X        SetScannerString(scanner, ConvertToLowerCase(line));
X        while (MoreTokensExist(scanner)) {
X            token = ReadToken(scanner);
X            if (isalpha(token[0])) RecordWord(table, token);
X        }
X    }
X    fclose(infile);
X    DisplayWordFrequencies(table);
}
X
/*
X * Function: RecordWord
X * Usage: RecordWord(table, word);
X * -------------------------------
X * This function records the fact that another instance of
X * word has appeared.  The implementation looks up the word
X * in the symbol table and increments the corresponding
X * count, creating a new entry if necessary.
X */
X
static void RecordWord(symtabADT table, string word)
{
X    counterT entry;
X
X    entry = Lookup(table, word);
X    if (entry == UNDEFINED) {
X        entry = New(counterT);
X        entry->count = 0;
X        Enter(table, word, entry);
X    }
X    entry->count++;
}
X
/*
X * Function: DisplayWordFrequencies
X * Usage: DisplayWordFrequencies(table);
X * -------------------------------------
X * This function displays the count associated with each word
X * in the table.
X */
X
static void DisplayWordFrequencies(symtabADT table)
{
X    printf("Word frequency table:\n");
X    MapSymbolTable(DisplayEntry, table, NULL);
}
X
/*
X * Function: DisplayEntry
X * Usage: Called by MapSymbolTable
X * -------------------------------
X * This callback function is passed to MapSymbolTable to display
X * every entry in a symbol table.  The original call in the
X * client is
X *
X *    MapSymbolTable(DisplayEntry, table, NULL);
X *
X * The effect of this call is to invoke DisplayEntry as follows
X * on each key/value pair in the table:
X *
X *    DisplayEntry(key, value, NULL);
X *
X * The clientData parameter is ignored in this application.
X */
X
static void DisplayEntry(string key, void *value, void *clientData)
{
X    printf("%-15s%5d\n", key, ((counterT) value)->count);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/11-Symbol-Tables/mapfreq.c' &&
  chmod 0644 'programs/11-Symbol-Tables/mapfreq.c' ||
  echo 'restore of programs/11-Symbol-Tables/mapfreq.c failed'
  shar_count="`wc -c < 'programs/11-Symbol-Tables/mapfreq.c'`"
  test 3013 -eq "$shar_count" ||
    echo "programs/11-Symbol-Tables/mapfreq.c: original size 3013, current size $shar_count"
fi
# ============= programs/11-Symbol-Tables/plot.c ==============
if test -f 'programs/11-Symbol-Tables/plot.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/11-Symbol-Tables/plot.c (file already exists)'
else
  echo 'x - extracting programs/11-Symbol-Tables/plot.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/11-Symbol-Tables/plot.c' &&
/*
X * File: plot.c
X * ------------
X * This program can be used to plot the graph of an
X * arbitrary function.
X */
X
#include <stdio.h>
#include <math.h>
#include "genlib.h"
#include "graphics.h"
X
/*
X * Constants
X * ---------
X * Pi     -- Mathematical constant pi
X * DeltaX -- Distance between x points
X */
X
#define Pi     3.14159265
#define DeltaX 0.05
X
/*
X * Type: doubleFnT
X * ---------------
X * This type defines the class of functions that maps doubles
X * to doubles.
X */
X
typedef double (*doubleFnT)(double);
X
/* Function prototypes */
X
void PlotFunction(doubleFnT fn, double start, double finish);
static void DrawLineTo(double x, double y);
X
/* Main program */
X
main()
{
X    InitGraphics();
X    PlotFunction(sin, 0, 2 * Pi);
}
X
/*
X * Function: PlotFunction
X * Usage: PlotFunction(fn, start, finish);
X * ---------------------------------------
X * This function plots the indicated function for x values between
X * start and finish, advancing x in units of DeltaX.
X */
X
void PlotFunction(doubleFnT fn, double start, double finish)
{
X    double x;
X
X    MovePen(start, fn(start));
X    for (x = start + DeltaX; x <= finish; x += DeltaX) {
X        DrawLineTo(x, fn(x));
X    }
}
X
X
/*
X * Function: DrawLineTo
X * Usage: DrawLineTo(x, y);
X * ------------------------
X * This function is like DrawLine, except that it uses the
X * absolute coordinates of the endpoint rather than the relative
X * displacement from the current point.
X */
X
static void DrawLineTo(double x, double y)
{
X    DrawLine(x - GetCurrentX(), y - GetCurrentY());
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/11-Symbol-Tables/plot.c' &&
  chmod 0644 'programs/11-Symbol-Tables/plot.c' ||
  echo 'restore of programs/11-Symbol-Tables/plot.c failed'
  shar_count="`wc -c < 'programs/11-Symbol-Tables/plot.c'`"
  test 1531 -eq "$shar_count" ||
    echo "programs/11-Symbol-Tables/plot.c: original size 1531, current size $shar_count"
fi
# ============= programs/11-Symbol-Tables/scanadt.c ==============
if test -f 'programs/11-Symbol-Tables/scanadt.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/11-Symbol-Tables/scanadt.c (file already exists)'
else
  echo 'x - extracting programs/11-Symbol-Tables/scanadt.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/11-Symbol-Tables/scanadt.c' &&
/*
X * File: scanadt.c
X * ---------------
X * This file implements the scanadt.h interface.
X */
X
#include <stdio.h>
#include <ctype.h>
#include "genlib.h"
#include "strlib.h"
#include "scanadt.h"
X
/*
X * Type: scannerCDT
X * ----------------
X * This structure is the concrete representation of the type
X * scannerADT, which is exported by this interface.  Its purpose
X * is to maintain the state of the scanner between calls.  The
X * details of the representation are invisible to the client,
X * but consist of the following fields:
X *
X * str          -- Copy of string passed to SetScannerString
X * len          -- Length of string, saved for efficiency
X * cp           -- Current character position in the string
X * savedToken   -- String saved by SaveToken (NULL indicates none)
X * spaceOption  -- Setting of the space option extension
X * numberOption -- Setting of the number option extension
X * stringOption -- Setting of string option extension
X */
X
struct scannerCDT {
X    string str;
X    int len;
X    int cp;
X    string savedToken;
X    spaceOptionT spaceOption;
X    numberOptionT numberOption;
X    stringOptionT stringOption;
};
X
/* Private function prototypes */
X
static void SkipSpaces(scannerADT scanner);
static int ScanToEndOfIdentifier(scannerADT scanner);
static int ScanToEndOfInteger(scannerADT scanner);
static int ScanToEndOfReal(scannerADT scanner);
static string ScanQuotedString(scannerADT scanner);
static char ScanEscapeCharacter(scannerADT scanner);
X
/* Exported entries */
X
scannerADT NewScanner(void)
{
X    scannerADT scanner;
X
X    scanner = New(scannerADT);
X    scanner->str = NULL;
X    scanner->spaceOption = PreserveSpaces;
X    scanner->numberOption = ScanNumbersAsLetters;
X    scanner->stringOption = ScanQuotesAsPunctuation;
X    return (scanner);
}
X
void FreeScanner(scannerADT scanner)
{
X    if (scanner->str != NULL) FreeBlock(scanner->str);
X    FreeBlock(scanner);
}
X
void SetScannerString(scannerADT scanner, string str)
{
X    if (scanner->str != NULL) FreeBlock(scanner->str);
X    scanner->str = CopyString(str);
X    scanner->len = StringLength(str);
X    scanner->cp = 0;
X    scanner->savedToken = NULL;
}
X
string ReadToken(scannerADT scanner)
{
X    char ch;
X    string token;
X    int start, finish;
X
X    if (scanner->str == NULL) {
X        Error("SetScannerString has not been called");
X    }
X    if (scanner->savedToken != NULL) {
X        token = scanner->savedToken;
X        scanner->savedToken = NULL;
X        return (token);
X    }
X    if (scanner->spaceOption == IgnoreSpaces) SkipSpaces(scanner);
X    start = finish = scanner->cp;
X    if (start >= scanner->len) return (CopyString(""));
X    ch = scanner->str[scanner->cp];
X    if (scanner->stringOption == ScanQuotesAsStrings
X            && ch == '"') {
X        return (ScanQuotedString(scanner));
X    }
X    if (isdigit(ch)) {
X        switch (scanner->numberOption) {
X          case ScanNumbersAsLetters:
X            finish = ScanToEndOfIdentifier(scanner);
X            break;
X          case ScanNumbersAsIntegers:
X            finish = ScanToEndOfInteger(scanner);
X            break;
X          case ScanNumbersAsReals:
X            finish = ScanToEndOfReal(scanner);
X            break;
X        }
X    } else if (isalnum(ch)) {
X        finish = ScanToEndOfIdentifier(scanner);
X    } else {
X        scanner->cp++;
X    }
X    return (SubString(scanner->str, start, finish));
}
X
bool MoreTokensExist(scannerADT scanner)
{
X    if (scanner->str == NULL) {
X        Error("SetScannerString has not been called");
X    }
X    if (scanner->savedToken != NULL) {
X        return (!StringEqual(scanner->savedToken, ""));
X    }
X    if (scanner->spaceOption == IgnoreSpaces) SkipSpaces(scanner);
X    return (scanner->cp < scanner->len);
}
X
void SaveToken(scannerADT scanner, string token)
{
X    if (scanner->str == NULL) {
X        Error("SetScannerString has not been called");
X    }
X    if (scanner->savedToken != NULL) {
X        Error("Token has already been saved");
X    }
X    scanner->savedToken = token;
}
X
void SetScannerSpaceOption(scannerADT scanner, spaceOptionT option)
{
X    scanner->spaceOption = option;
}
X
spaceOptionT GetScannerSpaceOption(scannerADT scanner)
{
X    return (scanner->spaceOption);
}
X
void SetScannerNumberOption(scannerADT scanner, numberOptionT option)
{
X    scanner->numberOption = option;
}
X
numberOptionT GetScannerNumberOption(scannerADT scanner)
{
X    return (scanner->numberOption);
}
X
void SetScannerStringOption(scannerADT scanner, stringOptionT option)
{
X    scanner->stringOption = option;
}
X
stringOptionT GetScannerStringOption(scannerADT scanner)
{
X    return (scanner->stringOption);
}
X
/* Private functions */
X
/*
X * Function: SkipSpaces
X * Usage: SkipSpaces(scanner);
X * ---------------------------
X * This function advances the position of the scanner until the
X * current character is not a whitespace character.
X */
X
static void SkipSpaces(scannerADT scanner)
{
X    while (isspace(scanner->str[scanner->cp])) {
X        scanner->cp++;
X    }
}
X
/*
X * Function: ScanToEndOfIdentifier
X * Usage: finish = ScanToEndOfIdentifier(scanner);
X * -----------------------------------------------
X * This function advances the position of the scanner until it
X * reaches the end of a sequence of letters or digits that make
X * up an identifier.  The return value is the index of the last
X * character in the identifier; the value of the stored index
X * cp is the first character after that.
X */
X
static int ScanToEndOfIdentifier(scannerADT scanner)
{
X    while (isalnum(scanner->str[scanner->cp])) {
X        scanner->cp++;
X    }
X    return (scanner->cp - 1);
}
X
/*
X * Function: ScanToEndOfInteger
X * Usage: finish = ScanToEndOfInteger(scanner);
X * --------------------------------------------
X * This function advances the position of the scanner until it
X * reaches the end of a sequence of digits.  The return value is
X * the index of the last character in the integer; the value
X * of the stored index cp is the first character after that.
X */
X
static int ScanToEndOfInteger(scannerADT scanner)
{
X    while (isdigit(scanner->str[scanner->cp])) {
X        scanner->cp++;
X    }
X    return (scanner->cp - 1);
}
X
/*
X * Function: ScanToEndOfReal
X * Usage: finish = ScanToEndOfReal(scanner);
X * -----------------------------------------
X * This function advances the position of the scanner until it
X * reaches the end of a legal number.  The return value is the
X * index of the last character in the identifier; the value
X * of the stored index cp is the first character after that.
X *
X * The function operates by simulating what computer scientists
X * call a finite-state machine.  The program uses the variable
X * state to record the history of the process and determine
X * what characters would be legal at this point in time.
X */
X
#define InitialState        0
#define BeforeDecimalPoint  1
#define AfterDecimalPoint   2
#define StartingExponent    3
#define FoundExponentSign   4
#define ScanningExponent    5
#define FinalState         -1
X
static int ScanToEndOfReal(scannerADT scanner)
{
X    int state;
X    char ch;
X
X    state = InitialState;
X    while (state != FinalState) {
X        ch = scanner->str[scanner->cp];
X        switch (state) {
X          case InitialState:
X            if (!isdigit(ch)) Error("ScanToEndOfReal called on nonnumber");
X             state = BeforeDecimalPoint;
X            break;
X          case BeforeDecimalPoint:
X            if (ch == '.') {
X                state = AfterDecimalPoint;
X            } else if (ch == 'E' || ch == 'e') {
X                state = StartingExponent;
X            } else if (!isdigit(ch)) {
X                state = FinalState;
X            }
X            break;
X          case AfterDecimalPoint:
X            if (ch == 'E' || ch == 'e') {
X                state = StartingExponent;
X            } else if (!isdigit(ch)) {
X                state = FinalState;
X            }
X            break;
X          case StartingExponent:
X            if (ch == '+' || ch == '-') {
X                state = FoundExponentSign;
X            } else if (isdigit(ch)) {
X                state = ScanningExponent;
X            } else {
X                scanner->cp--;
X                state = FinalState;
X            }
X            break;
X          case FoundExponentSign:
X            if (isdigit(ch)) {
X                state = ScanningExponent;
X            } else {
X                scanner->cp -= 2;
X                state = FinalState;
X            }
X            break;
X          case ScanningExponent:
X            if (!isdigit(ch)) {
X                state = FinalState;
X            }
X            break;
X        }
X        if (state != FinalState) scanner->cp++;
X    }
X    return (scanner->cp - 1);
}
X
/*
X * Function: ScanQuotedString
X * Usage: str = ScanQuotedString(scanner);
X * ---------------------------------------
X * This function reads and returns a quoted string from the
X * scanner.  The current position of the scanner must be the
X * opening quotation mark.  At the end, the current position
X * marker will be set to the character position after the
X * closing quote.  The scanner generates an error if there
X * is no closing quotation mark before the end of the string.
X */
X
static string ScanQuotedString(scannerADT scanner)
{
X    string token;
X    char ch;
X
X    token = "\"";
X    scanner->cp++;
X    while ((ch = scanner->str[scanner->cp++]) != '"') {
X        if (ch == '\0') Error("Unterminated string");
X        if (ch == '\\') ch = ScanEscapeCharacter(scanner);
X        token = Concat(token, CharToString(ch));
X    }
X    return (Concat(token, "\""));
}
X
/*
X * Function: ScanEscapeCharacter
X * Usage: ch = ScanEscapeCharacter(scanner);
X * -----------------------------------------
X * This function is used by ScanQuotedString to read an escape
X * character sequence from the scanner string.  The opening
X * backslash character has already been read.  Most of the
X * complexity comes in reading the '\ddd' and '\xdd' forms.
X */
X
static char ScanEscapeCharacter(scannerADT scanner)
{
X    char ch, result;
X    int digit, base;
X
X    ch = scanner->str[scanner->cp];
X    if (isdigit(ch) || ch == 'x') {
X        base = 8;
X        if (ch == 'x') {
X            base = 16;
X            scanner->cp++;
X        }
X        result = 0;
X        while (TRUE) {
X            ch = scanner->str[scanner->cp];
X            if (isdigit(ch)) {
X                digit = ch - '0';
X            } else if (isalpha(ch)) {
X                digit = toupper(ch) - 'A' + 10;
X            } else {
X                digit = base;
X            }
X            if (digit >= base) break;
X            result = base * result + digit;
X            scanner->cp++;
X        }
X        return (result);
X    }
X    scanner->cp++;
X    switch (ch) {
X      case 'a':  return ('\a');
X      case 'b':  return ('\b');
X      case 'f':  return ('\f');
X      case 'n':  return ('\n');
X      case 'r':  return ('\r');
X      case 't':  return ('\t');
X      case 'v':  return ('\v');
X      case '\\': return ('\\');
X      case '"':  return ('"');
X    }
}
X
SHAR_EOF
  $shar_touch -am 0903182097 'programs/11-Symbol-Tables/scanadt.c' &&
  chmod 0644 'programs/11-Symbol-Tables/scanadt.c' ||
  echo 'restore of programs/11-Symbol-Tables/scanadt.c failed'
  shar_count="`wc -c < 'programs/11-Symbol-Tables/scanadt.c'`"
  test 10929 -eq "$shar_count" ||
    echo "programs/11-Symbol-Tables/scanadt.c: original size 10929, current size $shar_count"
fi
# ============= programs/11-Symbol-Tables/scanadt.h ==============
if test -f 'programs/11-Symbol-Tables/scanadt.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/11-Symbol-Tables/scanadt.h (file already exists)'
else
  echo 'x - extracting programs/11-Symbol-Tables/scanadt.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/11-Symbol-Tables/scanadt.h' &&
/*
X * File: scanadt.h
X * ---------------
X * This file is the interface to a module that exports an abstract
X * data type to facilitate dividing a string into logical units
X * called "tokens," which are either
X *
X * 1. Strings of consecutive letters and digits representing words
X * 2. One-character strings representing punctuation or separators
X *
X * To use this package, you must first create an instance of a
X * scannerADT by calling
X *
X *      scanner = NewScanner();
X *
X * All other calls to the scanner package take this variable as their
X * first argument to identify a particular instance of the abstract
X * scanner type.
X *
X * You initialize the scanner to hold a particular string by calling
X *
X *      SetScannerString(scanner, str);
X *
X * where str is the string from which tokens should be read.  To
X * retrieve each individual token, you make the following call:
X *
X *      token = ReadToken(scanner);
X *
X * To determine whether any tokens remain to be read, you can call
X * the predicate function MoreTokensExist(scanner).  The ReadToken
X * function returns the empty string after the last token is read.
X *
X * The following code fragment serves as an idiom for processing
X * each token in the string inputString:
X *
X *      scanner = NewScanner();
X *      SetScannerString(scanner, inputString);
X *      while (MoreTokensExist(scanner)) {
X *          token = ReadToken(scanner);
X *          . . . process the token . . .
X *      }
X *
X * This version of scanadt.h also supports the following extensions,
X * which are documented later in the interface:
X *
X *   SaveToken
X *   SetScannerSpaceOption
X *   SetScannerStringOption
X *   SetScannerNumberOption
X */
X
#ifndef _scanadt_h
#define _scanadt_h
X
#include "genlib.h"
X
/*
X * Type: scannerADT
X * ----------------
X * This type is the abstract type used to represent a single instance
X * of a scanner.  As with any abstract type, the details of the
X * internal representation are hidden from the client.
X */
X
typedef struct scannerCDT *scannerADT;
X
/*
X * Function: NewScanner
X * Usage: scanner = NewScanner();
X * ------------------------------
X * This function creates a new scanner instance.  All other functions
X * in this interface take this scanner value as their first argument
X * so that they can identify what particular instance of the scanner
X * is in use.  This design makes it possible for clients to have more
X * than one scanner process active at the same time.
X */
X
scannerADT NewScanner(void);
X
/*
X * Function: FreeScanner
X * Usage: FreeScanner(scanner);
X * ----------------------------
X * This function frees the storage associated with scanner.
X */
X
void FreeScanner(scannerADT scanner);
X
/*
X * Function: SetScannerString
X * Usage: SetScannerString(scanner, str);
X * --------------------------------------
X * This function initializes the scanner so that it will start
X * extracting tokens from the string str.
X */
X
void SetScannerString(scannerADT scanner, string str);
X
/*
X * Function: ReadToken
X * Usage: token = ReadToken(scanner);
X * ----------------------------------
X * This function returns the next token from scanner.  If ReadToken
X * is called when there are no tokens available, it returns the
X * empty string.  The token returned by ReadToken is always
X * allocated in the heap, which means that clients can call
X * FreeBlock when the token is no longer needed.
X */
X
string ReadToken(scannerADT scanner);
X
/*
X * Function: MoreTokensExist
X * Usage: if (MoreTokensExist(scanner)) . . .
X * ------------------------------------------
X * This function returns TRUE as long as there are additional
X * tokens available for the scanner to read.
X */
X
bool MoreTokensExist(scannerADT scanner);
X
/*
X * Function: SaveToken
X * Usage: SaveToken(scanner, token);
X * ---------------------------------
X * This function sets the internal data structure within the scanner
X * so that the next time ReadToken is called, it will return the
X * specified token without reading any additional characters from
X * the input.
X */
X
void SaveToken(scannerADT scanner, string token);
X
/*
X * Functions: SetScannerSpaceOption, GetScannerSpaceOption
X * Usage: SetScannerSpaceOption(scanner, option);
X *        option = GetScannerSpaceOption(scanner);
X * -----------------------------------------------
X * The SetScannerSpaceOption function controls whether the scanner
X * ignores whitespace characters or treats them as valid tokens.
X * By default, the ReadToken function treats whitespace characters,
X * such as spaces and tabs, just like any other punctuation mark.
X * If, however, you call
X *
X *    SetScannerSpaceOption(scanner, IgnoreSpaces);
X *
X * the scanner will skip over any white space before reading a token.
X * You can restore the original behavior by calling
X *
X *    SetScannerSpaceOption(scanner, PreserveSpaces);
X *
X * The GetScannerSpaceOption function returns the current setting
X * of this option.
X */
X
typedef enum { PreserveSpaces, IgnoreSpaces } spaceOptionT;
X
void SetScannerSpaceOption(scannerADT scanner, spaceOptionT option);
spaceOptionT GetScannerSpaceOption(scannerADT scanner);
X
/*
X * Functions: SetScannerNumberOption, GetScannerNumberOption
X * Usage: SetScannerNumberOption(scanner, option);
X *        option = GetScannerNumberOption(scanner);
X * ------------------------------------------------
X * This function controls whether the scanner treats numeric values
X * specially.  The default behavior for the scanner is to treat
X * digits as equivalent to letters.  If you call
X *
X *    SetScannerNumberOption(scanner, ScanNumbersAsIntegers);
X *
X * a token beginning with a digit will end at the first nondigit.
X * (Note that digits can still be scanned as part of a token as in
X * the token "x1".)  If you call
X *
X *    SetScannerNumberOption(scanner, ScanNumbersAsReals);
X *
X * the scanner will return the longest token string that represents
X * a real number, if the next character to be scanned is a digit.
X * The format for a real number is a sequence of digit characters
X * that may include at most one decimal point, optionally followed
X * by the letter 'E' in either upper- or lowercase, an optional sign,
X * and an exponent.  You can restore the default behavior by calling
X *
X *    SetScannerNumberOption(scanner, ScanNumbersAsLetters);
X *
X * Even if the number options are enabled, ReadToken always returns
X * its result as a string, which means that you need to call
X * StringToInteger or StringToReal to convert the token to a number.
X */
X
typedef enum {
X    ScanNumbersAsLetters,
X    ScanNumbersAsIntegers,
X    ScanNumbersAsReals
} numberOptionT;
X
void SetScannerNumberOption(scannerADT scanner, numberOptionT option);
numberOptionT GetScannerNumberOption(scannerADT scanner);
X
/*
X * Functions: SetScannerStringOption, GetScannerStringOption
X * Usage: SetScannerStringOption(scanner, option);
X *        option = GetScannerStringOption(scanner);
X * ------------------------------------------------
X * This function controls how the scanner treats double quotation
X * marks in the input.  The default behavior for the scanner is
X * to treat quotes just like any other punctuation character.
X * If, however, you call
X *
X *    SetScannerStringOption(scanner, ScanQuotesAsStrings);
X *
X * a token beginning with a quotation mark will be scanned up to
X * the closing quotation mark.  The quotation marks are returned
X * as part of the scanned token so that clients can differentiate
X * strings from other token types.  The original behavior can be
X * restored by calling
X *
X *    SetScannerStringOption(scanner, ScanQuotesAsPunctuation);
X *
X * When scanning a string, the scanner recognizes the standard
X * escape sequences from ANSI C, such as \n and \t.
X */
X
typedef enum {
X    ScanQuotesAsPunctuation,
X    ScanQuotesAsStrings
} stringOptionT;
X
void SetScannerStringOption(scannerADT scanner, stringOptionT option);
stringOptionT GetScannerStringOption(scannerADT scanner);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/11-Symbol-Tables/scanadt.h' &&
  chmod 0644 'programs/11-Symbol-Tables/scanadt.h' ||
  echo 'restore of programs/11-Symbol-Tables/scanadt.h failed'
  shar_count="`wc -c < 'programs/11-Symbol-Tables/scanadt.h'`"
  test 7881 -eq "$shar_count" ||
    echo "programs/11-Symbol-Tables/scanadt.h: original size 7881, current size $shar_count"
fi
# ============= programs/11-Symbol-Tables/sorttest.c ==============
if test -f 'programs/11-Symbol-Tables/sorttest.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/11-Symbol-Tables/sorttest.c (file already exists)'
else
  echo 'x - extracting programs/11-Symbol-Tables/sorttest.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/11-Symbol-Tables/sorttest.c' &&
/*
X * File: sorttest.c
X * ----------------
X * This program tests the qsort library function by using it
X * as both an alphabetization and numeric sorting function.
X */
X
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "genlib.h"
#include "strlib.h"
#include "simpio.h"
#include "cmpfn.h"
X
/*
X * Constants
X * ---------
X * MaxArray        -- Maximum size of test arrays
X * NumericSentinel -- Sentinel value used to terminate integer list
X */
X
#define MaxArray        100
#define NumericSentinel  -1
X
/* Private function prototypes */
X
static void NumericSort(void);
static void AlphabeticSort(void);
static bool PrefixMatch(string prefix, string str);
static int GetIntegerArray(int array[], int max, int sentinel);
static int GetStringArray(string array[], int max, string sentinel);
static void PrintIntegerArray(int array[], int n);
static void PrintStringArray(string array[], int n);
X
/* Main program */
X
main()
{
X    string stype;
X
X    printf("Enter sort type (numeric or alphabetic): ");
X    stype = ConvertToLowerCase(GetLine());
X    if (PrefixMatch(stype, "numeric")) {
X        NumericSort();
X    } else if (PrefixMatch(stype, "alphabetic")) {
X        AlphabeticSort();
X    } else {
X        Error("Unrecognized sort type");
X    }
}
X
/* Private functions */
X
/*
X * Function: NumericSort
X * Usage: NumericSort();
X * ---------------------
X * This function tests the use of qsort with integers.
X */
X
static void NumericSort(void)
{
X    int array[MaxArray];
X    int n;
X
X    printf("Enter numeric elements (use %d to stop)\n",
X           NumericSentinel);
X    n = GetIntegerArray(array, MaxArray, NumericSentinel);
X    qsort(array, n, sizeof(int), IntCmpFn);
X    printf("The sorted array is:\n");
X    PrintIntegerArray(array, n);
}
X
/*
X * Function: AlphabeticSort
X * Usage: AlphabeticSort();
X * ------------------------
X * This function tests the use of qsort with strings.
X */
X
static void AlphabeticSort(void)
{
X    string array[MaxArray];
X    int n;
X
X    printf("Enter strings (use blank line to stop)\n");
X    n = GetStringArray(array, MaxArray, "");
X    qsort(array, n, sizeof(string), StringCmpFn);
X    printf("The alphabetized array is:\n");
X    PrintStringArray(array, n);
}
X
/*
X * Function: PrefixMatch
X * Usage: if (PrefixMatch(prefix, str)) . . .
X * ------------------------------------------
X * This function returns TRUE if prefix matches the beginning of str.
X */
X
static bool PrefixMatch(string prefix, string str)
{
X    return (strncmp(prefix, str, strlen(prefix)) == 0);
}
X
/*
X * Function: GetIntegerArray
X * Usage: n = GetIntegerArray(array, max, sentinel);
X * -------------------------------------------------
X * This function reads elements into an integer array by
X * reading values, one per line, from the keyboard.  The end
X * of the input data is indicated by the parameter sentinel.
X * The caller is responsible for declaring the array and
X * passing it as a parameter, along with its allocated
X * size.  The value returned is the number of elements
X * actually entered and therefore gives the effective size
X * of the array, which is typically less than the allocated
X * size given by max.  If the user types in more than max
X * elements, GetIntegerArray generates an error.
X */
X
static int GetIntegerArray(int array[], int max, int sentinel)
{
X    int n, value;
X
X    n = 0;
X    while (TRUE) {
X        printf(" ? ");
X        value = GetInteger();
X        if (value == sentinel) break;
X        if (n == max) Error("Too many input items for array");
X        array[n] = value;
X        n++;
X    }
X    return (n);
}
X
/*
X * Function: GetStringArray
X * Usage: n = GetStringArray(array, max, sentinel);
X * ------------------------------------------------
X * This function reads elements into an array of strings by
X * reading values, one per line, from the keyboard.  The end
X * of the input data is indicated by the parameter sentinel.
X * The caller is responsible for declaring the array and
X * passing it in as a parameter, along with its allocated
X * size.  The value returned is the number of elements
X * actually entered and therefore gives the effective size
X * of the array, which is typically less than the allocated
X * size given by max.  If the user types in more than max
X * elements, GetStringArray generates an error.
X */
X
static int GetStringArray(string array[], int max, string sentinel)
{
X    int n;
X    string value;
X
X    n = 0;
X    while (TRUE) {
X        printf(": ");
X        value = GetLine();
X        if (StringEqual(value, sentinel)) break;
X        if (n == max) Error("Too many input items for array");
X        array[n] = value;
X        n++;
X    }
X    return (n);
}
X
/*
X * Function: PrintIntegerArray
X * Usage: PrintIntegerArray(array, n);
X * -----------------------------------
X * This function displays the first n values in array,
X * one per line, on the console.
X */
X
static void PrintIntegerArray(int array[], int n)
{
X    int i;
X
X    for (i = 0; i < n; i++) {
X        printf("%d\n", array[i]);
X    }
}
X
/*
X * Function: PrintStringArray
X * Usage: PrintStringArray(array, n);
X * ----------------------------------
X * This function displays the first n values in array,
X * one per line, on the console.
X */
X
static void PrintStringArray(string array[], int n)
{
X    int i;
X
X    for (i = 0; i < n; i++) {
X        printf("%s\n", array[i]);
X    }
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/11-Symbol-Tables/sorttest.c' &&
  chmod 0644 'programs/11-Symbol-Tables/sorttest.c' ||
  echo 'restore of programs/11-Symbol-Tables/sorttest.c failed'
  shar_count="`wc -c < 'programs/11-Symbol-Tables/sorttest.c'`"
  test 5312 -eq "$shar_count" ||
    echo "programs/11-Symbol-Tables/sorttest.c: original size 5312, current size $shar_count"
fi
# ============= programs/11-Symbol-Tables/symtab.c ==============
if test -f 'programs/11-Symbol-Tables/symtab.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/11-Symbol-Tables/symtab.c (file already exists)'
else
  echo 'x - extracting programs/11-Symbol-Tables/symtab.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/11-Symbol-Tables/symtab.c' &&
/*
X * File: symtab.c
X * --------------
X * This file implements the symbol table abstraction.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "strlib.h"
#include "symtab.h"
X
/*
X * Constants
X * ---------
X * NBuckets -- Number of buckets in the hash table
X */
X
#define NBuckets 101
X
/*
X * Type: cellT
X * -----------
X * This type defines a linked list cell for the symbol table.
X */
X
typedef struct cellT {
X    string key;
X    void *value;
X    struct cellT *link;
} cellT;
X
/*
X * Type: symtabCDT
X * ---------------
X * This type defines the underlying concrete representation for a
X * symtabADT.  These details are not relevant to and therefore
X * not exported to the client.  In this implementation, the
X * underlying structure is a hash table organized as an array of
X * "buckets," in which each bucket is a linked list of elements
X * that share the same hash code.
X */
X
struct symtabCDT {
X    cellT *buckets[NBuckets];
};
X
/* Private function declarations */
X
static void FreeBucketChain(cellT *cp);
static cellT *FindCell(cellT *cp, string s);
static int Hash(string s, int nBuckets);
X
/* Public entries */
X
symtabADT NewSymbolTable(void)
{
X    symtabADT table;
X    int i;
X
X    table = New(symtabADT);
X    for (i = 0; i < NBuckets; i++) {
X        table->buckets[i] = NULL;
X    }
X    return (table);
}
X
void FreeSymbolTable(symtabADT table)
{
X    int i;
X
X    for (i = 0; i < NBuckets; i++) {
X        FreeBucketChain(table->buckets[i]);
X    }
X    FreeBlock(table);
}
X
void Enter(symtabADT table, string key, void *value)
{
X    int bucket;
X    cellT *cp;
X
X    bucket = Hash(key, NBuckets);
X    cp = FindCell(table->buckets[bucket], key);
X    if (cp == NULL) {
X        cp = New(cellT *);
X        cp->key = CopyString(key);
X        cp->link = table->buckets[bucket];
X        table->buckets[bucket] = cp;
X    }
X    cp->value = value;
}
X
void *Lookup(symtabADT table, string key)
{
X    int bucket;
X    cellT *cp;
X
X    bucket = Hash(key, NBuckets);
X    cp = FindCell(table->buckets[bucket], key);
X    if (cp == NULL) return(UNDEFINED);
X    return (cp->value);
}
X
void MapSymbolTable(symtabFnT fn, symtabADT table,
X                    void *clientData)
{
X    int i;
X    cellT *cp;
X
X    for (i = 0; i < NBuckets; i++) {
X        for (cp = table->buckets[i]; cp != NULL; cp = cp->link) {
X            fn(cp->key, cp->value, clientData);
X        }
X    }
}
X
/* Private functions */
X
/*
X * Function: FreeBucketChain
X * Usage: FreeBucketChain(cp);
X * ---------------------------
X * This function takes a chain pointer and frees all the cells
X * in that chain.  Because the package makes copies of the keys,
X * this function must free the string storage as well.
X */
X
static void FreeBucketChain(cellT *cp)
{
X    cellT *next;
X
X    while (cp != NULL) {
X        next = cp->link;
X        FreeBlock(cp->key);
X        FreeBlock(cp);
X        cp = next;
X    }
}
X
/*
X * Function: FindCell
X * Usage: cp = FindCell(cp, key);
X * ------------------------------
X * This function finds a cell in the chain beginning at cp that
X * matches key.  If a match is found, a pointer to that cell is
X * returned.  If no match is found, the function returns NULL.
X */
X
static cellT *FindCell(cellT *cp, string key)
{
X    while (cp != NULL && !StringEqual(cp->key, key)) {
X        cp = cp->link;
X    }
X    return (cp);
}
X
/*
X * Function: Hash
X * Usage: bucket = Hash(key, nBuckets);
X * ------------------------------------
X * This function takes the key and uses it to derive a hash code,
X * which is an integer in the range [0, nBuckets - 1].  The hash
X * code is computed using a method called linear congruence.  The
X * choice of the value for Multiplier can have a significant effect
X * on the performance of the algorithm, but not on its correctness.
X */
X
#define Multiplier -1664117991L
X
static int Hash(string s, int nBuckets)
{
X    int i;
X    unsigned long hashcode;
X
X    hashcode = 0;
X    for (i = 0; s[i] != '\0'; i++) {
X        hashcode = hashcode * Multiplier + s[i];
X    }
X    return (hashcode % nBuckets);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/11-Symbol-Tables/symtab.c' &&
  chmod 0644 'programs/11-Symbol-Tables/symtab.c' ||
  echo 'restore of programs/11-Symbol-Tables/symtab.c failed'
  shar_count="`wc -c < 'programs/11-Symbol-Tables/symtab.c'`"
  test 3983 -eq "$shar_count" ||
    echo "programs/11-Symbol-Tables/symtab.c: original size 3983, current size $shar_count"
fi
# ============= programs/11-Symbol-Tables/symtab.h ==============
if test -f 'programs/11-Symbol-Tables/symtab.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/11-Symbol-Tables/symtab.h (file already exists)'
else
  echo 'x - extracting programs/11-Symbol-Tables/symtab.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/11-Symbol-Tables/symtab.h' &&
/*
X * File: symtab.h
X * --------------
X * This interface exports a simple symbol table abstraction.
X */
X
#ifndef _symtab_h
#define _symtab_h
X
#include "genlib.h"
X
/*
X * Type: symtabADT
X * ---------------
X * This type is the ADT used to represent a symbol table.
X */
X
typedef struct symtabCDT *symtabADT;
X
/*
X * Type: symtabFnT
X * ---------------
X * This type defines the class of functions that can be used to
X * map over the entries in a symbol table.
X */
X
typedef void (*symtabFnT)(string key, void *value,
X                          void *clientData);
X
/* Exported entries */
X
/*
X * Function: NewSymbolTable
X * Usage: table = NewSymbolTable();
X * --------------------------------
X * This function allocates a new symbol table with no entries.
X */
X
symtabADT NewSymbolTable(void);
X
/*
X * Function: FreeSymbolTable
X * Usage: FreeSymbolTable(table);
X * ------------------------------
X * This function frees the storage associated with the symbol table.
X */
X
void FreeSymbolTable(symtabADT table);
X
/*
X * Function: Enter
X * Usage: Enter(table, key, value);
X * --------------------------------
X * This function associates key with value in the symbol table.
X * Each call to Enter supersedes any previous definition for key.
X */
X
void Enter(symtabADT table, string key, void *value);
X
/*
X * Function: Lookup
X * Usage: value = Lookup(table, key);
X * ----------------------------------
X * This function returns the value associated with key in the symbol
X * table, or UNDEFINED, if no such value exists.
X */
X
void *Lookup(symtabADT table, string key);
X
/*
X * Function: MapSymbolTable
X * Usage: MapSymbolTable(fn, table, clientData);
X * ---------------------------------------------
X * This function goes through every entry in the symbol table
X * and calls the function fn, passing it the following arguments:
X * the current key, its associated value, and the clientData
X * pointer.  The clientData pointer allows the client to pass
X * additional state information to the function fn, if necessary.
X * If no clientData argument is required, this value should be NULL.
X */
X
void MapSymbolTable(symtabFnT fn, symtabADT table,
X                    void *clientData);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/11-Symbol-Tables/symtab.h' &&
  chmod 0644 'programs/11-Symbol-Tables/symtab.h' ||
  echo 'restore of programs/11-Symbol-Tables/symtab.h failed'
  shar_count="`wc -c < 'programs/11-Symbol-Tables/symtab.h'`"
  test 2165 -eq "$shar_count" ||
    echo "programs/11-Symbol-Tables/symtab.h: original size 2165, current size $shar_count"
fi
# ============= programs/11-Symbol-Tables/symtest.c ==============
if test -f 'programs/11-Symbol-Tables/symtest.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/11-Symbol-Tables/symtest.c (file already exists)'
else
  echo 'x - extracting programs/11-Symbol-Tables/symtest.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/11-Symbol-Tables/symtest.c' &&
/*
X * File: symtest.c
X * ---------------
X * This program tests the symbol table abstraction.  The user
X * types in command lines, which are assumed to be in one of
X * the following forms:
X *
X *    key               Display the current value of key
X *    key = value       Enter new value for key
X *    quit              Exit from the program
X */
X
#include <stdio.h>
#include <ctype.h>
#include "genlib.h"
#include "strlib.h"
#include "simpio.h"
#include "symtab.h"
#include "scanadt.h"
X
/* Main program */
X
main()
{
X    symtabADT table;
X    scannerADT scanner;
X    string line, name, value;
X
X    table = NewSymbolTable();
X    scanner = NewScanner();
X    SetScannerSpaceOption(scanner, IgnoreSpaces);
X    while (TRUE) {
X        printf("-> ");
X        line = GetLine();
X        if (StringEqual(line, "quit")) break;
X        SetScannerString(scanner, line);
X        name = ReadToken(scanner);
X        if (MoreTokensExist(scanner)) {
X            if (!StringEqual(ReadToken(scanner), "=")) {
X                Error("Missing equal sign in assignment");
X            }
X            value = ReadToken(scanner);
X            if (MoreTokensExist(scanner)) {
X                Error("Statement contains additional data");
X            }
X            Enter(table, name, value);
X        } else {
X            value = Lookup(table, name);
X            if (value == UNDEFINED) {
X                printf("'%s' is undefined.\n", name);
X            } else {
X                printf("%s\n", value);
X            }
X        }
X    }
X    FreeSymbolTable(table);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/11-Symbol-Tables/symtest.c' &&
  chmod 0644 'programs/11-Symbol-Tables/symtest.c' ||
  echo 'restore of programs/11-Symbol-Tables/symtest.c failed'
  shar_count="`wc -c < 'programs/11-Symbol-Tables/symtest.c'`"
  test 1528 -eq "$shar_count" ||
    echo "programs/11-Symbol-Tables/symtest.c: original size 1528, current size $shar_count"
fi
# ============= programs/11-Symbol-Tables/wordfreq.c ==============
if test -f 'programs/11-Symbol-Tables/wordfreq.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/11-Symbol-Tables/wordfreq.c (file already exists)'
else
  echo 'x - extracting programs/11-Symbol-Tables/wordfreq.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/11-Symbol-Tables/wordfreq.c' &&
/*
X * File: wordfreq.c
X * ----------------
X * This program goes through a file and keeps track of how
X * often each word appears.  When the input is exhausted, the
X * program displays a table of the words and their frequency.
X */
X
#include <stdio.h>
#include <ctype.h>
#include "genlib.h"
#include "strlib.h"
#include "simpio.h"
#include "scanadt.h"
#include "symtab.h"
#include "iterator.h"
X
/*
X * Type: counterT
X * --------------
X * This type is used to record the count of each word in the
X * symbol table, which requires that values be pointers.
X */
X
typedef struct {
X    int count;
} *counterT;
X
/* Private function prototypes */
X
static void RecordWord(symtabADT table, string word);
static void DisplayWordFrequencies(symtabADT table);
X
/* Main program */
X
main()
{
X    FILE *infile;
X    string line, token, filename;
X    scannerADT scanner;
X    symtabADT table;
X
X    scanner = NewScanner();
X    table = NewSymbolTable();
X    printf("Input file: ");
X    filename = GetLine();
X    infile = fopen(filename, "r");
X    if (infile == NULL) Error("Can't open %s", filename);
X    while ((line = ReadLine(infile)) != NULL) {
X        SetScannerString(scanner, ConvertToLowerCase(line));
X        while (MoreTokensExist(scanner)) {
X            token = ReadToken(scanner);
X            if (isalpha(token[0])) RecordWord(table, token);
X        }
X    }
X    fclose(infile);
X    DisplayWordFrequencies(table);
}
X
/*
X * Function: RecordWord
X * Usage: RecordWord(table, word);
X * -------------------------------
X * This function records the fact that another instance of
X * word has appeared.  The implementation looks up the word
X * in the symbol table and increments the corresponding
X * count, creating a new entry if necessary.
X */
X
static void RecordWord(symtabADT table, string word)
{
X    counterT entry;
X
X    entry = Lookup(table, word);
X    if (entry == UNDEFINED) {
X        entry = New(counterT);
X        entry->count = 0;
X        Enter(table, word, entry);
X    }
X    entry->count++;
}
X
/*
X * Function: DisplayWordFrequencies
X * Usage: DisplayWordFrequencies(table);
X * -------------------------------------
X * This function displays the count associated with each word
X * in the table.
X */
X
static void DisplayWordFrequencies(symtabADT table)
{
X    iteratorADT iterator;
X    counterT entry;
X    string key;
X
X    printf("Word frequency table:\n");
X    iterator = NewIterator(table);
X    while (StepIterator(iterator, &key)) {
X        entry = Lookup(table, key);
X        printf("%-15s%5d\n", key, entry->count);
X    }
X    FreeIterator(iterator);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/11-Symbol-Tables/wordfreq.c' &&
  chmod 0644 'programs/11-Symbol-Tables/wordfreq.c' ||
  echo 'restore of programs/11-Symbol-Tables/wordfreq.c failed'
  shar_count="`wc -c < 'programs/11-Symbol-Tables/wordfreq.c'`"
  test 2545 -eq "$shar_count" ||
    echo "programs/11-Symbol-Tables/wordfreq.c: original size 2545, current size $shar_count"
fi
# ============= programs/11-Symbol-Tables/Makefile ==============
if test -f 'programs/11-Symbol-Tables/Makefile' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/11-Symbol-Tables/Makefile (file already exists)'
else
  echo 'x - extracting programs/11-Symbol-Tables/Makefile (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/11-Symbol-Tables/Makefile' &&
# Makefile for programs in directory 11-Symbol-Tables
# ***************************************************************
X
PROGRAMS = \
X    cmddisp \
X    dumpfreq \
X    mapfreq \
X    plot \
X    sorttest \
X    symtest \
X    wordfreq
X
# ***************************************************************
# Parameters to control Makefile operation
# Note that the gccx command script must be defined
X
CC = gccx
CFLAGS = 
X
# ***************************************************************
# Entry to bring the package up to date
X
all: $(PROGRAMS)
X
# ***************************************************************
# Standard entries to remove files from the directories
#    tidy    -- eliminate unwanted files
#    scratch -- delete derived files in preparation for rebuild
X
tidy:
X	rm -f ,* .,* *~ core a.out graphics.ps
X
scratch: tidy
X	rm -f *.o *.a $(PROGRAMS)
X
# ***************************************************************
# C compilations
X
cmddisp.o: cmddisp.c symtab.h
X	$(CC) $(CFLAGS) -c cmddisp.c
X
cmpfn.o: cmpfn.c cmpfn.h
X	$(CC) $(CFLAGS) -c cmpfn.c
X
dumpfreq.o: dumpfreq.c scanadt.h symtab.h
X	$(CC) $(CFLAGS) -c dumpfreq.c
X
iterator.o: iterator.c iterator.h symtab.h
X	$(CC) $(CFLAGS) -c iterator.c
X
mapfreq.o: mapfreq.c scanadt.h symtab.h
X	$(CC) $(CFLAGS) -c mapfreq.c
X
plot.o: plot.c
X	$(CC) $(CFLAGS) -c plot.c
X
scanadt.o: scanadt.c scanadt.h
X	$(CC) $(CFLAGS) -c scanadt.c
X
sorttest.o: sorttest.c cmpfn.h
X	$(CC) $(CFLAGS) -c sorttest.c
X
symtab.o: symtab.c symtab.h
X	$(CC) $(CFLAGS) -c symtab.c
X
symtest.o: symtest.c scanadt.h symtab.h
X	$(CC) $(CFLAGS) -c symtest.c
X
wordfreq.o: wordfreq.c iterator.h scanadt.h symtab.h
X	$(CC) $(CFLAGS) -c wordfreq.c
X
X
# ***************************************************************
# Executable programs
X
cmddisp: cmddisp.o symtab.o
X	$(CC) $(CFLAGS) -o cmddisp cmddisp.o symtab.o
X
dumpfreq: dumpfreq.o scanadt.o symtab.o
X	$(CC) $(CFLAGS) -o dumpfreq dumpfreq.o scanadt.o symtab.o
X
mapfreq: mapfreq.o scanadt.o symtab.o
X	$(CC) $(CFLAGS) -o mapfreq mapfreq.o scanadt.o symtab.o
X
plot: plot.o
X	$(CC) $(CFLAGS) -o plot plot.o
X
sorttest: sorttest.o cmpfn.o
X	$(CC) $(CFLAGS) -o sorttest sorttest.o cmpfn.o
X
symtest: symtest.o scanadt.o symtab.o
X	$(CC) $(CFLAGS) -o symtest symtest.o scanadt.o symtab.o
X
wordfreq: wordfreq.o iterator.o scanadt.o symtab.o
X	$(CC) $(CFLAGS) -o wordfreq wordfreq.o iterator.o scanadt.o symtab.o
X
SHAR_EOF
  $shar_touch -am 0905210397 'programs/11-Symbol-Tables/Makefile' &&
  chmod 0644 'programs/11-Symbol-Tables/Makefile' ||
  echo 'restore of programs/11-Symbol-Tables/Makefile failed'
  shar_count="`wc -c < 'programs/11-Symbol-Tables/Makefile'`"
  test 2361 -eq "$shar_count" ||
    echo "programs/11-Symbol-Tables/Makefile: original size 2361, current size $shar_count"
fi
# ============= programs/12-Recursive-Lists/bigfact.c ==============
if test ! -d 'programs/12-Recursive-Lists'; then
  echo 'x - creating directory programs/12-Recursive-Lists'
  mkdir 'programs/12-Recursive-Lists'
fi
if test -f 'programs/12-Recursive-Lists/bigfact.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/12-Recursive-Lists/bigfact.c (file already exists)'
else
  echo 'x - extracting programs/12-Recursive-Lists/bigfact.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/12-Recursive-Lists/bigfact.c' &&
/*
X * File: bigfact.c
X * ---------------
X * This file defines the BigFact function, which calculates
X * the factorial of an integer but returns the result as a
X * bigIntADT so that the result can be arbitrarily large.
X * This file also includes a test program that prints the
X * factorials of the numbers between the limits LowerLimit
X * and UpperLimit, inclusive.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "bigint.h"
X
/* Constants */
X
#define LowerLimit  0
#define UpperLimit 20
X
/* Private function prototypes */
X
static bigIntADT BigFact(int n);
X
/* Main program */
X
main()
{
X    int i;
X
X    for (i = LowerLimit; i <= UpperLimit; i++) {
X        printf("%2d! = %s\n", i, BigIntToString(BigFact(i)));
X    }
}
X
/*
X * Function: BigFact
X * Usage: b = BigFact(n);
X * ----------------------
X * This function returns the factorial of n, which is defined
X * as the product of all integers from 1 up to n.
X */
X
static bigIntADT BigFact(int n)
{
X    if (n == 0) {
X        return (NewBigInt(1));
X    } else {
X        return (MultiplyBigInt(NewBigInt(n), BigFact(n - 1)));
X    }
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/12-Recursive-Lists/bigfact.c' &&
  chmod 0644 'programs/12-Recursive-Lists/bigfact.c' ||
  echo 'restore of programs/12-Recursive-Lists/bigfact.c failed'
  shar_count="`wc -c < 'programs/12-Recursive-Lists/bigfact.c'`"
  test 1082 -eq "$shar_count" ||
    echo "programs/12-Recursive-Lists/bigfact.c: original size 1082, current size $shar_count"
fi
# ============= programs/12-Recursive-Lists/bigint.c ==============
if test -f 'programs/12-Recursive-Lists/bigint.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/12-Recursive-Lists/bigint.c (file already exists)'
else
  echo 'x - extracting programs/12-Recursive-Lists/bigint.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/12-Recursive-Lists/bigint.c' &&
/*
X * File: bigint.c
X * --------------
X * This file implements the bigint.h interface, which provides
X * addition and multiplication operations for nonnegative
X * integers of arbitrary size.
X */
X
#include <stdio.h>
#include <ctype.h>
#include "genlib.h"
#include "strlib.h"
#include "bigint.h"
X
/*
X * Type: bigIntCDT
X * ---------------
X * This type is the concrete counterpart of the abstract type
X * bigIntADT.  The underlying representation is a linked list
X * of cells, each of which contains a single digit.  The digits
X * in the list appear in reverse order, with the units digit at
X * the beginning of the list, the tens digit next, and so on.
X * In its recursive formulation, a bigIntADT is either
X *
X * 1. NULL, representing the integer 0, or
X * 2. A digit d and a bigIntADT n, representing 10 * n + d
X */
X
struct bigIntCDT {
X    int finalDigit;
X    bigIntADT leadingDigits;
};
X
/* Private function prototypes */
X
static bigIntADT AddWithCarry(bigIntADT n1, bigIntADT n2, int carry);
static bigIntADT MultiplyDigit(int digit, bigIntADT n);
static bigIntADT DigitCons(bigIntADT n, int digit);
static bigIntADT LeadingDigits(bigIntADT n);
static int FinalDigit(bigIntADT n);
X
/* Exported entries */
X
bigIntADT NewBigInt(int i)
{
X    if (i < 0) Error("Negative integers are not permitted");
X    if (i == 0) return (NULL);
X    return (DigitCons(NewBigInt(i / 10), i % 10));
}
X
bigIntADT StringToBigInt(string str)
{
X    int len;
X    char ch;
X
X    len = StringLength(str);
X    if (len == 0) return (NULL);
X    ch = str[len - 1];
X    if (!isdigit(ch)) Error("Illegal digit %c", ch);
X    return (DigitCons(StringToBigInt(SubString(str, 0, len - 2)),
X                      ch - '0'));
}
X
string BigIntToString(bigIntADT n)
{
X    string str;
X
X    str = CharToString(FinalDigit(n) + '0');
X    if (LeadingDigits(n) != NULL) {
X        str = Concat(BigIntToString(LeadingDigits(n)), str);
X    }
X    return (str);
}
X
/*
X * Implementation notes: AddBigInt
X * -------------------------------
X * The AddBigInt function itself is a simple wrapper that calls
X * AddWithCarry to do the real work.   The third argument to
X * AddWithCarry is the carry from the preceding digit position.
X */
X
bigIntADT AddBigInt(bigIntADT n1, bigIntADT n2)
{
X    return (AddWithCarry(n1, n2, 0));
}
X
static bigIntADT AddWithCarry(bigIntADT n1, bigIntADT n2, int carry)
{
X    int sum;
X    bigIntADT p1, p2;
X
X    p1 = LeadingDigits(n1);
X    p2 = LeadingDigits(n2);
X    sum = FinalDigit(n1) + FinalDigit(n2) + carry;
X    if (sum == 0 && p1 == NULL && p2 == NULL) return (NULL);
X    return (DigitCons(AddWithCarry(p1, p2, sum / 10), sum % 10));
}
X
/*
X * Function: MultiplyBigInt
X * ------------------------
X * The MultiplyBigInt implementation uses the standard
X * elementary-school algorithm of multiplying by each
X * digit in turn, except that the algorithm is implemented
X * recursively here.  The recursive insight is that the
X * product of n1 and n2 is
X *
X *   FinalDigit(n1) * n2 + LeadingDigits(n1) * n2 * 10
X *
X * Note that multiplying by 10 is implemented simply by
X * adding a 0 to the number using DigitCons.  Single-digit
X * multiplication is implemented by recursive addition.
X */
X
bigIntADT MultiplyBigInt(bigIntADT n1, bigIntADT n2)
{
X    if (n1 == NULL) return (NULL);
X    return (AddBigInt(MultiplyDigit(FinalDigit(n1), n2),
X                      MultiplyBigInt(LeadingDigits(n1),
X                                     DigitCons(n2, 0))));
}
X
static bigIntADT MultiplyDigit(int digit, bigIntADT n)
{
X    if (digit == 0) return (NULL);
X    return (AddBigInt(n, MultiplyDigit(digit - 1, n)));
}
X
/*
X * Function: DigitCons
X * Usage: n = DigitCons(leadingDigits, finalDigit);
X * ------------------------------------------------
X * This low-level constructor function combines leadingDigits
X * and finalDigit to make a new bigIntADT.  Note that the
X * direction of this function is opposite to that of ListCons
X * in that finalDigit is added to the beginning of the linked
X * list.  The reason for using this argument order is that
X * doing so makes it easier to understand the function in
X * its arithmetic sense: finalDigit is added to the end of
X * leadingDigits.  The implementation also includes a check
X * to make sure that 0 is always represented as NULL.
X */
X
static bigIntADT DigitCons(bigIntADT leadingDigits, int finalDigit)
{
X    bigIntADT cp;
X
X    if (leadingDigits == NULL && finalDigit == 0) return (NULL);
X    cp = New(bigIntADT);
X    cp->finalDigit = finalDigit;
X    cp->leadingDigits = leadingDigits;
X    return (cp);
}
X
/*
X * Functions: LeadingDigits, FinalDigit
X * Usage: prefix = LeadingDigits(n);
X *        last = FinalDigit(n);
X * ------------------------------------
X * These functions select the leading digits and final digit
X * of a bigIntADT, respectively.  Because these functions are
X * defined locally in the implementation, callers could select
X * the fields directly.  However, by making these functions,
X * the special-case handling of NULL as 0 becomes much easier
X * to implement.
X */
X
static bigIntADT LeadingDigits(bigIntADT n)
{
X    return ((n == NULL) ? NULL : n->leadingDigits);
}
X
static int FinalDigit(bigIntADT n)
{
X    return ((n == NULL) ? 0 : n->finalDigit);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/12-Recursive-Lists/bigint.c' &&
  chmod 0644 'programs/12-Recursive-Lists/bigint.c' ||
  echo 'restore of programs/12-Recursive-Lists/bigint.c failed'
  shar_count="`wc -c < 'programs/12-Recursive-Lists/bigint.c'`"
  test 5184 -eq "$shar_count" ||
    echo "programs/12-Recursive-Lists/bigint.c: original size 5184, current size $shar_count"
fi
# ============= programs/12-Recursive-Lists/bigint.h ==============
if test -f 'programs/12-Recursive-Lists/bigint.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/12-Recursive-Lists/bigint.h (file already exists)'
else
  echo 'x - extracting programs/12-Recursive-Lists/bigint.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/12-Recursive-Lists/bigint.h' &&
/*
X * File: bigint.h
X * --------------
X * This interface is a primitive version of a facility intended
X * to support integers of an arbitrary size. This package has the
X * following limitations, which significantly reduce its utility:
X *
X * 1. The package does not support negative integers.
X * 2. The only operations are addition and multiplication.
X * 3. It is inefficient in terms of both space and time.
X */
X
#ifndef _bigint_h
#define _bigint_h
X
#include "genlib.h"
X
/*
X * Type: bigIntADT
X * ---------------
X * This type is the abstract type used to store a nonnegative
X * integer of arbitrary size.
X */
X
typedef struct bigIntCDT *bigIntADT;
X
/*
X * Function: NewBigInt
X * Usage: n = NewBigInt(i);
X * ------------------------
X * This function creates a new bigIntADT with the value i.  Use
X * StringToBigInt to create bigIntADTs larger than an integer.
X */
X
bigIntADT NewBigInt(int i);
X
/*
X * Functions: StringToBigInt, BigIntToString
X * Usage: n = StringToBigInt(str);
X *        str = BigIntToString(n);
X * -----------------------------------------
X * These functions convert between strings of digits and values
X * of type bigIntADT.
X */
X
bigIntADT StringToBigInt(string str);
string BigIntToString(bigIntADT n);
X
/*
X * Function: AddBigInt
X * Usage: n = AddBigInt(n1, n2);
X * -----------------------------
X * This function allocates a new bigIntADT n whose value is
X * the sum of n1 and n2.
X */
X
bigIntADT AddBigInt(bigIntADT n1, bigIntADT n2);
X
/*
X * Function: MultiplyBigInt
X * Usage: n = MultiplyBigInt(n1, n2);
X * ----------------------------------
X * This function allocates a new bigIntADT n whose value is
X * the product of n1 and n2.
X */
X
bigIntADT MultiplyBigInt(bigIntADT n1, bigIntADT n2);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/12-Recursive-Lists/bigint.h' &&
  chmod 0644 'programs/12-Recursive-Lists/bigint.h' ||
  echo 'restore of programs/12-Recursive-Lists/bigint.h failed'
  shar_count="`wc -c < 'programs/12-Recursive-Lists/bigint.h'`"
  test 1714 -eq "$shar_count" ||
    echo "programs/12-Recursive-Lists/bigint.h: original size 1714, current size $shar_count"
fi
# ============= programs/12-Recursive-Lists/list.c ==============
if test -f 'programs/12-Recursive-Lists/list.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/12-Recursive-Lists/list.c (file already exists)'
else
  echo 'x - extracting programs/12-Recursive-Lists/list.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/12-Recursive-Lists/list.c' &&
/*
X * File: list.c
X * ------------
X * This file implements the list.h interface, which defines
X * an immutable abstraction for manipulating lists of values.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "list.h"
X
/*
X * Type: listCDT
X * -------------
X * The type listCDT is the concrete representation of the type
X * listADT defined by the interface.  Because the list exported
X * by this interface is immutable, there is no need for an extra
X * level of structure.  Thus, the concrete list type is just a
X * linked-list cell containing an element and another list.
X */
X
struct listCDT {
X    listElementT head;
X    listADT tail;
};
X
/* Exported entries */
X
listADT ListCons(listElementT head, listADT tail)
{
X    listADT list;
X
X    list = New(listADT);
X    list->head = head;
X    list->tail = tail;
X    return (list);
}
X
listElementT ListHead(listADT list)
{
X    if (list == NULL) Error("ListHead called on NULL list");
X    return (list->head);
}
X
listADT ListTail(listADT list)
{
X    if (list == NULL) Error("ListTail called on NULL list");
X    return (list->tail);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/12-Recursive-Lists/list.c' &&
  chmod 0644 'programs/12-Recursive-Lists/list.c' ||
  echo 'restore of programs/12-Recursive-Lists/list.c failed'
  shar_count="`wc -c < 'programs/12-Recursive-Lists/list.c'`"
  test 1075 -eq "$shar_count" ||
    echo "programs/12-Recursive-Lists/list.c: original size 1075, current size $shar_count"
fi
# ============= programs/12-Recursive-Lists/list.h ==============
if test -f 'programs/12-Recursive-Lists/list.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/12-Recursive-Lists/list.h (file already exists)'
else
  echo 'x - extracting programs/12-Recursive-Lists/list.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/12-Recursive-Lists/list.h' &&
/*
X * File: list.h
X * ------------
X * This interface defines an abstraction for an immutable list.
X */
X
#ifndef _list_h
#define _list_h
X
#include "genlib.h"
X
/*
X * Type: listElementT
X * ------------------
X * The type listElementT is used in this interface to indicate
X * the type of values that can be stored in the list.  Here the
X * list is used to store values of type void *, but that can
X * be changed by editing this definition line.
X */
X
typedef void *listElementT;
X
/*
X * Type: listADT
X * -------------
X * The type listADT represents the abstract type used to represent
X * the list itself.  The empty list is always represented by NULL.
X * The client can rely on the following aspects of the internal
X * structure:
X *
X * 1. Each list value returned is dynamically allocated.
X *
X * 2. The list element is stored at the beginning of the
X *    structure used internally to hold the record so that
X *    the address of the list cell is also the address of the
X *    stored value.  This constraint makes it possible to apply
X *    comparison functions to the stored data.
X */
X
typedef struct listCDT *listADT;
X
/*
X * Function: ListCons
X * Usage: list = ListCons(head, tail);
X * -----------------------------------
X * This function allocates and returns a new list, which consists
X * of the element head followed by the list tail.
X */
X
listADT ListCons(listElementT head, listADT tail);
X
/*
X * Functions: ListHead, ListTail
X * Usage: head = ListHead(list);
X *        tail = ListTail(list);
X * -----------------------------
X * These functions return the head and tail of a list, where the
X * head is defined to be the first element and the tail is the
X * list that remains after removing the head of the list.
X */
X
listElementT ListHead(listADT list);
listADT ListTail(listADT list);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/12-Recursive-Lists/list.h' &&
  chmod 0644 'programs/12-Recursive-Lists/list.h' ||
  echo 'restore of programs/12-Recursive-Lists/list.h failed'
  shar_count="`wc -c < 'programs/12-Recursive-Lists/list.h'`"
  test 1793 -eq "$shar_count" ||
    echo "programs/12-Recursive-Lists/list.h: original size 1793, current size $shar_count"
fi
# ============= programs/12-Recursive-Lists/listtest.c ==============
if test -f 'programs/12-Recursive-Lists/listtest.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/12-Recursive-Lists/listtest.c (file already exists)'
else
  echo 'x - extracting programs/12-Recursive-Lists/listtest.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/12-Recursive-Lists/listtest.c' &&
/*
X * File: listtest.c
X * ----------------
X * This program tests the list package by allowing the user to
X * enter a series of commands that manipulate a single global
X * list. The commands are listed in the function HelpCmd.
X */
X
#include <stdio.h>
#include <ctype.h>
#include "genlib.h"
#include "simpio.h"
#include "strlib.h"
#include "scanadt.h"
#include "list.h"
X
/*
X * Type: dataBlockT
X * ----------------
X * This type is used to define a data block for the operation
X * of the program that makes it easier to decompose the code
X * into separate functions.  For details on the test program
X * operation, please see the function HelpCmd.
X */
X
typedef struct {
X    listADT variables[26];
X    scannerADT scanner;
} *dataBlockT;
X
/* Private function prototypes */
X
static void HelpCmd(void);
static void ParseOperation(dataBlockT db, string lhs);
static void SelectionOperation(dataBlockT db, string lhs);
static void LengthOperation(dataBlockT db, string lhs);
static void HeadOperation(dataBlockT db, string lhs);
static void TailOperation(dataBlockT db, string lhs);
static void ConsOperation(dataBlockT db, string lhs);
static void ConcatOperation(dataBlockT db, string lhs);
static dataBlockT NewDataBlock(void);
static bool IsVariableName(string token);
static void CheckForToken(scannerADT scanner, string expected);
static void *GetValue(dataBlockT db, string var);
static void SetValue(dataBlockT db, string var, void *value);
static int ListLength(listADT list);
static listADT ListConcat(listADT list1, listADT list2);
static listElementT NthElement(listADT list, int n);
static void DisplayStringList(listADT list);
static void RecDisplayList(listADT list);
X
/* Main program */
X
main()
{
X    dataBlockT db;
X    string line, cmd, token, var;
X    int pos;
X    printf("List structure test program\n");
X    printf("Type \"help\" for help\n");
X    db = NewDataBlock();
X    while (TRUE) {
X        printf(">");
X        line = GetLine();
X        SetScannerString(db->scanner, line);
X        cmd = ConvertToLowerCase(ReadToken(db->scanner));
X        if (IsVariableName(cmd)) {
X            var = cmd;
X            token = ReadToken(db->scanner);
X            if (StringEqual(token, "")) {
X                DisplayStringList(GetValue(db, var));
X            } else if (StringEqual(token, "=")) {
X                ParseOperation(db, var);
X            } else {
X                Error("Unexpected token %s", token);
X            }
X        } else if (StringEqual(cmd, "help")) {
X            HelpCmd();
X        } else if (StringEqual(cmd, "quit")) {
X            break;
X        } else {
X            SaveToken(db->scanner, cmd);
X            ParseOperation(db, NULL);
X        }
X    }
}
X
static void HelpCmd(void)
{
X    printf("Enter commands in the following forms, where x, y, and z\n");
X    printf("represent list variables named with a single letter:\n");
X    printf("  NthElement(x, n) -- Display nth element of x\n");
X    printf("  Length(x)        -- Display length of x\n");
X    printf("  Head(x)          -- Display head of x\n");
X    printf("* Tail(x)          -- Display tail of x\n");
X    printf("* Cons(id, x)      -- Add id to front of x\n");
X    printf("* Concat(x, y)     -- Concatenate lists x and y\n");
X    printf("* x                -- Display value of x\n");
X    printf("  quit             -- Exit from the program\n\n");
X    printf("The command forms marked with a * may be preceded\n");
X    printf("by a variable name and an equal sign to indicate\n");
X    printf("assignment.\n\n");
}
X
static void ParseOperation(dataBlockT db, string lhs)
{
X    string token;
X
X    token = ConvertToLowerCase(ReadToken(db->scanner));
X    if (StringEqual(token, "nthelement")) {
X        SelectionOperation(db, lhs);
X    } else if (StringEqual(token, "length")) {
X        LengthOperation(db, lhs);
X    } else if (StringEqual(token, "head")) {
X        HeadOperation(db, lhs);
X    } else if (StringEqual(token, "tail")) {
X        TailOperation(db, lhs);
X    } else if (StringEqual(token, "cons")) {
X        ConsOperation(db, lhs);
X    } else if (StringEqual(token, "concat")) {
X        ConcatOperation(db, lhs);
X    } else if (IsVariableName(token)) {
X        if (lhs == NULL) Error("Null lhs in assignment");
X        SetValue(db, lhs, GetValue(db, token));
X    } else {
X        Error("Illegal operation %s", token);
X    }
}
X
static void SelectionOperation(dataBlockT db, string lhs)
{
X    string var;
X    int pos;
X
X    if (lhs != NULL) Error("NthElement result cannot be assigned");
X    CheckForToken(db->scanner, "(");
X    var = ConvertToLowerCase(ReadToken(db->scanner));
X    CheckForToken(db->scanner, ",");
X    pos = StringToInteger(ReadToken(db->scanner));
X    CheckForToken(db->scanner, ")");
X    printf("%s\n", NthElement(GetValue(db, var), pos));
}
X
static void LengthOperation(dataBlockT db, string lhs)
{
X    string var;
X
X    if (lhs != NULL) Error("Length result cannot be assigned");
X    CheckForToken(db->scanner, "(");
X    var = ConvertToLowerCase(ReadToken(db->scanner));
X    CheckForToken(db->scanner, ")");
X    printf("%d\n", ListLength(GetValue(db, var)));
}
X
static void HeadOperation(dataBlockT db, string lhs)
{
X    string var;
X
X    if (lhs != NULL) Error("Head result cannot be assigned");
X    CheckForToken(db->scanner, "(");
X    var = ConvertToLowerCase(ReadToken(db->scanner));
X    CheckForToken(db->scanner, ")");
X    printf("%s\n", ListHead(GetValue(db, var)));
}
X
static void TailOperation(dataBlockT db, string lhs)
{
X    listADT result;
X    string var;
X
X    CheckForToken(db->scanner, "(");
X    var = ConvertToLowerCase(ReadToken(db->scanner));
X    CheckForToken(db->scanner, ")");
X    result = ListTail(GetValue(db, var));
X    if (lhs == NULL) {
X        DisplayStringList(result);
X    } else {
X        SetValue(db, lhs, result);
X    }
}
X
static void ConsOperation(dataBlockT db, string lhs)
{
X    listADT result;
X    string id, var;
X
X    CheckForToken(db->scanner, "(");
X    id = ReadToken(db->scanner);
X    CheckForToken(db->scanner, ",");
X    var = ConvertToLowerCase(ReadToken(db->scanner));
X    CheckForToken(db->scanner, ")");
X    result = ListCons(id, GetValue(db, var));
X    if (lhs == NULL) {
X        DisplayStringList(result);
X    } else {
X        SetValue(db, lhs, result);
X    }
}
X
static void ConcatOperation(dataBlockT db, string lhs)
{
X    listADT result;
X    string v1, v2;
X
X    CheckForToken(db->scanner, "(");
X    v1 = ConvertToLowerCase(ReadToken(db->scanner));
X    CheckForToken(db->scanner, ",");
X    v2 = ConvertToLowerCase(ReadToken(db->scanner));
X    CheckForToken(db->scanner, ")");
X    result = ListConcat(GetValue(db, v1), GetValue(db, v2));
X    if (lhs == NULL) {
X        DisplayStringList(result);
X    } else {
X        SetValue(db, lhs, result);
X    }
}
X
static dataBlockT NewDataBlock(void)
{
X    dataBlockT db;
X    int i;
X
X    db = New(dataBlockT);
X    db->scanner = NewScanner();
X    SetScannerSpaceOption(db->scanner, IgnoreSpaces);
X    for (i = 0; i < 26; i++) {
X        db->variables[i] = NULL;
X    }
X    return (db);
}
X
static bool IsVariableName(string token)
{
X    if (StringEqual(token, "null")) return (TRUE);
X    return (StringLength(token) == 1 && isalpha(token[0]));
}
X
static void CheckForToken(scannerADT scanner, string expected)
{
X    string token;
X
X    token = ReadToken(scanner);
X    if (!StringEqual(token, expected)) {
X        Error("Found '%s' when expecting '%s'", token, expected);
X    }
}
X
static void *GetValue(dataBlockT db, string var)
{
X    if (StringEqual(var, "null")) return (NULL);
X    if (!IsVariableName(var)) {
X        Error("Illegal variable name '%s'", var);
X    }
X    return (db->variables[var[0] - 'a']);
}
X
static void SetValue(dataBlockT db, string var, void *value)
{
X    if (StringEqual(var, "null")) {
X        Error("Cannot change the constant NULL");
X    }
X    if (!IsVariableName(var)) {
X        Error("Illegal variable name '%s'", var);
X    }
X    db->variables[var[0] - 'a'] = value;
}
X
static int ListLength(listADT list)
{
X    if (list == NULL) {
X        return (0);
X    } else {
X        return (ListLength(ListTail(list)) + 1);
X    }
}
X
static listADT ListConcat(listADT list1, listADT list2)
{
X    if (list1 == NULL) {
X        return (list2);
X    } else {
X        return (ListCons(ListHead(list1),
X                         ListConcat(ListTail(list1), list2)));
X    }
}
X
static listElementT NthElement(listADT list, int n)
{
X    if (list == NULL) {
X        Error("NthElement: No such element");
X    } else if (n == 0) {
X        return (ListHead(list));
X    } else {
X        return (NthElement(ListTail(list), n - 1));
X    }
}
X
static void DisplayStringList(listADT list)
{
X    printf("(");
X    RecDisplayList(list);
X    printf(")\n");
}
X
static void RecDisplayList(listADT list)
{
X    if (list != NULL) {
X        printf("%s", ListHead(list));
X        if (ListTail(list) != NULL) printf(" ");
X        RecDisplayList(ListTail(list));
X    }
}
SHAR_EOF
  $shar_touch -am 0905211297 'programs/12-Recursive-Lists/listtest.c' &&
  chmod 0644 'programs/12-Recursive-Lists/listtest.c' ||
  echo 'restore of programs/12-Recursive-Lists/listtest.c failed'
  shar_count="`wc -c < 'programs/12-Recursive-Lists/listtest.c'`"
  test 8842 -eq "$shar_count" ||
    echo "programs/12-Recursive-Lists/listtest.c: original size 8842, current size $shar_count"
fi
# ============= programs/12-Recursive-Lists/scanadt.c ==============
if test -f 'programs/12-Recursive-Lists/scanadt.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/12-Recursive-Lists/scanadt.c (file already exists)'
else
  echo 'x - extracting programs/12-Recursive-Lists/scanadt.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/12-Recursive-Lists/scanadt.c' &&
/*
X * File: scanadt.c
X * ---------------
X * This file implements the scanadt.h interface.
X */
X
#include <stdio.h>
#include <ctype.h>
#include "genlib.h"
#include "strlib.h"
#include "scanadt.h"
X
/*
X * Type: scannerCDT
X * ----------------
X * This structure is the concrete representation of the type
X * scannerADT, which is exported by this interface.  Its purpose
X * is to maintain the state of the scanner between calls.  The
X * details of the representation are invisible to the client,
X * but consist of the following fields:
X *
X * str          -- Copy of string passed to SetScannerString
X * len          -- Length of string, saved for efficiency
X * cp           -- Current character position in the string
X * savedToken   -- String saved by SaveToken (NULL indicates none)
X * spaceOption  -- Setting of the space option extension
X * numberOption -- Setting of the number option extension
X * stringOption -- Setting of string option extension
X */
X
struct scannerCDT {
X    string str;
X    int len;
X    int cp;
X    string savedToken;
X    spaceOptionT spaceOption;
X    numberOptionT numberOption;
X    stringOptionT stringOption;
};
X
/* Private function prototypes */
X
static void SkipSpaces(scannerADT scanner);
static int ScanToEndOfIdentifier(scannerADT scanner);
static int ScanToEndOfInteger(scannerADT scanner);
static int ScanToEndOfReal(scannerADT scanner);
static string ScanQuotedString(scannerADT scanner);
static char ScanEscapeCharacter(scannerADT scanner);
X
/* Exported entries */
X
scannerADT NewScanner(void)
{
X    scannerADT scanner;
X
X    scanner = New(scannerADT);
X    scanner->str = NULL;
X    scanner->spaceOption = PreserveSpaces;
X    scanner->numberOption = ScanNumbersAsLetters;
X    scanner->stringOption = ScanQuotesAsPunctuation;
X    return (scanner);
}
X
void FreeScanner(scannerADT scanner)
{
X    if (scanner->str != NULL) FreeBlock(scanner->str);
X    FreeBlock(scanner);
}
X
void SetScannerString(scannerADT scanner, string str)
{
X    if (scanner->str != NULL) FreeBlock(scanner->str);
X    scanner->str = CopyString(str);
X    scanner->len = StringLength(str);
X    scanner->cp = 0;
X    scanner->savedToken = NULL;
}
X
string ReadToken(scannerADT scanner)
{
X    char ch;
X    string token;
X    int start, finish;
X
X    if (scanner->str == NULL) {
X        Error("SetScannerString has not been called");
X    }
X    if (scanner->savedToken != NULL) {
X        token = scanner->savedToken;
X        scanner->savedToken = NULL;
X        return (token);
X    }
X    if (scanner->spaceOption == IgnoreSpaces) SkipSpaces(scanner);
X    start = finish = scanner->cp;
X    if (start >= scanner->len) return (CopyString(""));
X    ch = scanner->str[scanner->cp];
X    if (scanner->stringOption == ScanQuotesAsStrings
X            && ch == '"') {
X        return (ScanQuotedString(scanner));
X    }
X    if (isdigit(ch)) {
X        switch (scanner->numberOption) {
X          case ScanNumbersAsLetters:
X            finish = ScanToEndOfIdentifier(scanner);
X            break;
X          case ScanNumbersAsIntegers:
X            finish = ScanToEndOfInteger(scanner);
X            break;
X          case ScanNumbersAsReals:
X            finish = ScanToEndOfReal(scanner);
X            break;
X        }
X    } else if (isalnum(ch)) {
X        finish = ScanToEndOfIdentifier(scanner);
X    } else {
X        scanner->cp++;
X    }
X    return (SubString(scanner->str, start, finish));
}
X
bool MoreTokensExist(scannerADT scanner)
{
X    if (scanner->str == NULL) {
X        Error("SetScannerString has not been called");
X    }
X    if (scanner->savedToken != NULL) {
X        return (!StringEqual(scanner->savedToken, ""));
X    }
X    if (scanner->spaceOption == IgnoreSpaces) SkipSpaces(scanner);
X    return (scanner->cp < scanner->len);
}
X
void SaveToken(scannerADT scanner, string token)
{
X    if (scanner->str == NULL) {
X        Error("SetScannerString has not been called");
X    }
X    if (scanner->savedToken != NULL) {
X        Error("Token has already been saved");
X    }
X    scanner->savedToken = token;
}
X
void SetScannerSpaceOption(scannerADT scanner, spaceOptionT option)
{
X    scanner->spaceOption = option;
}
X
spaceOptionT GetScannerSpaceOption(scannerADT scanner)
{
X    return (scanner->spaceOption);
}
X
void SetScannerNumberOption(scannerADT scanner, numberOptionT option)
{
X    scanner->numberOption = option;
}
X
numberOptionT GetScannerNumberOption(scannerADT scanner)
{
X    return (scanner->numberOption);
}
X
void SetScannerStringOption(scannerADT scanner, stringOptionT option)
{
X    scanner->stringOption = option;
}
X
stringOptionT GetScannerStringOption(scannerADT scanner)
{
X    return (scanner->stringOption);
}
X
/* Private functions */
X
/*
X * Function: SkipSpaces
X * Usage: SkipSpaces(scanner);
X * ---------------------------
X * This function advances the position of the scanner until the
X * current character is not a whitespace character.
X */
X
static void SkipSpaces(scannerADT scanner)
{
X    while (isspace(scanner->str[scanner->cp])) {
X        scanner->cp++;
X    }
}
X
/*
X * Function: ScanToEndOfIdentifier
X * Usage: finish = ScanToEndOfIdentifier(scanner);
X * -----------------------------------------------
X * This function advances the position of the scanner until it
X * reaches the end of a sequence of letters or digits that make
X * up an identifier.  The return value is the index of the last
X * character in the identifier; the value of the stored index
X * cp is the first character after that.
X */
X
static int ScanToEndOfIdentifier(scannerADT scanner)
{
X    while (isalnum(scanner->str[scanner->cp])) {
X        scanner->cp++;
X    }
X    return (scanner->cp - 1);
}
X
/*
X * Function: ScanToEndOfInteger
X * Usage: finish = ScanToEndOfInteger(scanner);
X * --------------------------------------------
X * This function advances the position of the scanner until it
X * reaches the end of a sequence of digits.  The return value is
X * the index of the last character in the integer; the value
X * of the stored index cp is the first character after that.
X */
X
static int ScanToEndOfInteger(scannerADT scanner)
{
X    while (isdigit(scanner->str[scanner->cp])) {
X        scanner->cp++;
X    }
X    return (scanner->cp - 1);
}
X
/*
X * Function: ScanToEndOfReal
X * Usage: finish = ScanToEndOfReal(scanner);
X * -----------------------------------------
X * This function advances the position of the scanner until it
X * reaches the end of a legal number.  The return value is the
X * index of the last character in the identifier; the value
X * of the stored index cp is the first character after that.
X *
X * The function operates by simulating what computer scientists
X * call a finite-state machine.  The program uses the variable
X * state to record the history of the process and determine
X * what characters would be legal at this point in time.
X */
X
#define InitialState        0
#define BeforeDecimalPoint  1
#define AfterDecimalPoint   2
#define StartingExponent    3
#define FoundExponentSign   4
#define ScanningExponent    5
#define FinalState         -1
X
static int ScanToEndOfReal(scannerADT scanner)
{
X    int state;
X    char ch;
X
X    state = InitialState;
X    while (state != FinalState) {
X        ch = scanner->str[scanner->cp];
X        switch (state) {
X          case InitialState:
X            if (!isdigit(ch)) Error("ScanToEndOfReal called on nonnumber");
X             state = BeforeDecimalPoint;
X            break;
X          case BeforeDecimalPoint:
X            if (ch == '.') {
X                state = AfterDecimalPoint;
X            } else if (ch == 'E' || ch == 'e') {
X                state = StartingExponent;
X            } else if (!isdigit(ch)) {
X                state = FinalState;
X            }
X            break;
X          case AfterDecimalPoint:
X            if (ch == 'E' || ch == 'e') {
X                state = StartingExponent;
X            } else if (!isdigit(ch)) {
X                state = FinalState;
X            }
X            break;
X          case StartingExponent:
X            if (ch == '+' || ch == '-') {
X                state = FoundExponentSign;
X            } else if (isdigit(ch)) {
X                state = ScanningExponent;
X            } else {
X                scanner->cp--;
X                state = FinalState;
X            }
X            break;
X          case FoundExponentSign:
X            if (isdigit(ch)) {
X                state = ScanningExponent;
X            } else {
X                scanner->cp -= 2;
X                state = FinalState;
X            }
X            break;
X          case ScanningExponent:
X            if (!isdigit(ch)) {
X                state = FinalState;
X            }
X            break;
X        }
X        if (state != FinalState) scanner->cp++;
X    }
X    return (scanner->cp - 1);
}
X
/*
X * Function: ScanQuotedString
X * Usage: str = ScanQuotedString(scanner);
X * ---------------------------------------
X * This function reads and returns a quoted string from the
X * scanner.  The current position of the scanner must be the
X * opening quotation mark.  At the end, the current position
X * marker will be set to the character position after the
X * closing quote.  The scanner generates an error if there
X * is no closing quotation mark before the end of the string.
X */
X
static string ScanQuotedString(scannerADT scanner)
{
X    string token;
X    char ch;
X
X    token = "\"";
X    scanner->cp++;
X    while ((ch = scanner->str[scanner->cp++]) != '"') {
X        if (ch == '\0') Error("Unterminated string");
X        if (ch == '\\') ch = ScanEscapeCharacter(scanner);
X        token = Concat(token, CharToString(ch));
X    }
X    return (Concat(token, "\""));
}
X
/*
X * Function: ScanEscapeCharacter
X * Usage: ch = ScanEscapeCharacter(scanner);
X * -----------------------------------------
X * This function is used by ScanQuotedString to read an escape
X * character sequence from the scanner string.  The opening
X * backslash character has already been read.  Most of the
X * complexity comes in reading the '\ddd' and '\xdd' forms.
X */
X
static char ScanEscapeCharacter(scannerADT scanner)
{
X    char ch, result;
X    int digit, base;
X
X    ch = scanner->str[scanner->cp];
X    if (isdigit(ch) || ch == 'x') {
X        base = 8;
X        if (ch == 'x') {
X            base = 16;
X            scanner->cp++;
X        }
X        result = 0;
X        while (TRUE) {
X            ch = scanner->str[scanner->cp];
X            if (isdigit(ch)) {
X                digit = ch - '0';
X            } else if (isalpha(ch)) {
X                digit = toupper(ch) - 'A' + 10;
X            } else {
X                digit = base;
X            }
X            if (digit >= base) break;
X            result = base * result + digit;
X            scanner->cp++;
X        }
X        return (result);
X    }
X    scanner->cp++;
X    switch (ch) {
X      case 'a':  return ('\a');
X      case 'b':  return ('\b');
X      case 'f':  return ('\f');
X      case 'n':  return ('\n');
X      case 'r':  return ('\r');
X      case 't':  return ('\t');
X      case 'v':  return ('\v');
X      case '\\': return ('\\');
X      case '"':  return ('"');
X    }
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/12-Recursive-Lists/scanadt.c' &&
  chmod 0644 'programs/12-Recursive-Lists/scanadt.c' ||
  echo 'restore of programs/12-Recursive-Lists/scanadt.c failed'
  shar_count="`wc -c < 'programs/12-Recursive-Lists/scanadt.c'`"
  test 10928 -eq "$shar_count" ||
    echo "programs/12-Recursive-Lists/scanadt.c: original size 10928, current size $shar_count"
fi
# ============= programs/12-Recursive-Lists/scanadt.h ==============
if test -f 'programs/12-Recursive-Lists/scanadt.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/12-Recursive-Lists/scanadt.h (file already exists)'
else
  echo 'x - extracting programs/12-Recursive-Lists/scanadt.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/12-Recursive-Lists/scanadt.h' &&
/*
X * File: scanadt.h
X * ---------------
X * This file is the interface to a module that exports an abstract
X * data type to facilitate dividing a string into logical units
X * called "tokens," which are either
X *
X * 1. Strings of consecutive letters and digits representing words
X * 2. One-character strings representing punctuation or separators
X *
X * To use this package, you must first create an instance of a
X * scannerADT by calling
X *
X *      scanner = NewScanner();
X *
X * All other calls to the scanner package take this variable as their
X * first argument to identify a particular instance of the abstract
X * scanner type.
X *
X * You initialize the scanner to hold a particular string by calling
X *
X *      SetScannerString(scanner, str);
X *
X * where str is the string from which tokens should be read.  To
X * retrieve each individual token, you make the following call:
X *
X *      token = ReadToken(scanner);
X *
X * To determine whether any tokens remain to be read, you can call
X * the predicate function MoreTokensExist(scanner).  The ReadToken
X * function returns the empty string after the last token is read.
X *
X * The following code fragment serves as an idiom for processing
X * each token in the string inputString:
X *
X *      scanner = NewScanner();
X *      SetScannerString(scanner, inputString);
X *      while (MoreTokensExist(scanner)) {
X *          token = ReadToken(scanner);
X *          . . . process the token . . .
X *      }
X *
X * This version of scanadt.h also supports the following extensions,
X * which are documented later in the interface:
X *
X *   SaveToken
X *   SetScannerSpaceOption
X *   SetScannerStringOption
X *   SetScannerNumberOption
X */
X
#ifndef _scanadt_h
#define _scanadt_h
X
#include "genlib.h"
X
/*
X * Type: scannerADT
X * ----------------
X * This type is the abstract type used to represent a single instance
X * of a scanner.  As with any abstract type, the details of the
X * internal representation are hidden from the client.
X */
X
typedef struct scannerCDT *scannerADT;
X
/*
X * Function: NewScanner
X * Usage: scanner = NewScanner();
X * ------------------------------
X * This function creates a new scanner instance.  All other functions
X * in this interface take this scanner value as their first argument
X * so that they can identify what particular instance of the scanner
X * is in use.  This design makes it possible for clients to have more
X * than one scanner process active at the same time.
X */
X
scannerADT NewScanner(void);
X
/*
X * Function: FreeScanner
X * Usage: FreeScanner(scanner);
X * ----------------------------
X * This function frees the storage associated with scanner.
X */
X
void FreeScanner(scannerADT scanner);
X
/*
X * Function: SetScannerString
X * Usage: SetScannerString(scanner, str);
X * --------------------------------------
X * This function initializes the scanner so that it will start
X * extracting tokens from the string str.
X */
X
void SetScannerString(scannerADT scanner, string str);
X
/*
X * Function: ReadToken
X * Usage: token = ReadToken(scanner);
X * ----------------------------------
X * This function returns the next token from scanner.  If
X * ReadToken is called when no tokens are available, it returns
X * the empty string.  The token returned by ReadToken is always
X * allocated in the heap, which means that clients can call
X * FreeBlock when the token is no longer needed.
X */
X
string ReadToken(scannerADT scanner);
X
/*
X * Function: MoreTokensExist
X * Usage: if (MoreTokensExist(scanner)) . . .
X * ------------------------------------------
X * This function returns TRUE as long as there are additional
X * tokens for the scanner to read.
X */
X
bool MoreTokensExist(scannerADT scanner);
X
/*
X * Function: SaveToken
X * Usage: SaveToken(scanner, token);
X * ---------------------------------
X * This function stores the token in the scanner data structure
X * in such a way that the next time ReadToken is called, it will
X * return that token without reading any additional characters
X * from the input.
X */
X
void SaveToken(scannerADT scanner, string token);
X
/*
X * Functions: SetScannerSpaceOption, GetScannerSpaceOption
X * Usage: SetScannerSpaceOption(scanner, option);
X *        option = GetScannerSpaceOption(scanner);
X * -----------------------------------------------
X * The SetScannerSpaceOption function controls whether the scanner
X * ignores whitespace characters or treats them as valid tokens.
X * By default, the ReadToken function treats whitespace characters,
X * such as spaces and tabs, just like any other punctuation mark.
X * If, however, you call
X *
X *    SetScannerSpaceOption(scanner, IgnoreSpaces);
X *
X * the scanner will skip over any white space before reading a token.
X * You can restore the original behavior by calling
X *
X *    SetScannerSpaceOption(scanner, PreserveSpaces);
X *
X * The GetScannerSpaceOption function returns the current setting
X * of this option.
X */
X
typedef enum { PreserveSpaces, IgnoreSpaces } spaceOptionT;
X
void SetScannerSpaceOption(scannerADT scanner, spaceOptionT option);
spaceOptionT GetScannerSpaceOption(scannerADT scanner);
X
/*
X * Functions: SetScannerNumberOption, GetScannerNumberOption
X * Usage: SetScannerNumberOption(scanner, option);
X *        option = GetScannerNumberOption(scanner);
X * ------------------------------------------------
X * This function controls whether the scanner treats numeric values
X * specially.  The default behavior for the scanner is to treat
X * digits as equivalent to letters.  If you call
X *
X *    SetScannerNumberOption(scanner, ScanNumbersAsIntegers);
X *
X * a token beginning with a digit will end at the first nondigit.
X * (Note that digits can still be scanned as part of a token as in
X * the token "x1".)  If you call
X *
X *    SetScannerNumberOption(scanner, ScanNumbersAsReals);
X *
X * the scanner will return the longest token string that represents
X * a real number, if the next character to be scanned is a digit.
X * The format for a real number is a sequence of digit characters
X * that may include at most one decimal point, optionally followed
X * by the letter 'E' in either upper- or lowercase, an optional sign,
X * and an exponent.  You can restore the default behavior by calling
X *
X *    SetScannerNumberOption(scanner, ScanNumbersAsLetters);
X *
X * Even if the number options are enabled, ReadToken always returns
X * its result as a string, which means that you need to call
X * StringToInteger or StringToReal to convert the token to a number.
X */
X
typedef enum {
X    ScanNumbersAsLetters,
X    ScanNumbersAsIntegers,
X    ScanNumbersAsReals
} numberOptionT;
X
void SetScannerNumberOption(scannerADT scanner, numberOptionT option);
numberOptionT GetScannerNumberOption(scannerADT scanner);
X
/*
X * Functions: SetScannerStringOption, GetScannerStringOption
X * Usage: SetScannerStringOption(scanner, option);
X *        option = GetScannerStringOption(scanner);
X * ------------------------------------------------
X * This function controls how the scanner treats double quotation
X * marks in the input.  The default behavior for the scanner is
X * to treat quotes just like any other punctuation character.
X * If, however, you call
X *
X *    SetScannerStringOption(scanner, ScanQuotesAsStrings);
X *
X * a token beginning with a quotation mark will be scanned up to
X * the closing quotation mark.  The quotation marks are returned
X * as part of the scanned token so that clients can differentiate
X * strings from other token types.  The original behavior can be
X * restored by calling
X *
X *    SetScannerStringOption(scanner, ScanQuotesAsPunctuation);
X *
X * When scanning a string, the scanner recognizes the standard
X * escape sequences from ANSI C, such as \n and \t.
X */
X
typedef enum {
X    ScanQuotesAsPunctuation,
X    ScanQuotesAsStrings
} stringOptionT;
X
void SetScannerStringOption(scannerADT scanner, stringOptionT option);
stringOptionT GetScannerStringOption(scannerADT scanner);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/12-Recursive-Lists/scanadt.h' &&
  chmod 0644 'programs/12-Recursive-Lists/scanadt.h' ||
  echo 'restore of programs/12-Recursive-Lists/scanadt.h failed'
  shar_count="`wc -c < 'programs/12-Recursive-Lists/scanadt.h'`"
  test 7862 -eq "$shar_count" ||
    echo "programs/12-Recursive-Lists/scanadt.h: original size 7862, current size $shar_count"
fi
# ============= programs/12-Recursive-Lists/Makefile ==============
if test -f 'programs/12-Recursive-Lists/Makefile' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/12-Recursive-Lists/Makefile (file already exists)'
else
  echo 'x - extracting programs/12-Recursive-Lists/Makefile (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/12-Recursive-Lists/Makefile' &&
# Makefile for programs in directory 12-Recursive-Lists
# ***************************************************************
X
PROGRAMS = \
X    bigfact \
X    listtest
X
# ***************************************************************
# Parameters to control Makefile operation
# Note that the gccx command script must be defined
X
CC = gccx
CFLAGS = 
X
# ***************************************************************
# Entry to bring the package up to date
X
all: $(PROGRAMS)
X
# ***************************************************************
# Standard entries to remove files from the directories
#    tidy    -- eliminate unwanted files
#    scratch -- delete derived files in preparation for rebuild
X
tidy:
X	rm -f ,* .,* *~ core a.out graphics.ps
X
scratch: tidy
X	rm -f *.o *.a $(PROGRAMS)
X
# ***************************************************************
# C compilations
X
bigfact.o: bigfact.c bigint.h
X	$(CC) $(CFLAGS) -c bigfact.c
X
bigint.o: bigint.c bigint.h
X	$(CC) $(CFLAGS) -c bigint.c
X
list.o: list.c list.h
X	$(CC) $(CFLAGS) -c list.c
X
listtest.o: listtest.c list.h scanadt.h
X	$(CC) $(CFLAGS) -c listtest.c
X
scanadt.o: scanadt.c scanadt.h
X	$(CC) $(CFLAGS) -c scanadt.c
X
X
# ***************************************************************
# Executable programs
X
bigfact: bigfact.o bigint.o
X	$(CC) $(CFLAGS) -o bigfact bigfact.o bigint.o
X
listtest: listtest.o list.o scanadt.o
X	$(CC) $(CFLAGS) -o listtest listtest.o list.o scanadt.o
X
SHAR_EOF
  $shar_touch -am 0905210997 'programs/12-Recursive-Lists/Makefile' &&
  chmod 0644 'programs/12-Recursive-Lists/Makefile' ||
  echo 'restore of programs/12-Recursive-Lists/Makefile failed'
  shar_count="`wc -c < 'programs/12-Recursive-Lists/Makefile'`"
  test 1438 -eq "$shar_count" ||
    echo "programs/12-Recursive-Lists/Makefile: original size 1438, current size $shar_count"
fi
# ============= programs/13-Trees/avltree.c ==============
if test ! -d 'programs/13-Trees'; then
  echo 'x - creating directory programs/13-Trees'
  mkdir 'programs/13-Trees'
fi
if test -f 'programs/13-Trees/avltree.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/13-Trees/avltree.c (file already exists)'
else
  echo 'x - extracting programs/13-Trees/avltree.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/13-Trees/avltree.c' &&
/*
X * File: avltree.c
X * ---------------
X * This file implements a self-balancing AVL tree.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "strlib.h"
#include "simpio.h"
X
/*
X * Types: nodeT, treeT
X * -------------------
X * These types define the structure of the binary search tree.
X * The type nodeT is a record that corresponds to an individual
X * node; the type treeT is simply a pointer to a node.
X */
X
typedef struct nodeT {
X    string key;
X    struct nodeT *left, *right;
X    int bf;
} nodeT, *treeT;
X
/* Private function prototypes */
X
static treeT FindNode(treeT t, string key);
static void InsertNode(treeT *tptr, string key);
static int InsertAVL(treeT *tptr, string key);
static void FixLeftImbalance(treeT *tptr);
static void FixRightImbalance(treeT *tptr);
static void RotateLeft(treeT *tptr);
static void RotateRight(treeT *tptr);
static void DisplayTree(treeT t);
static void DisplayStructure(treeT t);
static void RecDisplayStructure(treeT t, int depth, string label);
X
/* Main program */
X
main()
{
X    treeT t;
X    string key;
X
X    t = NULL;
X    while (TRUE) {
X        printf("Key: ");
X        key = GetLine();
X        if (StringEqual(key, "quit")) break;
X        InsertNode(&t, key);
X    }
X    DisplayStructure(t);
}
X
/*
X * Function: FindNode
X * Usage: np = FindNode(t, key);
X * -----------------------------
X * This function searches the tree t for a node containing key.
X * If it finds it, it returns a pointer to that node, which can
X * also be regarded as the subtree rooted at that point.  If
X * the key does not appear, FindNode returns NULL.
X */
X
static treeT FindNode(treeT t, string key)
{
X    int sign;
X
X    if (t == NULL) return (NULL);
X    sign = StringCompare(key, t->key);
X    if (sign == 0) return (t);
X    if (sign < 0) {
X        return (FindNode(t->left, key));
X    } else {
X        return (FindNode(t->right, key));
X    }
}
X
/*
X * Function: InsertNode
X * Usage: InsertNode(&t, key);
X * ---------------------------
X * This function calls InsertAVL and discards the result.
X */
X
static void InsertNode(treeT *tptr, string key)
{
X    (void) InsertAVL(tptr, key);
}
X
/*
X * Function: InsertAVL
X * Usage: delta = InsertAVL(&t, key);
X * ----------------------------------
X * This function enters the key into the tree whose address is
X * passed as the first argument.  The return value is the change
X * in depth in the tree, which is used to correct the balance
X * factors in ancestor nodes.
X */
X
static int InsertAVL(treeT *tptr, string key)
{
X    treeT t;
X    int sign, delta;
X
X    t = *tptr;
X    if (t == NULL) {
X        t = New(treeT);
X        t->key = CopyString(key);
X        t->bf = 0;
X        t->left = t->right = NULL;
X        *tptr = t;
X        return (+1);
X    }
X    sign = StringCompare(key, t->key);
X    if (sign == 0) return (0);
X    if (sign < 0) {
X        delta = InsertAVL(&t->left, key);
X        if (delta == 0) return (0);
X        switch (t->bf) {
X          case +1: t->bf =  0; return (0);
X          case  0: t->bf = -1; return (+1);
X          case -1: FixLeftImbalance(tptr); return (0);
X        }
X    } else {
X        delta = InsertAVL(&t->right, key);
X        if (delta == 0) return (0);
X        switch (t->bf) {
X          case -1: t->bf =  0; return (0);
X          case  0: t->bf = +1; return (+1);
X          case +1: FixRightImbalance(tptr); return (0);
X        }
X    }
}
X
/*
X * Function: FixLeftImbalance
X * Usage: FixLeftImbalance(&t);
X * ----------------------------
X * This function is called when a node has been found that
X * is out of balance with the longer subtree on the left.
X * Depending on the balance factor of the left child, the
X * code performs a single or double rotation.
X */
X
static void FixLeftImbalance(treeT *tptr)
{
X    treeT t, parent, child, *cptr;
X    int oldBF;
X
X    parent = *tptr;
X    cptr = &parent->left;
X    child = *cptr;
X    if (child->bf != parent->bf) {
X        oldBF = child->right->bf;
X        RotateLeft(cptr);
X        RotateRight(tptr);
X        t = *tptr;
X        t->bf = 0;
X        switch (oldBF) {
X          case -1: t->left->bf = 0; t->right->bf = +1; break;
X          case  0: t->left->bf = t->right->bf = 0; break;
X          case +1: t->left->bf = -1; t->right->bf = 0; break;
X        }
X    } else {
X        RotateRight(tptr);
X        t = *tptr;
X        t->right->bf = t->bf = 0;
X    }
}
X
/*
X * Function: RotateLeft
X * Usage: RotateLeft(&t);
X * ----------------------
X * This function performs a single left rotation of the tree
X * whose address is passed as an argument.  The balance factors
X * are unchanged by this function and must be corrected at a
X * higher level of the algorithm.
X */
X
static void RotateLeft(treeT *tptr)
{
X    treeT parent, child;
X
X    parent = *tptr;
X    child = parent->right;
X    parent->right = child->left;
X    child->left = parent;
X    (*tptr) = child;
}
X
/*
X * Functions: FixRightImbalance, RotateRight
X * -----------------------------------------
X * These functions are symmetrical to their FixLeftImbalance
X * and RotateLeft counterparts.
X */
X
static void FixRightImbalance(treeT *tptr)
{
X    treeT t, parent, child, *cptr;
X    int oldBF;
X
X    parent = *tptr;
X    cptr = &parent->right;
X    child = *cptr;
X    if (child->bf != parent->bf) {
X        oldBF = child->right->bf;
X        RotateRight(cptr);
X        RotateLeft(tptr);
X        t = *tptr;
X        t->bf = 0;
X        switch (oldBF) {
X          case -1: t->left->bf = 0; t->right->bf = +1; break;
X          case  0: t->left->bf = t->right->bf = 0; break;
X          case +1: t->left->bf = -1; t->right->bf = 0; break;
X        }
X    } else {
X        RotateLeft(tptr);
X        t = *tptr;
X        t->left->bf = t->bf = 0;
X    }
}
X
static void RotateRight(treeT *tptr)
{
X    treeT parent, child;
X
X    parent = *tptr;
X    child = parent->left;
X    parent->left = child->right;
X    child->right = parent;
X    (*tptr) = child;
}
X
/*
X * Function: DisplayTree
X * Usage: DisplayTree(t);
X * ----------------------
X * This function displays the keys in the specified tree in
X * alphabetical order by performing an inorder traversal.
X */
X
static void DisplayTree(treeT t)
{
X    if (t != NULL) {
X        DisplayTree(t->left);
X        printf("%s\n", t->key);
X        DisplayTree(t->right);
X    }
}
X
/*
X * Function: DisplayStructure
X * Usage: DisplayStructure(t);
X * ---------------------------
X * This function lists the keys in the tree in a form that
X * makes its structure clear by indenting children with respect
X * to their parents and labeling left and right children.  The
X * DisplayStructure function is implemented as a simple wrapper;
X * all the work is done by RecDisplayStructure.
X */
X
static void DisplayStructure(treeT t)
{
X    RecDisplayStructure(t, 0, NULL);
}
X
static void RecDisplayStructure(treeT t, int depth, string label)
{
X    if (t == NULL) return;
X    printf("%*s", 3 * depth, "");
X    if (label != NULL) printf("%s: ", label);
X    printf("%s (%s%d)\n", t->key, (t->bf > 0) ? "+" : "", t->bf);
X    RecDisplayStructure(t->left, depth + 1, "L");
X    RecDisplayStructure(t->right, depth + 1, "R");
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/13-Trees/avltree.c' &&
  chmod 0644 'programs/13-Trees/avltree.c' ||
  echo 'restore of programs/13-Trees/avltree.c failed'
  shar_count="`wc -c < 'programs/13-Trees/avltree.c'`"
  test 7002 -eq "$shar_count" ||
    echo "programs/13-Trees/avltree.c: original size 7002, current size $shar_count"
fi
# ============= programs/13-Trees/bst.c ==============
if test -f 'programs/13-Trees/bst.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/13-Trees/bst.c (file already exists)'
else
  echo 'x - extracting programs/13-Trees/bst.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/13-Trees/bst.c' &&
/*
X * File: bst.c
X * -----------
X * This file implements the bst.h interface, which provides a
X * general implementation of binary search trees.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "cmpfn.h"
#include "bst.h"
X
/*
X * Type: treeT
X * -----------
X * Because the implementation does not know the structure of a
X * node, pointers to nodes cannot be defined explicitly and must
X * be represented using void *.  For readability, the code declares
X * any void * pointers that are in fact trees to be of type treeT.
X */
X
typedef void *treeT;
X
/*
X * Type: bstCDT
X * ------------
X * This type is the concrete type used to represent the bstADT.
X */
X
struct bstCDT {
X    treeT root;
X    int userSize, totalSize;
X    cmpFnT cmpFn;
X    nodeInitFnT nodeInitFn;
};
X
/*
X * Type: bstDataT
X * --------------
X * This record is allocated at the end of the client's structure
X * and is used to maintain the structure of the tree.  The code
X * calls BSTData on the node pointer to derive this address.
X */
X
typedef struct {
X    treeT left, right;
} bstDataT;
X
/* Private function prototypes */
X
static treeT *RecFindNode(bstADT bst, treeT t, void *kp);
static void *RecInsertNode(bstADT bst, treeT *tptr, void *kp,
X                           void *clientData);
static void *RecDeleteNode(bstADT bst, treeT *tptr, void *kp);
static void *DeleteTargetNode(bstADT bst, treeT *tptr);
static void RecMapBST(nodeFnT fn, bstADT bst, treeT t,
X                      traversalOrderT order, void *clientData);
static bstDataT *BSTData(bstADT bst, treeT t);
X
/* Exported entries */
X
bstADT NewBST(int size, cmpFnT cmpFn, nodeInitFnT nodeInitFn)
{
X    bstADT bst;
X
X    bst = New(bstADT);
X    bst->root = NULL;
X    bst->userSize = size;
X    bst->totalSize = bst->userSize + sizeof(bstDataT);
X    bst->cmpFn = cmpFn;
X    bst->nodeInitFn = nodeInitFn;
X    return (bst);
}
X
void FreeBST(bstADT bst, nodeFnT freeNodeFn)
{
X    MapBST(freeNodeFn, bst, PostOrder, NULL);
X    FreeBlock(bst);
}
X
/*
X * Implementation notes: FindBSTNode, RecFindNode
X * ----------------------------------------------
X * The FindBSTNode function simply calls RecFindNode to do
X * the work.  The recursive function takes the address of
X * the current node along with the original arguments.
X */
X
void *FindBSTNode(bstADT bst, void *kp)
{
X    return (RecFindNode(bst, bst->root, kp));
}
X
static treeT *RecFindNode(bstADT bst, treeT t, void *kp)
{
X    bstDataT *dp;
X    int sign;
X
X    if (t == NULL) return (NULL);
X    sign = bst->cmpFn(kp, t);
X    if (sign == 0) return (t);
X    dp = BSTData(bst, t);
X    if (sign < 0) {
X        return (RecFindNode(bst, dp->left, kp));
X    } else {
X        return (RecFindNode(bst, dp->right, kp));
X    }
}
X
/*
X * Implementation notes: InsertBSTNode, RecInsertNode
X * --------------------------------------------------
X * The InsertBSTNode function is implemented as a simple wrapper
X * to RecInsertNode, which does all the work.  The difference
X * between the prototypes is that RecInsertNode takes a pointer
X * to the root of the current subtree as an extra argument.
X */
X
void *InsertBSTNode(bstADT bst, void *kp, void *clientData)
{
X    return (RecInsertNode(bst, &bst->root, kp, clientData));
}
X
static void *RecInsertNode(bstADT bst, treeT *tptr, void *kp,
X                           void *clientData)
{
X    bstDataT *dp;
X    treeT t;
X    int sign;
X
X    t = *tptr;
X    if (t == NULL) {
X        t = GetBlock(bst->totalSize);
X        bst->nodeInitFn(t, kp, clientData);
X        dp = BSTData(bst, t);
X        dp->left = dp->right = NULL;
X        *tptr = t;
X        return (t);
X    }
X    sign = bst->cmpFn(kp, t);
X    if (sign == 0) return (t);
X    dp = BSTData(bst, t);
X    if (sign < 0) {
X        return (RecInsertNode(bst, &dp->left, kp, clientData));
X    } else {
X        return (RecInsertNode(bst, &dp->right, kp, clientData));
X    }
}
X
/*
X * Implementation notes: DeleteBSTNode, RecDeleteNode
X * --------------------------------------------------
X * The first step in deleting a node is to find it using binary
X * search, which is performed by these two functions.  If the
X * node is found, DeleteTargetNode does the actual deletion.
X */
X
void *DeleteBSTNode(bstADT bst, void *kp)
{
X    return (RecDeleteNode(bst, &bst->root, kp));
}
X
static void *RecDeleteNode(bstADT bst, treeT *tptr, void *kp)
{
X    bstDataT *dp;
X    treeT t;
X    int sign;
X
X    t = *tptr;
X    if (t == NULL) return (NULL);
X    sign = bst->cmpFn(kp, t);
X    if (sign == 0) {
X        return (DeleteTargetNode(bst, tptr));
X    }
X    dp = BSTData(bst, t);
X    if (sign < 0) {
X        return (RecDeleteNode(bst, &dp->left, kp));
X    } else {
X        return (RecDeleteNode(bst, &dp->right, kp));
X    }
}
X
/*
X * Implementation notes: DeleteTargetNode
X * --------------------------------------
X * This function deletes the node whose address is passed by
X * reference in tptr.  The easy case occurs when either of the
X * children is NULL; all you need to do is replace the node with
X * its non-NULL child.  If both children are non-NULL, this code
X * finds the rightmost descendent of the left child; this node
X * may not be a leaf, but will have no right child.  Its left
X * child replaces it in the tree, after which the replacement
X * node is moved to the position occupied by the target node.
X */
X
static void *DeleteTargetNode(bstADT bst, treeT *tptr)
{
X    treeT target, *rptr;
X    bstDataT *tdp, *rdp;
X
X    target = *tptr;
X    tdp = BSTData(bst, target);
X    if (tdp->left == NULL) {
X        *tptr = tdp->right;
X    } else if (tdp->right == NULL) {
X        *tptr = tdp->left;
X    } else {
X        rptr = &tdp->left;
X        rdp = BSTData(bst, *rptr);
X        while (rdp->right != NULL) {
X            rptr = &rdp->right;
X            rdp = BSTData(bst, *rptr);
X        }
X        *tptr = *rptr;
X        *rptr = rdp->left;
X        rdp->left = tdp->left;
X        rdp->right = tdp->right;
X    }
X    return (target);
}
X
/*
X * Implementation notes: MapBST, RecMapBST
X * ---------------------------------------
X * The MapBST function is implemented as a wrapper to the
X * recursive function RecMapBST, which does the actual work.
X */
X
void MapBST(nodeFnT fn, bstADT bst, traversalOrderT order,
X            void *clientData)
{
X    RecMapBST(fn, bst, bst->root, order, clientData);
}
X
static void RecMapBST(nodeFnT fn, bstADT bst, treeT t,
X                      traversalOrderT order, void *clientData)
{
X    bstDataT *dp;
X
X    if (t != NULL) {
X        dp = BSTData(bst, t);
X        if (order == PreOrder) fn(t, clientData);
X        RecMapBST(fn, bst, dp->left, order, clientData);
X        if (order == InOrder) fn(t, clientData);
X        RecMapBST(fn, bst, dp->right, order, clientData);
X        if (order == PostOrder) fn(t, clientData);
X    }
}
X
/* Low-level functions */
X
void *BSTRoot(bstADT bst)
{
X    return (bst->root);
}
X
void *BSTLeftChild(bstADT bst, void *np)
{
X    bstDataT *dp;
X
X    if (np == NULL) Error("BSTLeftChild: Argument is NULL");
X    dp = BSTData(bst, np);
X    return (dp->left);
}
X
void *BSTRightChild(bstADT bst, void *np)
{
X    bstDataT *dp;
X
X    if (np == NULL) Error("BSTRightChild: Argument is NULL");
X    dp = BSTData(bst, np);
X    return (dp->right);
}
X
/*
X * Function: BSTData
X * Usage: dp = BSTData(bst, t);
X * ----------------------------
X * This function determines the address of the data record
X * containing the pointers for the binary tree.  This record
X * appears at the end of the user structure that begins at t.
X */
X
static bstDataT *BSTData(bstADT bst, treeT t)
{
X    return ((bstDataT *) ((char *) t + bst->userSize));
}
X
X
SHAR_EOF
  $shar_touch -am 0903182097 'programs/13-Trees/bst.c' &&
  chmod 0644 'programs/13-Trees/bst.c' ||
  echo 'restore of programs/13-Trees/bst.c failed'
  shar_count="`wc -c < 'programs/13-Trees/bst.c'`"
  test 7517 -eq "$shar_count" ||
    echo "programs/13-Trees/bst.c: original size 7517, current size $shar_count"
fi
# ============= programs/13-Trees/bst.h ==============
if test -f 'programs/13-Trees/bst.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/13-Trees/bst.h (file already exists)'
else
  echo 'x - extracting programs/13-Trees/bst.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/13-Trees/bst.h' &&
/*
X * File: bst.h
X * -----------
X * This file provides an interface for a general binary search
X * tree facility that allows the client to maintain control of
X * the structure of the node.
X */
X
#ifndef _bst_h
#define _bst_h
X
#include "genlib.h"
#include "cmpfn.h"
X
/*
X * Type: bstADT
X * ------------
X * This is the abstract type for a binary search tree.
X */
X
typedef struct bstCDT *bstADT;
X
/*
X * Type: nodeFnT
X * -------------
X * This type defines the class of callback functions for nodes.
X */
X
typedef void (*nodeFnT)(void *np, void *clientData);
X
/*
X * Type: nodeInitFnT
X * -----------------
X * This type defines the class of functions used to initialize
X * a newly created node.
X */
X
typedef void (*nodeInitFnT)(void *np, void *kp, void *clientData);
X
/*
X * Function: NewBST
X * Usage: bst = NewBST(sizeof (nodeT), cmpFn, nodeInitFn);
X * -------------------------------------------------------
X * This function allocates and returns a new empty binary search
X * tree.  The first argument is the size of the client node.  The
X * second is a comparison function, which is called with the address
X * of the search key and the address of a node.  By storing the key
X * at the beginning of the structure, client's can use the standard
X * comparison functions from cmpfn.h.  The third argument is a
X * function that initializes the client's fields in the node, which
X * is described in more detail in the comments for InsertBSTNode.
X */
X
bstADT NewBST(int size, cmpFnT cmpFn, nodeInitFnT nodeInitFn);
X
/*
X * Function: FreeBST
X * Usage: FreeBST(bst, freeNodeFn);
X * --------------------------------
X * This function frees the storage for a tree, but calls the
X * client-supplied freeNodeFn to free each individual node.
X * The clientData value passed to the callback function is
X * always NULL.
X */
X
void FreeBST(bstADT bst, nodeFnT freeNodeFn);
X
/*
X * Function: FindBSTNode
X * Usage: np = FindBSTNode(bst, &key);
X * -----------------------------------
X * This function applies the binary search algorithm to find a
X * particular key in the tree represented by bst.  The second
X * argument represents the address of the key in the client
X * space rather than the key itself, which makes it possible to
X * use this package for keys that are not pointer types.  If a
X * node matching the key appears in the tree, FindBSTNode
X * returns a pointer to it; if not, FindBSTNode returns NULL.
X */
X
void *FindBSTNode(bstADT bst, void *kp);
X
/*
X * Function: InsertBSTNode
X * Usage: np = InsertBSTNode(bst, &key, clientData);
X * -------------------------------------------------
X * This function is used to insert a new node into a binary search
X * tree.  The bst and &key arguments are interpreted as they are
X * in FindBSTNode.  If the key already exists, the result is
X * simply the address of the old node.  If the key is not found,
X * InsertBSTNode allocates a new node and then calls the node
X * initialization function specified in the NewBST call to
X * initialize it.  The call has the following form:
X *
X *     nodeInitFn(np, kp, clientData);
X *
X * where np is a pointer to the node, kp is the pointer to the key,
X * and clientData is the value (typically NULL) supplied in the
X * InsertBSTNode call.  The initialization function must initialize
X * the key field in the node, but may perform other initialization
X * as well.
X */
X
void *InsertBSTNode(bstADT bst, void *kp, void *clientData);
X
/*
X * Function: DeleteBSTNode
X * Usage: np = DeleteBSTNode(bst, &key);
X * -------------------------------------
X * This function deletes a node in the tree that matches the
X * specified key pointer.  The arguments are interpreted as
X * in FindBSTNode.  The function returns the address of the
X * deleted node so that clients can free its storage.  If the
X * key is not found in the tree, DeleteBSTNode returns NULL.
X */
X
void *DeleteBSTNode(bstADT bst, void *kp);
X
/*
X * Function: MapBST
X * Usage: MapBST(fn, bst, order, clientData);
X * ------------------------------------------
X * This function calls fn on every node in the binary search tree,
X * passing it a pointer to a node and the clientData pointer.  The
X * type of traversal is given by the order argument, which must
X * be one of the constants InOrder, PreOrder, or PostOrder.
X */
X
typedef enum { InOrder, PreOrder, PostOrder } traversalOrderT;
X
void MapBST(nodeFnT fn, bstADT bst, traversalOrderT order,
X            void *clientData);
X
/*
X * Low-level functions: BSTRoot, BSTLeftChild, BSTRightChild
X * Usage: root = BSTRoot(bst);
X *        child = BSTLeftChild(bst, np);
X *        child = BSTRightChild(bst, np);
X * ---------------------------------------------------------
X * These functions allow the client to trace the structure of the
X * binary search tree and are useful primarily for debugging.
X */
X
void *BSTRoot(bstADT bst);
void *BSTLeftChild(bstADT bst, void *np);
void *BSTRightChild(bstADT bst, void *np);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/13-Trees/bst.h' &&
  chmod 0644 'programs/13-Trees/bst.h' ||
  echo 'restore of programs/13-Trees/bst.h failed'
  shar_count="`wc -c < 'programs/13-Trees/bst.h'`"
  test 4878 -eq "$shar_count" ||
    echo "programs/13-Trees/bst.h: original size 4878, current size $shar_count"
fi
# ============= programs/13-Trees/bsttab.c ==============
if test -f 'programs/13-Trees/bsttab.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/13-Trees/bsttab.c (file already exists)'
else
  echo 'x - extracting programs/13-Trees/bsttab.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/13-Trees/bsttab.c' &&
/*
X * File: bsttab.c
X * --------------
X * This file implements the symtab.h interface using binary
X * search trees as the underlying representation.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "strlib.h"
#include "bst.h"
#include "cmpfn.h"
#include "symtab.h"
X
/*
X * Type: symtabCDT
X * ---------------
X * This type defines the underlying concrete representation
X * for a symtabADT, which is simply a binary search tree.
X */
X
struct symtabCDT {
X    bstADT bst;
};
X
/*
X * Type: symtabNodeT
X * -----------------
X * This record type defines the node type for the symbol table
X * and consists of a key/value pair.
X */
X
typedef struct {
X    string key;
X    void *value;
} symtabNodeT;
X
/*
X * Type: callbackDataT
X * -------------------
X * This type holds the data required to build the mapping
X * function for symbol tables out of the more general one
X * for binary search trees.
X */
X
typedef struct {
X    symtabFnT fn;
X    void *clientData;
} *callbackDataT;
X
/* Private function prototypes */
X
static void InitEntry(void *np, void *kp, void *clientData);
static void FreeEntry(void *np, void *clientData);
static void MapCallbackFn(void *np, void *clientData);
X
/* Public entries */
X
symtabADT NewSymbolTable(void)
{
X    symtabADT table;
X
X    table = New(symtabADT);
X    table->bst =
X      NewBST(sizeof (symtabNodeT), StringCmpFn, InitEntry);
X    return (table);
}
X
void FreeSymbolTable(symtabADT table)
{
X    FreeBST(table->bst, FreeEntry);
X    FreeBlock(table);
}
X
void Enter(symtabADT table, string key, void *value)
{
X    symtabNodeT *np;
X
X    np = InsertBSTNode(table->bst, &key, NULL);
X    np->value = value;
}
X
void *Lookup(symtabADT table, string key)
{
X    symtabNodeT *np;
X
X    np = FindBSTNode(table->bst, &key);
X    if (np == NULL) return (UNDEFINED);
X    return (np->value);
}
X
void DeleteSymbol(symtabADT table, string key)
{
X    symtabNodeT *np;
X
X    np = DeleteBSTNode(table->bst, &key);
X    if (np != NULL) {
X        FreeBlock(np->key);
X        FreeBlock(np);
X    }
}
X
void MapSymbolTable(symtabFnT fn, symtabADT table,
X                    void *clientData)
{
X    callbackDataT cd;
X
X    cd = New(callbackDataT);
X    cd->fn = fn;
X    cd->clientData = clientData;
X    MapBST(MapCallbackFn, table->bst, InOrder, cd);
}
X
/* Private functions */
X
static void InitEntry(void *np, void *kp, void *clientData)
{
X    ((symtabNodeT *) np)->key = CopyString(*((string *) kp));
}
X
static void FreeEntry(void *np, void *clientData)
{
X    FreeBlock(((symtabNodeT *) np)->key);
X    FreeBlock(np);
}
X
static void MapCallbackFn(void *np, void *clientData)
{
X    symtabNodeT *ep = np;
X    callbackDataT cd = clientData;
X
X    cd->fn(ep->key, ep->value, cd->clientData);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/13-Trees/bsttab.c' &&
  chmod 0644 'programs/13-Trees/bsttab.c' ||
  echo 'restore of programs/13-Trees/bsttab.c failed'
  shar_count="`wc -c < 'programs/13-Trees/bsttab.c'`"
  test 2675 -eq "$shar_count" ||
    echo "programs/13-Trees/bsttab.c: original size 2675, current size $shar_count"
fi
# ============= programs/13-Trees/bsttest.c ==============
if test -f 'programs/13-Trees/bsttest.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/13-Trees/bsttest.c (file already exists)'
else
  echo 'x - extracting programs/13-Trees/bsttest.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/13-Trees/bsttest.c' &&
/*
X * File: bsttest.c
X * ---------------
X * This file tests the bst.c implementation.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "strlib.h"
#include "simpio.h"
#include "scanadt.h"
#include "cmpfn.h"
#include "bst.h"
X
/* Private function prototypes */
X
static void NodeInitFn(void *np, void *kp, void *clientData);
static void ListNode(void *np, void *clientData);
X
/* Main program */
X
main()
{
X    scannerADT scanner;
X    bstADT bst;
X    string line, cmd, key, *np;
X    bool newFlag;
X
X    scanner = NewScanner();
X    SetScannerSpaceOption(scanner, IgnoreSpaces);
X    bst = NewBST(sizeof(string), StringCmpFn, NodeInitFn);
X    while (TRUE) {
X        printf(">");
X        line = GetLine();
X        SetScannerString(scanner, line);
X        cmd = ConvertToLowerCase(ReadToken(scanner));
X        if (StringEqual(cmd, "find")) {
X            key = ReadToken(scanner);
X            np = FindBSTNode(bst, &key);
X            if (np == NULL) {
X                printf("No such node\n");
X            } else {
X                 printf("Key %s found in node at %08lx\n", *np, (long) np);
X             }
X        } else if (StringEqual(cmd, "insert")) {
X            key = ReadToken(scanner);
X            np = InsertBSTNode(bst, &key, NULL);
X        } else if (StringEqual(cmd, "delete")) {
X            key = ReadToken(scanner);
X            np = DeleteBSTNode(bst, &key);
X        } else if (StringEqual(cmd, "inorder") || StringEqual(cmd, "list")) {
X            MapBST(ListNode, bst, InOrder, NULL);
X        } else if (StringEqual(cmd, "preorder")) {
X            MapBST(ListNode, bst, PreOrder, NULL);
X        } else if (StringEqual(cmd, "postorder")) {
X            MapBST(ListNode, bst, PostOrder, NULL);
X        } else if (StringEqual(cmd, "quit")) {
X            break;
X        } else {
X            printf("Unrecognized command: %s\n", line);
X        }
X    }
}
X
static void NodeInitFn(void *np, void *kp, void *clientData)
{
X    *((string *) np) = CopyString(*((string *) kp));
}
X
static void ListNode(void *np, void *clientData)
{
X    printf("  %s\n", *((string *) np));
}
SHAR_EOF
  $shar_touch -am 0905212097 'programs/13-Trees/bsttest.c' &&
  chmod 0644 'programs/13-Trees/bsttest.c' ||
  echo 'restore of programs/13-Trees/bsttest.c failed'
  shar_count="`wc -c < 'programs/13-Trees/bsttest.c'`"
  test 2067 -eq "$shar_count" ||
    echo "programs/13-Trees/bsttest.c: original size 2067, current size $shar_count"
fi
# ============= programs/13-Trees/cmpfn.c ==============
if test -f 'programs/13-Trees/cmpfn.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/13-Trees/cmpfn.c (file already exists)'
else
  echo 'x - extracting programs/13-Trees/cmpfn.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/13-Trees/cmpfn.c' &&
/*
X * File: cmpfn.c
X * -------------
X * This file implements the comparison functions exported by
X * the cmpfn.h interface.  The reason to centralize them in
X * a single module is to allow the same functions to be
X * shared among many different modules.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "strlib.h"
#include "cmpfn.h"
X
/* Exported entries */
X
int IntCmpFn(const void *p1, const void *p2)
{
X    int v1, v2;
X
X    v1 = *((int *) p1);
X    v2 = *((int *) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : +1);
}
X
int ShortCmpFn(const void *p1, const void *p2)
{
X    short v1, v2;
X
X    v1 = *((short *) p1);
X    v2 = *((short *) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : +1);
}
X
int LongCmpFn(const void *p1, const void *p2)
{
X    long v1, v2;
X
X    v1 = *((long *) p1);
X    v2 = *((long *) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : +1);
}
X
int CharCmpFn(const void *p1, const void *p2)
{
X    unsigned char v1, v2;
X
X    v1 = *((unsigned char *) p1);
X    v2 = *((unsigned char *) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : +1);
}
X
int FloatCmpFn(const void *p1, const void *p2)
{
X    float v1, v2;
X
X    v1 = *((float *) p1);
X    v2 = *((float *) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : +1);
}
X
int DoubleCmpFn(const void *p1, const void *p2)
{
X    double v1, v2;
X
X    v1 = *((double *) p1);
X    v2 = *((double *) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : +1);
}
X
int UnsignedCmpFn(const void *p1, const void *p2)
{
X    unsigned v1, v2;
X
X    v1 = *((unsigned *) p1);
X    v2 = *((unsigned *) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : +1);
}
X
int UnsignedShortCmpFn(const void *p1, const void *p2)
{
X    unsigned short v1, v2;
X
X    v1 = *((unsigned short *) p1);
X    v2 = *((unsigned short *) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : +1);
}
X
int UnsignedLongCmpFn(const void *p1, const void *p2)
{
X    unsigned long v1, v2;
X
X    v1 = *((unsigned long *) p1);
X    v2 = *((unsigned long *) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : +1);
}
X
int UnsignedCharCmpFn(const void *p1, const void *p2)
{
X    unsigned char v1, v2;
X
X    v1 = *((unsigned char *) p1);
X    v2 = *((unsigned char *) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : +1);
}
X
int StringCmpFn(const void *p1, const void *p2)
{
X    return (StringCompare(*((string *) p1), *((string *) p2)));
}
X
int PtrCmpFn(const void *p1, const void *p2)
{
X    void *v1, *v2;
X
X    v1 = *((void **) p1);
X    v2 = *((void **) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : +1);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/13-Trees/cmpfn.c' &&
  chmod 0644 'programs/13-Trees/cmpfn.c' ||
  echo 'restore of programs/13-Trees/cmpfn.c failed'
  shar_count="`wc -c < 'programs/13-Trees/cmpfn.c'`"
  test 2658 -eq "$shar_count" ||
    echo "programs/13-Trees/cmpfn.c: original size 2658, current size $shar_count"
fi
# ============= programs/13-Trees/cmpfn.h ==============
if test -f 'programs/13-Trees/cmpfn.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/13-Trees/cmpfn.h (file already exists)'
else
  echo 'x - extracting programs/13-Trees/cmpfn.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/13-Trees/cmpfn.h' &&
/*
X * File: cmpfn.h
X * -------------
X * This interface exports several comparison functions for use
X * with ANSI library functions like qsort and bsearch as well
X * as various functions in the extended library.
X */
X
#ifndef _cmpfn_h
#define _cmpfn_h
X
/*
X * Type: cmpFnT
X * ------------
X * This type defines the type space of comparison functions,
X * each of which take the addresses of their arguments and
X * return an integer from the set {-1, 0, +1} depending on
X * whether the first argument is less than, equal to, or
X * greater than the second.
X */
X
typedef int (*cmpFnT)(const void *p1, const void *p2);
X
/*
X * Standard comparison functions
X * -----------------------------
X * The remainder of this interface exports standard comparison
X * functions for the most common built-in types.
X */
X
int IntCmpFn(const void *p1, const void *p2);
int ShortCmpFn(const void *p1, const void *p2);
int LongCmpFn(const void *p1, const void *p2);
int CharCmpFn(const void *p1, const void *p2);
int FloatCmpFn(const void *p1, const void *p2);
int DoubleCmpFn(const void *p1, const void *p2);
int UnsignedCmpFn(const void *p1, const void *p2);
int UnsignedShortCmpFn(const void *p1, const void *p2);
int UnsignedLongCmpFn(const void *p1, const void *p2);
int UnsignedCharCmpFn(const void *p1, const void *p2);
int StringCmpFn(const void *p1, const void *p2);
int PtrCmpFn(const void *p1, const void *p2);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/13-Trees/cmpfn.h' &&
  chmod 0644 'programs/13-Trees/cmpfn.h' ||
  echo 'restore of programs/13-Trees/cmpfn.h failed'
  shar_count="`wc -c < 'programs/13-Trees/cmpfn.h'`"
  test 1402 -eq "$shar_count" ||
    echo "programs/13-Trees/cmpfn.h: original size 1402, current size $shar_count"
fi
# ============= programs/13-Trees/elements.dat ==============
if test -f 'programs/13-Trees/elements.dat' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/13-Trees/elements.dat (file already exists)'
else
  echo 'x - extracting programs/13-Trees/elements.dat (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/13-Trees/elements.dat' &&
H
He
Li
Be
B
C
N
O
F
Ne
Na
Mg
Al
Si
P
S
Cl
Ar
K
Ca
Sc
Ti
V
Cr
Mn
Fe
Co
Ni
Cu
Zn
Ga
Ge
As
Se
Br
Kr
Rb
Sr
Y
Zr
Nb
Mo
Tc
Ru
Rh
Pd
Ag
Cd
In
Sn
Sb
Te
I
XXe
Cs
Ba
La
Ce
Pr
Nd
Pm
Sm
Eu
Gd
Tb
Dy
Ho
Er
Tm
Yb
Lu
Hf
Ta
W
Re
Os
Ir
Pt
Au
Hg
Tl
Pb
Bi
Po
At
Rn
Fr
Ra
Ac
Th
Pa
U
Np
Pu
Am
Cm
Bk
Cf
Es
Fm
Md
No
Lr
SHAR_EOF
  $shar_touch -am 0906100097 'programs/13-Trees/elements.dat' &&
  chmod 0644 'programs/13-Trees/elements.dat' ||
  echo 'restore of programs/13-Trees/elements.dat failed'
  shar_count="`wc -c < 'programs/13-Trees/elements.dat'`"
  test 295 -eq "$shar_count" ||
    echo "programs/13-Trees/elements.dat: original size 295, current size $shar_count"
fi
# ============= programs/13-Trees/introbst.c ==============
if test -f 'programs/13-Trees/introbst.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/13-Trees/introbst.c (file already exists)'
else
  echo 'x - extracting programs/13-Trees/introbst.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/13-Trees/introbst.c' &&
/*
X * File: introbst.c
X * ----------------
X * This program introduces the standard operations used for
X * binary search trees and serves as a model for the more
X * general bst.h interface.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "strlib.h"
X
/*
X * Types: nodeT, treeT
X * -------------------
X * These types define the structure of the binary search tree.
X * The type nodeT is a record that corresponds to an individual
X * node; the type treeT is simply a pointer to a node.
X */
X
typedef struct nodeT {
X    string key;
X    struct nodeT *left, *right;
} nodeT, *treeT;
X
/* Private function prototypes */
X
static void TestSearch(treeT tree, string key);
static treeT FindNode(treeT t, string key);
static void InsertNode(treeT *tptr, string key);
static void PreOrderWalk(treeT t);
static void PostOrderWalk(treeT t);
static void DisplayTree(treeT t);
X
/* Main program */
X
main()
{
X    treeT dwarfTree;
X
X    dwarfTree = NULL;
X    InsertNode(&dwarfTree, "Grumpy");
X    InsertNode(&dwarfTree, "Doc");
X    InsertNode(&dwarfTree, "Sleepy");
X    InsertNode(&dwarfTree, "Bashful");
X    InsertNode(&dwarfTree, "Dopey");
X    InsertNode(&dwarfTree, "Happy");
X    InsertNode(&dwarfTree, "Sneezy");
X    TestSearch(dwarfTree, "Grumpy");
X    TestSearch(dwarfTree, "Sleepy");
X    TestSearch(dwarfTree, "Snow White");
}
X
/*
X * Function: TestSearch
X * Usage: TestSearch(tree, key);
X * -----------------------------
X * This function writes out the result of calling FindNode on
X * the specified parameters.
X */
X
static void TestSearch(treeT tree, string key)
{
X    treeT np;
X
X    np = FindNode(tree, key);
X    printf("FindNode(tree, \"%s\") returns ", key);
X    if (np == NULL) {
X        printf("NULL");
X    } else {
X        printf("a pointer to a node at %08lx", (long) np);
X        if (!StringEqual(key, np->key)) {
X            Error("Search failed");
X        }
X    }
X    printf("\n");
}
X
/*
X * Function: FindNode
X * Usage: np = FindNode(t, key);
X * -----------------------------
X * This function searches the tree t for a node containing key.
X * If it finds it, it returns a pointer to that node, which can
X * also be regarded as the subtree rooted at that point.  If
X * the key does not appear, FindNode returns NULL.
X */
X
static treeT FindNode(treeT t, string key)
{
X    int sign;
X
X    if (t == NULL) return (NULL);
X    sign = StringCompare(key, t->key);
X    if (sign == 0) return (t);
X    if (sign < 0) {
X        return (FindNode(t->left, key));
X    } else {
X        return (FindNode(t->right, key));
X    }
}
X
/*
X * Function: InsertNode
X * Usage: InsertNode(&t, key);
X * ---------------------------
X * This function inserts the specified key into the tree, which
X * is passed by reference as the first argument to InsertNode.
X * If the key already exists in the tree, the call to InsertNode
X * returns without making any additional changes.
X */
X
static void InsertNode(treeT *tptr, string key)
{
X    treeT t;
X    int sign;
X
X    t = *tptr;
X    if (t == NULL) {
X        t = New(treeT);
X        t->key = CopyString(key);
X        t->left = t->right = NULL;
X        *tptr = t;
X        return;
X    }
X    sign = StringCompare(key, t->key);
X    if (sign == 0) return;
X    if (sign < 0) {
X        InsertNode(&t->left, key);
X    } else {
X        InsertNode(&t->right, key);
X    }
}
X
/*
X * Functions: DisplayTree
X * Usage: DisplayTree(t);
X * ----------------------
X * These functions displays the keys in the specified tree
X * in alphabetical order by keys.  This function performs an
X * inorder traversal.
X */
X
static void DisplayTree(treeT t)
{
X    if (t != NULL) {
X        DisplayTree(t->left);
X        printf("%s\n", t->key);
X        DisplayTree(t->right);
X    }
}
X
/*
X * Functions: PreOrderWalk, PostOrderWalk
X * Usage: PreOrderWalk(t);
X *        PostOrderWalk(t);
X * --------------------------------------
X * These functions perform the indicated type of tree traversal
X * on the tree t, displaying the keys in each node as it goes.
X * PreOrderWalk processes the current node before making the
X * recursive calls; PostOrderWalk processes the current node
X * after the recursive calls.  The DisplayTree function earlier
X * in the file processes the current node between the recursive
X * calls and is sometimes called an "inorder" walk.
X */
X
static void PreOrderWalk(treeT t)
{
X    if (t != NULL) {
X        printf("%s\n", t->key);
X        PreOrderWalk(t->left);
X        PreOrderWalk(t->right);
X    }
}
X
static void PostOrderWalk(treeT t)
{
X    if (t != NULL) {
X        PostOrderWalk(t->left);
X        PostOrderWalk(t->right);
X        printf("%s\n", t->key);
X    }
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/13-Trees/introbst.c' &&
  chmod 0644 'programs/13-Trees/introbst.c' ||
  echo 'restore of programs/13-Trees/introbst.c failed'
  shar_count="`wc -c < 'programs/13-Trees/introbst.c'`"
  test 4556 -eq "$shar_count" ||
    echo "programs/13-Trees/introbst.c: original size 4556, current size $shar_count"
fi
# ============= programs/13-Trees/scanadt.c ==============
if test -f 'programs/13-Trees/scanadt.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/13-Trees/scanadt.c (file already exists)'
else
  echo 'x - extracting programs/13-Trees/scanadt.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/13-Trees/scanadt.c' &&
/*
X * File: scanadt.c
X * ---------------
X * This file implements the scanadt.h interface.
X */
X
#include <stdio.h>
#include <ctype.h>
#include "genlib.h"
#include "strlib.h"
#include "scanadt.h"
X
/*
X * Type: scannerCDT
X * ----------------
X * This structure is the concrete representation of the type
X * scannerADT, which is exported by this interface.  Its purpose
X * is to maintain the state of the scanner between calls.  The
X * details of the representation are invisible to the client,
X * but consist of the following fields:
X *
X * str          -- Copy of string passed to SetScannerString
X * len          -- Length of string, saved for efficiency
X * cp           -- Current character position in the string
X * savedToken   -- String saved by SaveToken (NULL indicates none)
X * spaceOption  -- Setting of the space option extension
X * numberOption -- Setting of the number option extension
X * stringOption -- Setting of string option extension
X */
X
struct scannerCDT {
X    string str;
X    int len;
X    int cp;
X    string savedToken;
X    spaceOptionT spaceOption;
X    numberOptionT numberOption;
X    stringOptionT stringOption;
};
X
/* Private function prototypes */
X
static void SkipSpaces(scannerADT scanner);
static int ScanToEndOfIdentifier(scannerADT scanner);
static int ScanToEndOfInteger(scannerADT scanner);
static int ScanToEndOfReal(scannerADT scanner);
static string ScanQuotedString(scannerADT scanner);
static char ScanEscapeCharacter(scannerADT scanner);
X
/* Exported entries */
X
scannerADT NewScanner(void)
{
X    scannerADT scanner;
X
X    scanner = New(scannerADT);
X    scanner->str = NULL;
X    scanner->spaceOption = PreserveSpaces;
X    scanner->numberOption = ScanNumbersAsLetters;
X    scanner->stringOption = ScanQuotesAsPunctuation;
X    return (scanner);
}
X
void FreeScanner(scannerADT scanner)
{
X    if (scanner->str != NULL) FreeBlock(scanner->str);
X    FreeBlock(scanner);
}
X
void SetScannerString(scannerADT scanner, string str)
{
X    if (scanner->str != NULL) FreeBlock(scanner->str);
X    scanner->str = CopyString(str);
X    scanner->len = StringLength(str);
X    scanner->cp = 0;
X    scanner->savedToken = NULL;
}
X
string ReadToken(scannerADT scanner)
{
X    char ch;
X    string token;
X    int start, finish;
X
X    if (scanner->str == NULL) {
X        Error("SetScannerString has not been called");
X    }
X    if (scanner->savedToken != NULL) {
X        token = scanner->savedToken;
X        scanner->savedToken = NULL;
X        return (token);
X    }
X    if (scanner->spaceOption == IgnoreSpaces) SkipSpaces(scanner);
X    start = finish = scanner->cp;
X    if (start >= scanner->len) return (CopyString(""));
X    ch = scanner->str[scanner->cp];
X    if (scanner->stringOption == ScanQuotesAsStrings
X            && ch == '"') {
X        return (ScanQuotedString(scanner));
X    }
X    if (isdigit(ch)) {
X        switch (scanner->numberOption) {
X          case ScanNumbersAsLetters:
X            finish = ScanToEndOfIdentifier(scanner);
X            break;
X          case ScanNumbersAsIntegers:
X            finish = ScanToEndOfInteger(scanner);
X            break;
X          case ScanNumbersAsReals:
X            finish = ScanToEndOfReal(scanner);
X            break;
X        }
X    } else if (isalnum(ch)) {
X        finish = ScanToEndOfIdentifier(scanner);
X    } else {
X        scanner->cp++;
X    }
X    return (SubString(scanner->str, start, finish));
}
X
bool MoreTokensExist(scannerADT scanner)
{
X    if (scanner->str == NULL) {
X        Error("SetScannerString has not been called");
X    }
X    if (scanner->savedToken != NULL) {
X        return (!StringEqual(scanner->savedToken, ""));
X    }
X    if (scanner->spaceOption == IgnoreSpaces) SkipSpaces(scanner);
X    return (scanner->cp < scanner->len);
}
X
void SaveToken(scannerADT scanner, string token)
{
X    if (scanner->str == NULL) {
X        Error("SetScannerString has not been called");
X    }
X    if (scanner->savedToken != NULL) {
X        Error("Token has already been saved");
X    }
X    scanner->savedToken = token;
}
X
void SetScannerSpaceOption(scannerADT scanner, spaceOptionT option)
{
X    scanner->spaceOption = option;
}
X
spaceOptionT GetScannerSpaceOption(scannerADT scanner)
{
X    return (scanner->spaceOption);
}
X
void SetScannerNumberOption(scannerADT scanner, numberOptionT option)
{
X    scanner->numberOption = option;
}
X
numberOptionT GetScannerNumberOption(scannerADT scanner)
{
X    return (scanner->numberOption);
}
X
void SetScannerStringOption(scannerADT scanner, stringOptionT option)
{
X    scanner->stringOption = option;
}
X
stringOptionT GetScannerStringOption(scannerADT scanner)
{
X    return (scanner->stringOption);
}
X
/* Private functions */
X
/*
X * Function: SkipSpaces
X * Usage: SkipSpaces(scanner);
X * ---------------------------
X * This function advances the position of the scanner until the
X * current character is not a whitespace character.
X */
X
static void SkipSpaces(scannerADT scanner)
{
X    while (isspace(scanner->str[scanner->cp])) {
X        scanner->cp++;
X    }
}
X
/*
X * Function: ScanToEndOfIdentifier
X * Usage: finish = ScanToEndOfIdentifier(scanner);
X * -----------------------------------------------
X * This function advances the position of the scanner until it
X * reaches the end of a sequence of letters or digits that make
X * up an identifier.  The return value is the index of the last
X * character in the identifier; the value of the stored index
X * cp is the first character after that.
X */
X
static int ScanToEndOfIdentifier(scannerADT scanner)
{
X    while (isalnum(scanner->str[scanner->cp])) {
X        scanner->cp++;
X    }
X    return (scanner->cp - 1);
}
X
/*
X * Function: ScanToEndOfInteger
X * Usage: finish = ScanToEndOfInteger(scanner);
X * --------------------------------------------
X * This function advances the position of the scanner until it
X * reaches the end of a sequence of digits.  The return value is
X * the index of the last character in the integer; the value
X * of the stored index cp is the first character after that.
X */
X
static int ScanToEndOfInteger(scannerADT scanner)
{
X    while (isdigit(scanner->str[scanner->cp])) {
X        scanner->cp++;
X    }
X    return (scanner->cp - 1);
}
X
/*
X * Function: ScanToEndOfReal
X * Usage: finish = ScanToEndOfReal(scanner);
X * -----------------------------------------
X * This function advances the position of the scanner until it
X * reaches the end of a legal number.  The return value is the
X * index of the last character in the identifier; the value
X * of the stored index cp is the first character after that.
X *
X * The function operates by simulating what computer scientists
X * call a finite-state machine.  The program uses the variable
X * state to record the history of the process and determine
X * what characters would be legal at this point in time.
X */
X
#define InitialState        0
#define BeforeDecimalPoint  1
#define AfterDecimalPoint   2
#define StartingExponent    3
#define FoundExponentSign   4
#define ScanningExponent    5
#define FinalState         -1
X
static int ScanToEndOfReal(scannerADT scanner)
{
X    int state;
X    char ch;
X
X    state = InitialState;
X    while (state != FinalState) {
X        ch = scanner->str[scanner->cp];
X        switch (state) {
X          case InitialState:
X            if (!isdigit(ch)) Error("ScanToEndOfReal called on nonnumber");
X             state = BeforeDecimalPoint;
X            break;
X          case BeforeDecimalPoint:
X            if (ch == '.') {
X                state = AfterDecimalPoint;
X            } else if (ch == 'E' || ch == 'e') {
X                state = StartingExponent;
X            } else if (!isdigit(ch)) {
X                state = FinalState;
X            }
X            break;
X          case AfterDecimalPoint:
X            if (ch == 'E' || ch == 'e') {
X                state = StartingExponent;
X            } else if (!isdigit(ch)) {
X                state = FinalState;
X            }
X            break;
X          case StartingExponent:
X            if (ch == '+' || ch == '-') {
X                state = FoundExponentSign;
X            } else if (isdigit(ch)) {
X                state = ScanningExponent;
X            } else {
X                scanner->cp--;
X                state = FinalState;
X            }
X            break;
X          case FoundExponentSign:
X            if (isdigit(ch)) {
X                state = ScanningExponent;
X            } else {
X                scanner->cp -= 2;
X                state = FinalState;
X            }
X            break;
X          case ScanningExponent:
X            if (!isdigit(ch)) {
X                state = FinalState;
X            }
X            break;
X        }
X        if (state != FinalState) scanner->cp++;
X    }
X    return (scanner->cp - 1);
}
X
/*
X * Function: ScanQuotedString
X * Usage: str = ScanQuotedString(scanner);
X * ---------------------------------------
X * This function reads and returns a quoted string from the
X * scanner.  The current position of the scanner must be the
X * opening quotation mark.  At the end, the current position
X * marker will be set to the character position after the
X * closing quote.  The scanner generates an error if there
X * is no closing quotation mark before the end of the string.
X */
X
static string ScanQuotedString(scannerADT scanner)
{
X    string token;
X    char ch;
X
X    token = "\"";
X    scanner->cp++;
X    while ((ch = scanner->str[scanner->cp++]) != '"') {
X        if (ch == '\0') Error("Unterminated string");
X        if (ch == '\\') ch = ScanEscapeCharacter(scanner);
X        token = Concat(token, CharToString(ch));
X    }
X    return (Concat(token, "\""));
}
X
/*
X * Function: ScanEscapeCharacter
X * Usage: ch = ScanEscapeCharacter(scanner);
X * -----------------------------------------
X * This function is used by ScanQuotedString to read an escape
X * character sequence from the scanner string.  The opening
X * backslash character has already been read.  Most of the
X * complexity comes in reading the '\ddd' and '\xdd' forms.
X */
X
static char ScanEscapeCharacter(scannerADT scanner)
{
X    char ch, result;
X    int digit, base;
X
X    ch = scanner->str[scanner->cp];
X    if (isdigit(ch) || ch == 'x') {
X        base = 8;
X        if (ch == 'x') {
X            base = 16;
X            scanner->cp++;
X        }
X        result = 0;
X        while (TRUE) {
X            ch = scanner->str[scanner->cp];
X            if (isdigit(ch)) {
X                digit = ch - '0';
X            } else if (isalpha(ch)) {
X                digit = toupper(ch) - 'A' + 10;
X            } else {
X                digit = base;
X            }
X            if (digit >= base) break;
X            result = base * result + digit;
X            scanner->cp++;
X        }
X        return (result);
X    }
X    scanner->cp++;
X    switch (ch) {
X      case 'a':  return ('\a');
X      case 'b':  return ('\b');
X      case 'f':  return ('\f');
X      case 'n':  return ('\n');
X      case 'r':  return ('\r');
X      case 't':  return ('\t');
X      case 'v':  return ('\v');
X      case '\\': return ('\\');
X      case '"':  return ('"');
X    }
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/13-Trees/scanadt.c' &&
  chmod 0644 'programs/13-Trees/scanadt.c' ||
  echo 'restore of programs/13-Trees/scanadt.c failed'
  shar_count="`wc -c < 'programs/13-Trees/scanadt.c'`"
  test 10928 -eq "$shar_count" ||
    echo "programs/13-Trees/scanadt.c: original size 10928, current size $shar_count"
fi
# ============= programs/13-Trees/scanadt.h ==============
if test -f 'programs/13-Trees/scanadt.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/13-Trees/scanadt.h (file already exists)'
else
  echo 'x - extracting programs/13-Trees/scanadt.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/13-Trees/scanadt.h' &&
/*
X * File: scanadt.h
X * ---------------
X * This file is the interface to a module that exports an abstract
X * data type to facilitate dividing a string into logical units
X * called "tokens," which are either
X *
X * 1. Strings of consecutive letters and digits representing words
X * 2. One-character strings representing punctuation or separators
X *
X * To use this package, you must first create an instance of a
X * scannerADT by calling
X *
X *      scanner = NewScanner();
X *
X * All other calls to the scanner package take this variable as their
X * first argument to identify a particular instance of the abstract
X * scanner type.
X *
X * You initialize the scanner to hold a particular string by calling
X *
X *      SetScannerString(scanner, str);
X *
X * where str is the string from which tokens should be read.  To
X * retrieve each individual token, you make the following call:
X *
X *      token = ReadToken(scanner);
X *
X * To determine whether any tokens remain to be read, you can call
X * the predicate function MoreTokensExist(scanner).  The ReadToken
X * function returns the empty string after the last token is read.
X *
X * The following code fragment serves as an idiom for processing
X * each token in the string inputString:
X *
X *      scanner = NewScanner();
X *      SetScannerString(scanner, inputString);
X *      while (MoreTokensExist(scanner)) {
X *          token = ReadToken(scanner);
X *          . . . process the token . . .
X *      }
X *
X * This version of scanadt.h also supports the following extensions,
X * which are documented later in the interface:
X *
X *   SaveToken
X *   SetScannerSpaceOption
X *   SetScannerStringOption
X *   SetScannerNumberOption
X */
X
#ifndef _scanadt_h
#define _scanadt_h
X
#include "genlib.h"
X
/*
X * Type: scannerADT
X * ----------------
X * This type is the abstract type used to represent a single instance
X * of a scanner.  As with any abstract type, the details of the
X * internal representation are hidden from the client.
X */
X
typedef struct scannerCDT *scannerADT;
X
/*
X * Function: NewScanner
X * Usage: scanner = NewScanner();
X * ------------------------------
X * This function creates a new scanner instance.  All other functions
X * in this interface take this scanner value as their first argument
X * so that they can identify what particular instance of the scanner
X * is in use.  This design makes it possible for clients to have more
X * than one scanner process active at the same time.
X */
X
scannerADT NewScanner(void);
X
/*
X * Function: FreeScanner
X * Usage: FreeScanner(scanner);
X * ----------------------------
X * This function frees the storage associated with scanner.
X */
X
void FreeScanner(scannerADT scanner);
X
/*
X * Function: SetScannerString
X * Usage: SetScannerString(scanner, str);
X * --------------------------------------
X * This function initializes the scanner so that it will start
X * extracting tokens from the string str.
X */
X
void SetScannerString(scannerADT scanner, string str);
X
/*
X * Function: ReadToken
X * Usage: token = ReadToken(scanner);
X * ----------------------------------
X * This function returns the next token from scanner.  If
X * ReadToken is called when no tokens are available, it returns
X * the empty string.  The token returned by ReadToken is always
X * allocated in the heap, which means that clients can call
X * FreeBlock when the token is no longer needed.
X */
X
string ReadToken(scannerADT scanner);
X
/*
X * Function: MoreTokensExist
X * Usage: if (MoreTokensExist(scanner)) . . .
X * ------------------------------------------
X * This function returns TRUE as long as there are additional
X * tokens for the scanner to read.
X */
X
bool MoreTokensExist(scannerADT scanner);
X
/*
X * Function: SaveToken
X * Usage: SaveToken(scanner, token);
X * ---------------------------------
X * This function stores the token in the scanner data structure
X * in such a way that the next time ReadToken is called, it will
X * return that token without reading any additional characters
X * from the input.
X */
X
void SaveToken(scannerADT scanner, string token);
X
/*
X * Functions: SetScannerSpaceOption, GetScannerSpaceOption
X * Usage: SetScannerSpaceOption(scanner, option);
X *        option = GetScannerSpaceOption(scanner);
X * -----------------------------------------------
X * The SetScannerSpaceOption function controls whether the scanner
X * ignores whitespace characters or treats them as valid tokens.
X * By default, the ReadToken function treats whitespace characters,
X * such as spaces and tabs, just like any other punctuation mark.
X * If, however, you call
X *
X *    SetScannerSpaceOption(scanner, IgnoreSpaces);
X *
X * the scanner will skip over any white space before reading a token.
X * You can restore the original behavior by calling
X *
X *    SetScannerSpaceOption(scanner, PreserveSpaces);
X *
X * The GetScannerSpaceOption function returns the current setting
X * of this option.
X */
X
typedef enum { PreserveSpaces, IgnoreSpaces } spaceOptionT;
X
void SetScannerSpaceOption(scannerADT scanner, spaceOptionT option);
spaceOptionT GetScannerSpaceOption(scannerADT scanner);
X
/*
X * Functions: SetScannerNumberOption, GetScannerNumberOption
X * Usage: SetScannerNumberOption(scanner, option);
X *        option = GetScannerNumberOption(scanner);
X * ------------------------------------------------
X * This function controls whether the scanner treats numeric values
X * specially.  The default behavior for the scanner is to treat
X * digits as equivalent to letters.  If you call
X *
X *    SetScannerNumberOption(scanner, ScanNumbersAsIntegers);
X *
X * a token beginning with a digit will end at the first nondigit.
X * (Note that digits can still be scanned as part of a token as in
X * the token "x1".)  If you call
X *
X *    SetScannerNumberOption(scanner, ScanNumbersAsReals);
X *
X * the scanner will return the longest token string that represents
X * a real number, if the next character to be scanned is a digit.
X * The format for a real number is a sequence of digit characters
X * that may include at most one decimal point, optionally followed
X * by the letter 'E' in either upper- or lowercase, an optional sign,
X * and an exponent.  You can restore the default behavior by calling
X *
X *    SetScannerNumberOption(scanner, ScanNumbersAsLetters);
X *
X * Even if the number options are enabled, ReadToken always returns
X * its result as a string, which means that you need to call
X * StringToInteger or StringToReal to convert the token to a number.
X */
X
typedef enum {
X    ScanNumbersAsLetters,
X    ScanNumbersAsIntegers,
X    ScanNumbersAsReals
} numberOptionT;
X
void SetScannerNumberOption(scannerADT scanner, numberOptionT option);
numberOptionT GetScannerNumberOption(scannerADT scanner);
X
/*
X * Functions: SetScannerStringOption, GetScannerStringOption
X * Usage: SetScannerStringOption(scanner, option);
X *        option = GetScannerStringOption(scanner);
X * ------------------------------------------------
X * This function controls how the scanner treats double quotation
X * marks in the input.  The default behavior for the scanner is
X * to treat quotes just like any other punctuation character.
X * If, however, you call
X *
X *    SetScannerStringOption(scanner, ScanQuotesAsStrings);
X *
X * a token beginning with a quotation mark will be scanned up to
X * the closing quotation mark.  The quotation marks are returned
X * as part of the scanned token so that clients can differentiate
X * strings from other token types.  The original behavior can be
X * restored by calling
X *
X *    SetScannerStringOption(scanner, ScanQuotesAsPunctuation);
X *
X * When scanning a string, the scanner recognizes the standard
X * escape sequences from ANSI C, such as \n and \t.
X */
X
typedef enum {
X    ScanQuotesAsPunctuation,
X    ScanQuotesAsStrings
} stringOptionT;
X
void SetScannerStringOption(scannerADT scanner, stringOptionT option);
stringOptionT GetScannerStringOption(scannerADT scanner);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/13-Trees/scanadt.h' &&
  chmod 0644 'programs/13-Trees/scanadt.h' ||
  echo 'restore of programs/13-Trees/scanadt.h failed'
  shar_count="`wc -c < 'programs/13-Trees/scanadt.h'`"
  test 7862 -eq "$shar_count" ||
    echo "programs/13-Trees/scanadt.h: original size 7862, current size $shar_count"
fi
# ============= programs/13-Trees/symtab.h ==============
if test -f 'programs/13-Trees/symtab.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/13-Trees/symtab.h (file already exists)'
else
  echo 'x - extracting programs/13-Trees/symtab.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/13-Trees/symtab.h' &&
/*
X * File: symtab.h
X * --------------
X * This interface exports a simple symbol table abstraction.
X */
X
#ifndef _symtab_h
#define _symtab_h
X
#include "genlib.h"
X
/*
X * Type: symtabADT
X * ---------------
X * This type is the ADT used to represent a symbol table.
X */
X
typedef struct symtabCDT *symtabADT;
X
/*
X * Type: symtabFnT
X * ---------------
X * This type defines the class of functions that can be used to
X * map over the entries in a symbol table.
X */
X
typedef void (*symtabFnT)(string key, void *value,
X                          void *clientData);
X
/* Exported entries */
X
/*
X * Function: NewSymbolTable
X * Usage: table = NewSymbolTable();
X * --------------------------------
X * This function allocates a new symbol table with no entries.
X */
X
symtabADT NewSymbolTable(void);
X
/*
X * Function: FreeSymbolTable
X * Usage: FreeSymbolTable(table);
X * ------------------------------
X * This function frees the storage associated with the symbol table.
X */
X
void FreeSymbolTable(symtabADT table);
X
/*
X * Function: Enter
X * Usage: Enter(table, key, value);
X * --------------------------------
X * This function associates key with value in the symbol table.
X * Each call to Enter supersedes any previous definition for key.
X */
X
void Enter(symtabADT table, string key, void *value);
X
/*
X * Function: Lookup
X * Usage: value = Lookup(table, key);
X * ----------------------------------
X * This function returns the value associated with key in the symbol
X * table, or UNDEFINED, if no such value exists.
X */
X
void *Lookup(symtabADT table, string key);
X
/*
X * Function: DeleteSymbol
X * Usage: DeleteSymbol(table, key);
X * --------------------------------
X * This function removes the most recent definition of key,
X * reexposing the previous one.  If no definition exists for
X * key, DeleteSymbol simply returns without taking any action.
X */
X
void DeleteSymbol(symtabADT table, string key);
X
/*
X * Function: MapSymbolTable
X * Usage: MapSymbolTable(fn, table, clientData);
X * ---------------------------------------------
X * This function goes through every entry in the symbol table
X * and calls the function fn, passing it the following arguments:
X * the current key, its associated value, and the clientData
X * pointer.  The clientData pointer allows the client to pass
X * additional state information to the function fn, if necessary.
X * If no clientData argument is required, this value should be NULL.
X */
X
void MapSymbolTable(symtabFnT fn, symtabADT table,
X                    void *clientData);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/13-Trees/symtab.h' &&
  chmod 0644 'programs/13-Trees/symtab.h' ||
  echo 'restore of programs/13-Trees/symtab.h failed'
  shar_count="`wc -c < 'programs/13-Trees/symtab.h'`"
  test 2504 -eq "$shar_count" ||
    echo "programs/13-Trees/symtab.h: original size 2504, current size $shar_count"
fi
# ============= programs/13-Trees/symtest.c ==============
if test -f 'programs/13-Trees/symtest.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/13-Trees/symtest.c (file already exists)'
else
  echo 'x - extracting programs/13-Trees/symtest.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/13-Trees/symtest.c' &&
/*
X * File: symtest.c
X * ---------------
X * This program tests the symbol table and cmdtable abstractions.
X * For a description of the legal commands, see the definition
X * of HelpCmdFn.
X */
X
#include <stdio.h>
#include <ctype.h>
#include "genlib.h"
#include "strlib.h"
#include "simpio.h"
#include "symtab.h"
#include "iterator.h"
#include "scanadt.h"
#include "cmdscan.h"
X
/* Private function prototypes */
X
static void InitCommandTable(cmdScannerADT cs);
static void LookupCmdFn(cmdScannerADT cs);
static void EnterCmdFn(cmdScannerADT cs);
static void ClearCmdFn(cmdScannerADT cs);
static void ListCmdFn(cmdScannerADT cs);
static void HelpCmdFn(cmdScannerADT cs);
static void CheckForExtraTokens(cmdScannerADT cs);
X
/* Main program */
X
main()
{
X    cmdScannerADT cs;
X
X    printf("Test program for the symbol table package\n");
X    cs = NewCommandScanner();
X    SetCommandData(cs, NewSymbolTable());
X    InitCommandTable(cs);
X    CommandLoop(cs, "-> ");
X    FreeSymbolTable(GetCommandData(cs));
X    FreeCommandScanner(cs);
}
X
static void InitCommandTable(cmdScannerADT cs)
{
X    DefineCommand(cs, "lookup", LookupCmdFn);
X    DefineCommand(cs, "enter",  EnterCmdFn);
X    DefineCommand(cs, "clear",  ClearCmdFn);
X    DefineCommand(cs, "list",   ListCmdFn);
X    DefineCommand(cs, "help",   HelpCmdFn);
X    DefineCommand(cs, "quit",   QuitCmdFn);
}
X
static void LookupCmdFn(cmdScannerADT cs)
{
X    symtabADT table;
X    string key, value;
X
X    table = GetCommandData(cs);
X    key = ReadCommandToken(cs);
X    CheckForExtraTokens(cs);
X    value = Lookup(table, key);
X    if (value == UNDEFINED) {
X        printf("'%s' is undefined.\n", key);
X    } else {
X        printf("%s\n", value);
X    }
}
X
static void EnterCmdFn(cmdScannerADT cs)
{
X    symtabADT table;
X    string key, token, value;
X
X    table = GetCommandData(cs);
X    key = ReadCommandToken(cs);
X    token = ReadCommandToken(cs);
X    if (!StringEqual(token, "=")) Error("Enter: Missing =");
X    value = ReadCommandToken(cs);
X    CheckForExtraTokens(cs);
X    Enter(table, key, value);
}
X
static void ClearCmdFn(cmdScannerADT cs)
{
X    CheckForExtraTokens(cs);
X    FreeSymbolTable(GetCommandData(cs));
X    SetCommandData(cs, NewSymbolTable());
}
X
static void ListCmdFn(cmdScannerADT cs)
{
X    symtabADT table;
X    string key, value;
X    iteratorADT iterator;
X
X    CheckForExtraTokens(cs);
X    table = GetCommandData(cs);
X    iterator = NewIterator(table);
X    while (StepIterator(iterator, &key)) {
X        value = Lookup(table, key);
X        printf("%s = %s\n", key, value);
X    }
X    FreeIterator(iterator);
}
X
static void HelpCmdFn(cmdScannerADT cs)
{
X    printf("Legal commands:\n");
X    printf("  enter key = value   Enter new value for key\n");
X    printf("  lookup key          Lookup the current value of key\n");
X    printf("  clear               Clear all entries from the table\n");
X    printf("  list                List the defined symbols\n");
X    printf("  help                Generate a list of commands\n");
X    printf("  quit                Exit from the program\n");
}
X
static void CheckForExtraTokens(cmdScannerADT cs)
{
X    string token;
X
X    token = ReadCommandToken(cs);
X    if (!StringEqual(token, "")) {
X        Error("%s: Found %s when expecting end of line",
X              GetCommandName(cs), token);
X    }
}
SHAR_EOF
  $shar_touch -am 0905212497 'programs/13-Trees/symtest.c' &&
  chmod 0644 'programs/13-Trees/symtest.c' ||
  echo 'restore of programs/13-Trees/symtest.c failed'
  shar_count="`wc -c < 'programs/13-Trees/symtest.c'`"
  test 3287 -eq "$shar_count" ||
    echo "programs/13-Trees/symtest.c: original size 3287, current size $shar_count"
fi
# ============= programs/13-Trees/Makefile ==============
if test -f 'programs/13-Trees/Makefile' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/13-Trees/Makefile (file already exists)'
else
  echo 'x - extracting programs/13-Trees/Makefile (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/13-Trees/Makefile' &&
# Makefile for programs in directory 13-Trees
# ***************************************************************
X
PROGRAMS = \
X    avltree \
X    bsttest \
X    introbst \
X    symtest
X
# ***************************************************************
# Parameters to control Makefile operation
# Note that the gccx command script must be defined
X
CC = gccx
CFLAGS = 
X
# ***************************************************************
# Entry to bring the package up to date
X
all: $(PROGRAMS)
X
# ***************************************************************
# Standard entries to remove files from the directories
#    tidy    -- eliminate unwanted files
#    scratch -- delete derived files in preparation for rebuild
X
tidy:
X	rm -f ,* .,* *~ core a.out graphics.ps
X
scratch: tidy
X	rm -f *.o *.a $(PROGRAMS)
X
# ***************************************************************
# C compilations
X
avltree.o: avltree.c
X	$(CC) $(CFLAGS) -c avltree.c
X
bst.o: bst.c bst.h cmpfn.h
X	$(CC) $(CFLAGS) -c bst.c
X
bsttab.o: bsttab.c bst.h cmpfn.h symtab.h
X	$(CC) $(CFLAGS) -c bsttab.c
X
bsttest.o: bsttest.c bst.h cmpfn.h scanadt.h
X	$(CC) $(CFLAGS) -c bsttest.c
X
cmdscan.o: cmdscan.c cmdscan.h scanadt.h symtab.h
X	$(CC) $(CFLAGS) -c cmdscan.c
X
cmpfn.o: cmpfn.c cmpfn.h
X	$(CC) $(CFLAGS) -c cmpfn.c
X
introbst.o: introbst.c
X	$(CC) $(CFLAGS) -c introbst.c
X
iterator.o: iterator.c iterator.h symtab.h
X	$(CC) $(CFLAGS) -c iterator.c
X
scanadt.o: scanadt.c scanadt.h
X	$(CC) $(CFLAGS) -c scanadt.c
X
symtab.o: symtab.c symtab.h
X	$(CC) $(CFLAGS) -c symtab.c
X
symtest.o: symtest.c cmdscan.h iterator.h scanadt.h symtab.h
X	$(CC) $(CFLAGS) -c symtest.c
X
X
# ***************************************************************
# Executable programs
X
avltree: avltree.o
X	$(CC) $(CFLAGS) -o avltree avltree.o
X
bsttest: bsttest.o bst.o cmpfn.o scanadt.o
X	$(CC) $(CFLAGS) -o bsttest bsttest.o bst.o cmpfn.o scanadt.o
X
introbst: introbst.o
X	$(CC) $(CFLAGS) -o introbst introbst.o
X
symtest: symtest.o cmdscan.o iterator.o scanadt.o symtab.o
X	$(CC) $(CFLAGS) -o symtest symtest.o cmdscan.o iterator.o scanadt.o symtab.o
X
SHAR_EOF
  $shar_touch -am 0905212797 'programs/13-Trees/Makefile' &&
  chmod 0644 'programs/13-Trees/Makefile' ||
  echo 'restore of programs/13-Trees/Makefile failed'
  shar_count="`wc -c < 'programs/13-Trees/Makefile'`"
  test 2076 -eq "$shar_count" ||
    echo "programs/13-Trees/Makefile: original size 2076, current size $shar_count"
fi
# ============= programs/13-Trees/cmdscan.c ==============
if test -f 'programs/13-Trees/cmdscan.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/13-Trees/cmdscan.c (file already exists)'
else
  echo 'x - extracting programs/13-Trees/cmdscan.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/13-Trees/cmdscan.c' &&
/*
X * File: cmdscan.c
X * ---------------
X * This file implements the cmdscan.h interface.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "exception.h"
#include "strlib.h"
#include "simpio.h"
#include "symtab.h"
#include "scanadt.h"
#include "cmdscan.h"
X
/*
X * Type: cmdScannerCDT
X * -------------------
X * This type defines the concrete structure of the command scanner.
X */
X
struct cmdScannerCDT {
X    string line;
X    string cmdName;
X    symtabADT cmdTable;
X    scannerADT scanner;
X    void *data;
X    bool quit;
};
X
/*
X * Type: cmdEntryT
X * ---------------
X * This type defines the entry for an individual command.
X */
X
typedef struct {
X    string cmdName;
X    cmdFnT cmdFn;
} *cmdEntryT;
X
/* Exported entries */
X
cmdScannerADT NewCommandScanner(void)
{
X    cmdScannerADT cs;
X
X    cs = New(cmdScannerADT);
X    cs->cmdTable = NewSymbolTable();
X    cs->scanner = NewScanner();
X    SetScannerSpaceOption(cs->scanner, IgnoreSpaces);
X    cs->data = NULL;
X    cs->quit = FALSE;
X    return (cs);
}
X
void FreeCommandScanner(cmdScannerADT cs)
{
X    FreeSymbolTable(cs->cmdTable);
X    FreeScanner(cs->scanner);
X    FreeBlock(cs);
}
X
void DefineCommand(cmdScannerADT cs, string cmdName, cmdFnT cmdFn)
{
X    cmdEntryT entry;
X    int len;
X
X    entry = New(cmdEntryT);
X    entry->cmdName = CopyString(cmdName);
X    entry->cmdFn = cmdFn;
X    Enter(cs->cmdTable, cmdName, entry);
}
X
void SetCommandData(cmdScannerADT cs, void *data)
{
X    cs->data = data;
}
X
void *GetCommandData(cmdScannerADT cs)
{
X    return (cs->data);
}
X
string ReadCommandToken(cmdScannerADT cs)
{
X    return (ReadToken(cs->scanner));
}
X
string GetCommandLine(cmdScannerADT cs)
{
X    return (CopyString(cs->line));
}
X
string GetCommandName(cmdScannerADT cs)
{
X    return (CopyString(cs->cmdName));
}
X
scannerADT GetTokenScanner(cmdScannerADT cs)
{
X    return (cs->scanner);
}
X
void CommandLoop(cmdScannerADT cs, string prompt)
{
X    while (!cs->quit) {
X        printf("%s", prompt);
X        try {
X            if (!ExecuteCommand(cs, GetLine())) {
X                printf("Illegal command: %s\n", cs->line);
X            }
X          except(ErrorException)
X            printf("Error: %s\n", (string) GetExceptionValue());
X        } endtry
X    }
}
X
bool ExecuteCommand(cmdScannerADT cs, string line)
{
X    cmdEntryT entry;
X
X    cs->line = line;
X    SetScannerString(cs->scanner, line);
X    cs->cmdName = ReadToken(cs->scanner);
X    entry = Lookup(cs->cmdTable, cs->cmdName);
X    if (entry == UNDEFINED) return (FALSE);
X    entry->cmdFn(cs);
X    return (TRUE);
}
X
void QuitCmdFn(cmdScannerADT cs)
{
X    cs->quit = TRUE;
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/13-Trees/cmdscan.c' &&
  chmod 0644 'programs/13-Trees/cmdscan.c' ||
  echo 'restore of programs/13-Trees/cmdscan.c failed'
  shar_count="`wc -c < 'programs/13-Trees/cmdscan.c'`"
  test 2581 -eq "$shar_count" ||
    echo "programs/13-Trees/cmdscan.c: original size 2581, current size $shar_count"
fi
# ============= programs/13-Trees/cmdscan.h ==============
if test -f 'programs/13-Trees/cmdscan.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/13-Trees/cmdscan.h (file already exists)'
else
  echo 'x - extracting programs/13-Trees/cmdscan.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/13-Trees/cmdscan.h' &&
/*
X * File: cmdscan.h
X * ---------------
X * This interface provides a simple command-scanning interface
X * that is primarily used to construct test programs.  The
X * typical pattern of use requires the following steps:
X *
X * 1. Call NewCommandScanner to create an empty command scanner.
X * 2. Call DefineCommand to associate commands with functions.
X * 3. Call CommandLoop to execute a command loop.
X */
X
#ifndef _cmdscan_h
#define _cmdscan_h
X
#include "genlib.h"
#include "scanadt.h"
X
/*
X * Type: cmdScannerADT
X * -------------------
X * This abstract type represents the command scanner.
X */
X
typedef struct cmdScannerCDT *cmdScannerADT;
X
/*
X * Type: cmdFnT
X * ------------
X * This type represents the space of functions that can be used
X * as commands.  Each command takes the entire command scanner
X * as an argument, which gives the callback function access to
X * the various data fields associated with the scanner.
X */
X
typedef void (*cmdFnT)(cmdScannerADT cs);
X
/*
X * Functions: NewCommandScanner, FreeCommandScanner
X * Usage: cs = NewCommandScanner();
X *        FreeCommandScanner(cs);
X * ------------------------------------------------
X * These functions allocate and free command scanners.
X */
X
cmdScannerADT NewCommandScanner(void);
void FreeCommandScanner(cmdScannerADT cs);
X
/*
X * Function: DefineCommand
X * Usage: DefineCommand(cs, cmdName, cmdFn);
X * -----------------------------------------
X * This function adds an entry to the internal command table for
X * the command scanner that associates the command name with the
X * specified function.
X */
X
void DefineCommand(cmdScannerADT cs, string cmdName, cmdFnT cmdFn);
X
/*
X * Function: CommandLoop
X * Usage: CommandLoop(cs, prompt);
X * -------------------------------
X * This function executes a simple command loop that repeatedly
X *
X * 1. Prints the specified prompt
X * 2. Reads in a line from the user
X * 3. Checks to see if the first token on the line is a command
X * 4. Executes the function associated with that command
X *
X * If a command is undefined, CommandLoop displays a message
X * to that effect and allows the user to enter a new command.
X */
X
void CommandLoop(cmdScannerADT cs, string prompt);
X
/*
X * Function: ExecuteCommand
X * Usage: ok = ExecuteCommand(cs, line);
X * -------------------------------------
X * This function executes a command line as if it were entered
X * by the user.  The function returns TRUE if the command is
X * defined, and FALSE otherwise.
X */
X
bool ExecuteCommand(cmdScannerADT cs, string line);
X
/*
X * Functions: SetCommandData, GetCommandData
X * Usage: SetCommandData(cs, data);
X *        data = GetCommandData(cs);
X * ------------------------------------------
X * These functions make it possible for the client to associate
X * a data block with the command scanner, which makes it available
X * to the callback functions used for the individual commands.
X */
X
void SetCommandData(cmdScannerADT cs, void *data);
void *GetCommandData(cmdScannerADT cs);
X
/*
X * Function: ReadCommandToken(cs);
X * Usage: token = ReadCommandToken(cs);
X * ------------------------------------
X * This function returns the next token from the command line.  If
X * no more tokens exist, ReadCommandToken returns the empty string.
X */
X
string ReadCommandToken(cmdScannerADT cs);
X
/*
X * Functions: GetCommandLine, GetCommandName, GetTokenScanner
X * Usage: line = GetCommandLine(cs);
X *        name = GetCommandName(cs);
X *        scanner = GetTokenScanner(cs);
X * ----------------------------------------------------------
X * These functions return the current command line, the current
X * command name, and the token scanner used by the command
X * processor.  Providing these values to the client makes it
X * possible to perform more sophisticated command analysis than
X * is possible with ReadCommandToken alone.
X */
X
string GetCommandLine(cmdScannerADT cs);
string GetCommandName(cmdScannerADT cs);
scannerADT GetTokenScanner(cmdScannerADT cs);
X
/*
X * Function: QuitCmdFn
X * Usage: DefineCommand(cs, "quit", QuitCmdFn);
X * --------------------------------------------
X * This callback function is exported by the command scanner
X * interface so that clients can define a command that exits
X * from the command loop.
X */
X
void QuitCmdFn(cmdScannerADT cs);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/13-Trees/cmdscan.h' &&
  chmod 0644 'programs/13-Trees/cmdscan.h' ||
  echo 'restore of programs/13-Trees/cmdscan.h failed'
  shar_count="`wc -c < 'programs/13-Trees/cmdscan.h'`"
  test 4248 -eq "$shar_count" ||
    echo "programs/13-Trees/cmdscan.h: original size 4248, current size $shar_count"
fi
# ============= programs/13-Trees/iterator.c ==============
if test -f 'programs/13-Trees/iterator.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/13-Trees/iterator.c (file already exists)'
else
  echo 'x - extracting programs/13-Trees/iterator.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/13-Trees/iterator.c' &&
/*
X * File: iterator.c
X * ----------------
X * This file implements an iterator for the symbol table
X * abstraction.  In Chapter 14, this package is superseded
X * by a more general polymorphic iterator that also works for
X * other types that represent collections.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "strlib.h"
#include "symtab.h"
#include "iterator.h"
X
/*
X * Type: cellT
X * -----------
X * This type defines a linked list cell for the iterator.
X */
X
typedef struct cellT {
X    string key;
X    struct cellT *link;
} cellT;
X
/*
X * Type: iteratorCDT
X * -----------------
X * This type provides the concrete representation for the
X * iterator, which is simply a linked list.
X */
X
struct iteratorCDT {
X    cellT *start;
};
X
/* Private function declarations */
X
static void InsertKey(string key, void *value, void *clientData);
X
/* Public entries */
X
iteratorADT NewIterator(symtabADT table)
{
X    iteratorADT iterator;
X
X    iterator = New(iteratorADT);
X    iterator->start = NULL;
X    MapSymbolTable(InsertKey, table, iterator);
X    return (iterator);
}
X
bool StepIterator(iteratorADT iterator, string *pKey)
{
X    cellT *cp;
X
X    cp = iterator->start;
X    if (cp == NULL) return (FALSE);
X    *pKey = cp->key;
X    iterator->start = cp->link;
X    FreeBlock(cp);
X    return (TRUE);
}
X
void FreeIterator(iteratorADT iterator)
{
X    cellT *cp;
X
X    while ((cp = iterator->start) != NULL) {
X        iterator->start = cp->link;
X        FreeBlock(cp);
X    }
X    FreeBlock(iterator);
}
X
/* Private functions */
X
/*
X * Function: InsertKey
X * Usage: MapSymbolTable(InsertKey, table, iterator);
X * --------------------------------------------------
X * This function is a callback function called by MapSymbolTable
X * on every entry in a symbol table.  Its effect is to insert
X * the current key into the linked list so that the order of the
X * keys is maintained in sorted order.  The code is a simple
X * find-and-insert loop that ends with prev and next pointing to
X * the cells on each side of the insertion point.  As a special
X * case, a NULL value for prev indicates insertion at the beginning.
X */
X
static void InsertKey(string key, void *value, void *clientData)
{
X    iteratorADT iterator;
X    cellT *prev, *next, *cp;
X
X    iterator = (iteratorADT) clientData;
X    prev = NULL;
X    next = iterator->start;
X    while (next != NULL && StringCompare(key, next->key) > 0) {
X        prev = next;
X        next = next->link;
X    }
X    cp = New(cellT *);
X    cp->key = key;
X    cp->link = next;
X    if (prev == NULL) {
X        iterator->start = cp;
X    } else {
X        prev->link = cp;
X    }
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/13-Trees/iterator.c' &&
  chmod 0644 'programs/13-Trees/iterator.c' ||
  echo 'restore of programs/13-Trees/iterator.c failed'
  shar_count="`wc -c < 'programs/13-Trees/iterator.c'`"
  test 2595 -eq "$shar_count" ||
    echo "programs/13-Trees/iterator.c: original size 2595, current size $shar_count"
fi
# ============= programs/13-Trees/iterator.h ==============
if test -f 'programs/13-Trees/iterator.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/13-Trees/iterator.h (file already exists)'
else
  echo 'x - extracting programs/13-Trees/iterator.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/13-Trees/iterator.h' &&
/*
X * File: iterator.h
X * ----------------
X * This file implements an iterator for the symbol table
X * abstraction.  In the chapter on "Sets," this package is
X * superseded by a more general polymorphic iterator that
X * works for other collection types as well.
X */
X
#ifndef _iterator_h
#define _iterator_h
X
#include "genlib.h"
#include "symtab.h"
X
/*
X * Type: iteratorADT
X * -----------------
X * This abstract type is used to iterate over the elements
X * in a symbol table.
X */
X
typedef struct iteratorCDT *iteratorADT;
X
/* Exported entries */
X
/*
X * Functions: NewIterator, StepIterator, FreeIterator
X * Usage: iterator = NewIterator(table);
X *        while (StepIterator(iterator, &key)) {
X *            . . . body of loop involving key . . .
X *        }
X *        FreeIterator(iterator);
X * -------------------------------------------------
X * These functions make it possible to iterate over the keys
X * in a symbol table without having to call a mapping function.
X * The call to NewIterator creates a new iteratorADT that
X * contains all the keys in the table, arranged in ASCII order.
X * Each call to StepIterator advances the iterator and returns
X * the next key using the reference parameter.  StepIterator
X * returns TRUE until the keys are exhausted, after which it
X * returns FALSE.  The FreeIterator function releases any
X * storage associated with the iterator.
X */
X
iteratorADT NewIterator(symtabADT table);
bool StepIterator(iteratorADT iterator, string *pKey);
void FreeIterator(iteratorADT iterator);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/13-Trees/iterator.h' &&
  chmod 0644 'programs/13-Trees/iterator.h' ||
  echo 'restore of programs/13-Trees/iterator.h failed'
  shar_count="`wc -c < 'programs/13-Trees/iterator.h'`"
  test 1527 -eq "$shar_count" ||
    echo "programs/13-Trees/iterator.h: original size 1527, current size $shar_count"
fi
# ============= programs/13-Trees/symtab.c ==============
if test -f 'programs/13-Trees/symtab.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/13-Trees/symtab.c (file already exists)'
else
  echo 'x - extracting programs/13-Trees/symtab.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/13-Trees/symtab.c' &&
/*
X * File: symtab.c
X * --------------
X * This file implements the symbol table abstraction.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "strlib.h"
#include "symtab.h"
X
/*
X * Constants
X * ---------
X * NBuckets -- Number of buckets in the hash table
X */
X
#define NBuckets 101
X
/*
X * Type: cellT
X * -----------
X * This type defines a linked list cell for the symbol table.
X */
X
typedef struct cellT {
X    string key;
X    void *value;
X    struct cellT *link;
} cellT;
X
/*
X * Type: symtabCDT
X * ---------------
X * This type defines the underlying concrete representation for a
X * symtabADT.  These details are not relevant to and therefore
X * not exported to the client.  In this implementation, the
X * underlying structure is a hash table organized as an array of
X * "buckets," in which each bucket is a linked list of elements
X * that share the same hash code.
X */
X
struct symtabCDT {
X    cellT *buckets[NBuckets];
};
X
/* Private function declarations */
X
static void FreeBucketChain(cellT *cp);
static cellT *FindCell(cellT *cp, string s);
static int Hash(string s, int nBuckets);
X
/* Public entries */
X
symtabADT NewSymbolTable(void)
{
X    symtabADT table;
X    int i;
X
X    table = New(symtabADT);
X    for (i = 0; i < NBuckets; i++) {
X        table->buckets[i] = NULL;
X    }
X    return (table);
}
X
void FreeSymbolTable(symtabADT table)
{
X    int i;
X
X    for (i = 0; i < NBuckets; i++) {
X        FreeBucketChain(table->buckets[i]);
X    }
X    FreeBlock(table);
}
X
void Enter(symtabADT table, string key, void *value)
{
X    int bucket;
X    cellT *cp;
X
X    bucket = Hash(key, NBuckets);
X    cp = FindCell(table->buckets[bucket], key);
X    if (cp == NULL) {
X        cp = New(cellT *);
X        cp->key = CopyString(key);
X        cp->link = table->buckets[bucket];
X        table->buckets[bucket] = cp;
X    }
X    cp->value = value;
}
X
void *Lookup(symtabADT table, string key)
{
X    int bucket;
X    cellT *cp;
X
X    bucket = Hash(key, NBuckets);
X    cp = FindCell(table->buckets[bucket], key);
X    if (cp == NULL) return(UNDEFINED);
X    return (cp->value);
}
X
void MapSymbolTable(symtabFnT fn, symtabADT table,
X                    void *clientData)
{
X    int i;
X    cellT *cp;
X
X    for (i = 0; i < NBuckets; i++) {
X        for (cp = table->buckets[i]; cp != NULL; cp = cp->link) {
X            fn(cp->key, cp->value, clientData);
X        }
X    }
}
X
/* Private functions */
X
/*
X * Function: FreeBucketChain
X * Usage: FreeBucketChain(cp);
X * ---------------------------
X * This function takes a chain pointer and frees all the cells
X * in that chain.  Because the package makes copies of the keys,
X * this function must free the string storage as well.
X */
X
static void FreeBucketChain(cellT *cp)
{
X    cellT *next;
X
X    while (cp != NULL) {
X        next = cp->link;
X        FreeBlock(cp->key);
X        FreeBlock(cp);
X        cp = next;
X    }
}
X
/*
X * Function: FindCell
X * Usage: cp = FindCell(cp, key);
X * ------------------------------
X * This function finds a cell in the chain beginning at cp that
X * matches key.  If a match is found, a pointer to that cell is
X * returned.  If no match is found, the function returns NULL.
X */
X
static cellT *FindCell(cellT *cp, string key)
{
X    while (cp != NULL && !StringEqual(cp->key, key)) {
X        cp = cp->link;
X    }
X    return (cp);
}
X
/*
X * Function: Hash
X * Usage: bucket = Hash(key, nBuckets);
X * ------------------------------------
X * This function takes the key and uses it to derive a hash code,
X * which is an integer in the range [0, nBuckets - 1].  The hash
X * code is computed using a method called linear congruence.  The
X * choice of the value for Multiplier can have a significant effect
X * on the performance of the algorithm, but not on its correctness.
X */
X
#define Multiplier -1664117991L
X
static int Hash(string s, int nBuckets)
{
X    int i;
X    unsigned long hashcode;
X
X    hashcode = 0;
X    for (i = 0; s[i] != '\0'; i++) {
X        hashcode = hashcode * Multiplier + s[i];
X    }
X    return (hashcode % nBuckets);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/13-Trees/symtab.c' &&
  chmod 0644 'programs/13-Trees/symtab.c' ||
  echo 'restore of programs/13-Trees/symtab.c failed'
  shar_count="`wc -c < 'programs/13-Trees/symtab.c'`"
  test 3983 -eq "$shar_count" ||
    echo "programs/13-Trees/symtab.c: original size 3983, current size $shar_count"
fi
# ============= programs/14-Expression-Trees/eval.c ==============
if test ! -d 'programs/14-Expression-Trees'; then
  echo 'x - creating directory programs/14-Expression-Trees'
  mkdir 'programs/14-Expression-Trees'
fi
if test -f 'programs/14-Expression-Trees/eval.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/14-Expression-Trees/eval.c (file already exists)'
else
  echo 'x - extracting programs/14-Expression-Trees/eval.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/14-Expression-Trees/eval.c' &&
/*
X * File: eval.c
X * ------------
X * This file implements the eval.h interface.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "strlib.h"
#include "exp.h"
#include "eval.h"
#include "symtab.h"
X
/*
X * Private variable: variableTable
X * -------------------------------
X * This table keeps track of the values for each variable.
X */
X
static symtabADT variableTable;
X
/* Private function prototypes */
X
static int EvalCompound(expressionADT exp);
X
/* Exported entries */
X
int EvalExp(expressionADT exp)
{
X    switch (ExpType(exp)) {
X      case IntegerType:
X        return (ExpInteger(exp));
X      case IdentifierType:
X        return (GetIdentifierValue(ExpIdentifier(exp)));
X      case CompoundType:
X        return (EvalCompound(exp));
X    }
}
X
void InitVariableTable(void)
{
X    variableTable = NewSymbolTable();
}
X
int GetIdentifierValue(string name)
{
X    int *ip;
X
X    ip = Lookup(variableTable, name);
X    if (ip == UNDEFINED)  Error("%s is undefined", name);
X    return (*ip);
}
X
void SetIdentifierValue(string name, int value)
{
X    int *ip;
X
X    ip = New(int *);
X    *ip = value;
X    Enter(variableTable, name, ip);
}
X
/* Private functions */
X
static int EvalCompound(expressionADT exp)
{
X    char op;
X    int lhs, rhs;
X
X    op = ExpOperator(exp);
X    if (op == '=') {
X        rhs = EvalExp(ExpRHS(exp));
X        SetIdentifierValue(ExpIdentifier(ExpLHS(exp)), rhs);
X        return (rhs);
X    }
X    lhs = EvalExp(ExpLHS(exp));
X    rhs = EvalExp(ExpRHS(exp));
X    switch (op) {
X      case '+': return (lhs + rhs);
X      case '-': return (lhs - rhs);
X      case '*': return (lhs * rhs);
X      case '/': return (lhs / rhs);
X      default:  Error("Illegal operator");
X    }
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/14-Expression-Trees/eval.c' &&
  chmod 0644 'programs/14-Expression-Trees/eval.c' ||
  echo 'restore of programs/14-Expression-Trees/eval.c failed'
  shar_count="`wc -c < 'programs/14-Expression-Trees/eval.c'`"
  test 1682 -eq "$shar_count" ||
    echo "programs/14-Expression-Trees/eval.c: original size 1682, current size $shar_count"
fi
# ============= programs/14-Expression-Trees/eval.h ==============
if test -f 'programs/14-Expression-Trees/eval.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/14-Expression-Trees/eval.h (file already exists)'
else
  echo 'x - extracting programs/14-Expression-Trees/eval.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/14-Expression-Trees/eval.h' &&
/*
X * File: eval.h
X * ------------
X * This file is the interface to the evaluator module, which
X * computes the value represented by an expression.  This module
X * also maintains the state of the variables, which are only
X * updated or inspected during the evaluation phase.
X */
X
#ifndef _eval_h
#define _eval_h
X
#include "exp.h"
X
/*
X * Function: EvalExp
X * Usage: n = EvalExp(exp);
X * ------------------------
X * This function evaluates an expression and returns its value.
X */
X
int EvalExp(expressionADT exp);
X
/*
X * Function: InitVariableTable
X * Usage: InitVariableTable();
X * ---------------------------
X * This function initializes the table used to hold the variables.
X * All variables are initially undefined.
X */
X
void InitVariableTable(void);
X
/*
X * Function: GetIdentifierValue
X * Usage: value = GetIdentifierValue(name);
X * ----------------------------------------
X * This function returns the value of an identifier.
X */
X
int GetIdentifierValue(string name);
X
/*
X * Function: SetIdentifierValue
X * Usage: SetIdentifierValue(name, value);
X * ---------------------------------------
X * This function sets the identifier to have the specified value.
X */
X
void SetIdentifierValue(string name, int value);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/14-Expression-Trees/eval.h' &&
  chmod 0644 'programs/14-Expression-Trees/eval.h' ||
  echo 'restore of programs/14-Expression-Trees/eval.h failed'
  shar_count="`wc -c < 'programs/14-Expression-Trees/eval.h'`"
  test 1222 -eq "$shar_count" ||
    echo "programs/14-Expression-Trees/eval.h: original size 1222, current size $shar_count"
fi
# ============= programs/14-Expression-Trees/exp.c ==============
if test -f 'programs/14-Expression-Trees/exp.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/14-Expression-Trees/exp.c (file already exists)'
else
  echo 'x - extracting programs/14-Expression-Trees/exp.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/14-Expression-Trees/exp.c' &&
/*
X * File: exp.c
X * -----------
X * This file implements the exp.h interface.  The exported
X * functions are standard constructor and selector functions
X * that require no individual documentation.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "strlib.h"
#include "exp.h"
X
/*
X * Type: expressionCDT
X * -------------------
X * The type expressionCDT is the concrete counterpart of an
X * expressionADT.  The type is implemented as a pointer to a
X * node.  The value of the node consists of a tagged union that
X * allows the node to have multiple representations.
X */
X
struct expressionCDT {
X    exptypeT type;
X    union {
X        int intRep;
X        string idRep;
X        struct {
X            char op;
X            expressionADT lhs;
X            expressionADT rhs;
X        } compoundRep;
X    } value;
};
X
/* Constructor functions */
X
expressionADT NewIntegerExp(int n)
{
X    expressionADT exp;
X
X    exp = New(expressionADT);
X    exp->type = IntegerType;
X    exp->value.intRep = n;
X    return (exp);
}
X
expressionADT NewIdentifierExp(string id)
{
X    expressionADT exp;
X
X    exp = New(expressionADT);
X    exp->type = IdentifierType;
X    exp->value.idRep = CopyString(id);
X    return (exp);
}
X
expressionADT NewCompoundExp(char op,
X                             expressionADT lhs,
X                             expressionADT rhs)
{
X    expressionADT exp;
X
X    exp = New(expressionADT);
X    exp->type = CompoundType;
X    exp->value.compoundRep.op = op;
X    exp->value.compoundRep.lhs = lhs;
X    exp->value.compoundRep.rhs = rhs;
X    return (exp);
}
X
/* Selector functions */
X
exptypeT ExpType(expressionADT exp)
{
X    return (exp->type);
}
X
int ExpInteger(expressionADT exp)
{
X    if (ExpType(exp) != IntegerType) {
X        Error("Integer expression required");
X    }
X    return (exp->value.intRep);
}
X
string ExpIdentifier(expressionADT exp)
{
X    if (ExpType(exp) != IdentifierType) {
X        Error("Identifier expression required");
X    }
X    return (exp->value.idRep);
}
X
char ExpOperator(expressionADT exp)
{
X    if (ExpType(exp) != CompoundType) {
X        Error("Compound expression required");
X    }
X    return (exp->value.compoundRep.op);
}
X
expressionADT ExpLHS(expressionADT exp)
{
X    if (ExpType(exp) != CompoundType) {
X        Error("Compound expression required");
X    }
X    return (exp->value.compoundRep.lhs);
}
X
expressionADT ExpRHS(expressionADT exp)
{
X    if (ExpType(exp) != CompoundType) {
X        Error("Compound expression required");
X    }
X    return (exp->value.compoundRep.rhs);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/14-Expression-Trees/exp.c' &&
  chmod 0644 'programs/14-Expression-Trees/exp.c' ||
  echo 'restore of programs/14-Expression-Trees/exp.c failed'
  shar_count="`wc -c < 'programs/14-Expression-Trees/exp.c'`"
  test 2505 -eq "$shar_count" ||
    echo "programs/14-Expression-Trees/exp.c: original size 2505, current size $shar_count"
fi
# ============= programs/14-Expression-Trees/exp.h ==============
if test -f 'programs/14-Expression-Trees/exp.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/14-Expression-Trees/exp.h (file already exists)'
else
  echo 'x - extracting programs/14-Expression-Trees/exp.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/14-Expression-Trees/exp.h' &&
/*
X * File: exp.h
X * -----------
X * This interface defines an abstract type for expressions,
X * which allows the client to represent and manipulate simple
X * binary expression trees.
X */
X
#ifndef _exp_h
#define _exp_h
X
#include "genlib.h"
X
/*
X * Type: expressionADT
X * -------------------
X * This type is used to represent the abstract notion of an
X * expression, such as you might encounter in a C program.
X * An expression is defined recursively to be one of the
X * following:
X *
X * 1. A constant
X * 2. A string representing an identifier
X * 3. Two expressions combined by an operator
X */
X
typedef struct expressionCDT *expressionADT;
X
/*
X * Type: exptypeT
X * --------------
X * This enumeration type is used to differentiate the three
X * expression types: integers, identifiers, and compounds.
X */
X
typedef enum {
X    IntegerType,
X    IdentifierType,
X    CompoundType
} exptypeT;
X
/* Constructor functions */
X
/*
X * Function: NewIntegerExp
X * Usage: exp = NewIntegerExp(n);
X * ------------------------------
X * This function allocates a new expression node of type
X * IntegerType containing the integer n as its value.
X */
X
/*
X * Function: NewIntegerExp
X * Usage: exp = NewIntegerExp(n);
X * ------------------------------
X * This function allocates a new expression node of type
X * IntegerType containing the integer n as its value.
X */
X
expressionADT NewIntegerExp(int n);
X
/*
X * Function: NewIdentifierExp
X * Usage: exp = NewIdentifierExp(id);
X * ----------------------------------
X * This function allocates a new expression node of type
X * IdentifierType containing the specified id.
X */
X
expressionADT NewIdentifierExp(string id);
X
/*
X * Function: NewCompoundExp
X * Usage: exp = NewCompoundExp(op, lhs, rhs);
X * ------------------------------------------
X * This function allocates a new expression node of type
X * CompoundType, which is composed of the operator (op)
X * and the left and right subexpressions (lhs and rhs).
X */
X
expressionADT NewCompoundExp(char op,
X                             expressionADT lhs,
X                             expressionADT rhs);
X
/* Selector functions */
X
/*
X * Function: ExpType
X * Usage: tc = ExpType(exp);
X * -------------------------
X * This function returns the type of the expression.
X */
X
exptypeT ExpType(expressionADT exp);
X
X
/*
X * Function: ExpInteger
X * Usage: n = ExpInteger(exp);
X * ---------------------------
X * This function returns the integer stored in an expression,
X * which must be of type IntegerType.
X */
X
int ExpInteger(expressionADT exp);
X
/*
X * Function: ExpIdentifier
X * Usage: id = ExpIdentifier(exp);
X * -------------------------------
X * This function returns the identifier stored in an
X * expression, which must be of type IdentifierType.
X */
X
string ExpIdentifier(expressionADT exp);
X
/*
X * Function: ExpOperator
X * Usage: op = ExpOperator(exp);
X * -----------------------------
X * This function returns the operator stored in an expression,
X * which must be of type CompoundType.
X */
X
char ExpOperator(expressionADT exp);
X
/*
X * Functions: ExpLHS, ExpRHS
X * Usage: lhs = ExpLHS(exp);
X *        rhs = ExpRHS(exp);
X * -------------------------
X * These functions return the left and right subexpressions
X * from exp, which must be of type CompoundType.
X */
X
expressionADT ExpLHS(expressionADT exp);
expressionADT ExpRHS(expressionADT exp);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/14-Expression-Trees/exp.h' &&
  chmod 0644 'programs/14-Expression-Trees/exp.h' ||
  echo 'restore of programs/14-Expression-Trees/exp.h failed'
  shar_count="`wc -c < 'programs/14-Expression-Trees/exp.h'`"
  test 3322 -eq "$shar_count" ||
    echo "programs/14-Expression-Trees/exp.h: original size 3322, current size $shar_count"
fi
# ============= programs/14-Expression-Trees/interp.c ==============
if test -f 'programs/14-Expression-Trees/interp.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/14-Expression-Trees/interp.c (file already exists)'
else
  echo 'x - extracting programs/14-Expression-Trees/interp.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/14-Expression-Trees/interp.c' &&
/*
X * File: interp.c
X * --------------
X * This program simulates the top-level of a programming
X * language interpreter.  The program reads an expression,
X * evaluates the expression, and prints the result.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "strlib.h"
#include "simpio.h"
#include "exp.h"
#include "eval.h"
#include "parser.h"
#include "scanadt.h"
X
/* Main program */
X
main()
{
X    scannerADT scanner;
X    expressionADT exp;
X    string line;
X    int value;
X
X    InitVariableTable();
X    scanner = NewScanner();
X    SetScannerSpaceOption(scanner, IgnoreSpaces);
X    while (TRUE) {
X        printf("=> ");
X        line = GetLine();
X        if (StringEqual(line, "quit")) break;
X        SetScannerString(scanner, line);
X        exp = ParseExp(scanner);
X        value = EvalExp(exp);
X        printf("%d\n", value);
X    }
}
SHAR_EOF
  $shar_touch -am 0905212897 'programs/14-Expression-Trees/interp.c' &&
  chmod 0644 'programs/14-Expression-Trees/interp.c' ||
  echo 'restore of programs/14-Expression-Trees/interp.c failed'
  shar_count="`wc -c < 'programs/14-Expression-Trees/interp.c'`"
  test 837 -eq "$shar_count" ||
    echo "programs/14-Expression-Trees/interp.c: original size 837, current size $shar_count"
fi
# ============= programs/14-Expression-Trees/iverson.c ==============
if test -f 'programs/14-Expression-Trees/iverson.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/14-Expression-Trees/iverson.c (file already exists)'
else
  echo 'x - extracting programs/14-Expression-Trees/iverson.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/14-Expression-Trees/iverson.c' &&
/*
X * File: iverson.c
X * ---------------
X * This file implements a simple version of ReadExp that uses
X * the simple precedence rule that all operators have equal
X * precedence and are applied in right-to-left order.  Thus,
X * under this rule, the expression
X *
X *        x = 2 * x + y
X *
X * is interpreted as if it had been written
X *
X *        x = (2 * (x + y))
X *
X * with the operators executed strictly in right-to-left order.
X *
X * While this rule is different from conventional mathematical
X * practice and seems a bit bizarre, it is the precedence rule
X * used in the programming language APL, developed by Ken
X * Iverson in the 1960s.  The rule is called Iversonian
X * precedence after its inventor.
X *
X * Iversonian precedence has the advantage that it is very
X * easy to parse by using the following grammar:
X *
X *       E  ->  T
X *       E  ->  T op E
X *
X *       T  ->  integer
X *       T  ->  identifier
X *       T  ->  ( E )
X */
X
#include <stdio.h>
#include <ctype.h>
#include "genlib.h"
#include "strlib.h"
#include "simpio.h"
#include "scanadt.h"
#include "parser.h"
#include "exp.h"
X
/* Private function prototypes */
X
static expressionADT ReadE(scannerADT scanner);
static expressionADT ReadT(scannerADT scanner);
static bool IsOperator(string token);
X
/* Public entries */
X
/*
X * Implementation notes: ParseExp
X * ------------------------------
X * This function just calls ReadE to read an expression and then
X * checks to make sure no tokens are left over.
X */
X
expressionADT ParseExp(scannerADT scanner)
{
X    expressionADT exp;
X
X    exp = ReadE(scanner);
X    if (MoreTokensExist(scanner)) {
X        Error("ParseExp: %s unexpected", ReadToken(scanner));
X    }
X    return (exp);
}
X
/* Private functions */
X
/*
X * Implementation notes: ReadE
X * Usage: exp = ReadE(scanner);
X * ----------------------------
X * This function reads the next expression from the scanner by
X * matching the input to one of the following grammatical rules:
X *
X *       E  ->  T
X *       E  ->  T op E
X *
X * Both right-hand sides start with T, so the code can begin by
X * calling ReadT.  If the next token is an operator, the code
X * creates a compound expression from the term, the operator,
X * and the expression after the operator.
X */
X
static expressionADT ReadE(scannerADT scanner)
{
X    expressionADT exp, rhs;
X    string token;
X
X    exp = ReadT(scanner);
X    token = ReadToken(scanner);
X    if (IsOperator(token)) {
X        rhs = ReadE(scanner);
X        exp = NewCompoundExp(token[0], exp, rhs);
X    } else {
X        SaveToken(scanner, token);
X    }
X    return (exp);
}
X
/*
X * Function: ReadT
X * Usage: exp = ReadT(scanner);
X * ----------------------------
X * This function reads a single term from the scanner by matching
X * the input to one of the following grammatical rules:
X *
X *       T  ->  integer
X *       T  ->  identifier
X *       T  ->  ( E )
X *
X * In each case, the first token identifies the appropriate rule.
X */
X
static expressionADT ReadT(scannerADT scanner)
{
X    expressionADT exp;
X    string token;
X
X    token = ReadToken(scanner);
X    if (StringEqual(token, "(")) {
X        exp = ReadE(scanner);
X        if (!StringEqual(ReadToken(scanner), ")")) {
X            Error("Unbalanced parentheses");
X        }
X    } else if (isdigit(token[0])) {
X        exp = NewIntegerExp(StringToInteger(token));
X    } else if (isalpha(token[0])) {
X        exp = NewIdentifierExp(token);
X    } else {
X        Error("Illegal term in expression");
X    }
X    return (exp);
}
X
/*
X * Function: IsOperator
X * Usage: if (IsOperator(token)) . . .
X * -----------------------------------
X * This function returns TRUE if the token is a legal operator.
X */
X
static bool IsOperator(string token)
{
X    if (StringLength(token) != 1) return (FALSE);
X    switch (token[0]) {
X      case '+': case '-': case '*': case '/': case '=':
X        return (TRUE);
X      default:
X        return (FALSE);
X    }
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/14-Expression-Trees/iverson.c' &&
  chmod 0644 'programs/14-Expression-Trees/iverson.c' ||
  echo 'restore of programs/14-Expression-Trees/iverson.c failed'
  shar_count="`wc -c < 'programs/14-Expression-Trees/iverson.c'`"
  test 3889 -eq "$shar_count" ||
    echo "programs/14-Expression-Trees/iverson.c: original size 3889, current size $shar_count"
fi
# ============= programs/14-Expression-Trees/parser.c ==============
if test -f 'programs/14-Expression-Trees/parser.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/14-Expression-Trees/parser.c (file already exists)'
else
  echo 'x - extracting programs/14-Expression-Trees/parser.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/14-Expression-Trees/parser.c' &&
/*
X * File: parser.c
X * --------------
X * This file implements a version of ReadExp that uses
X * conventional precedence rules.  Thus, the expression
X *
X *        x = 2 * x + y
X *
X * is interpreted as if it had been written
X *
X *        x = ((2 * x) + y))
X *
X * This language can be parsed using the following ambiguous
X * grammar:
X *
X *       E  ->  T
X *       E  ->  E op E
X *
X *       T  ->  integer
X *       T  ->  identifier
X *       T  ->  ( E )
X *
X * Unfortunately, this grammar is not sufficient by itself.  The
X * parser must also provide some way to determine what operators
X * take precedence over others.  Moreover, it must avoid the
X * problem of going into an infinite recursion of trying to read
X * an expression by reading an expression, and so on forever.
X *
X * To solve these problems, this implementation passes a numeric
X * value to the ReadE function that specifies the precedence
X * level for the current subexpression.  As long as ReadE finds
X * operators with a higher precedence, it will read in those
X * operators along with the following subexpression.  If the
X * precedence of the new operator is the same or lower than
X * the prevailing precedence, ReadE returns to the next higher
X * level in the recursive-descent parsing and reads the operator
X * there.
X */
X
#include <stdio.h>
#include <ctype.h>
#include "genlib.h"
#include "strlib.h"
#include "simpio.h"
#include "scanadt.h"
#include "parser.h"
#include "exp.h"
X
/*
X * Implementation notes: ParseExp
X * ------------------------------
X * This function just calls ReadE to read an expression and then
X * checks to make sure no tokens are left over.
X */
X
expressionADT ParseExp(scannerADT scanner)
{
X    expressionADT exp;
X
X    exp = ReadE(scanner, 0);
X    if (MoreTokensExist(scanner)) {
X        Error("ParseExp: %s unexpected", ReadToken(scanner));
X    }
X    return (exp);
}
X
/*
X * Implementation notes: ReadE
X * Usage: exp = ReadE(scanner, prec);
X * ----------------------------------
X * This function reads an expression from the scanner stream,
X * stopping when it encounters an operator whose precedence is
X * less that or equal to prec.
X */
X
expressionADT ReadE(scannerADT scanner, int prec)
{
X    expressionADT exp, rhs;
X    string token;
X    int newPrec;
X
X    exp = ReadT(scanner);
X    while (TRUE) {
X        token = ReadToken(scanner);
X        newPrec = Precedence(token);
X        if (newPrec <= prec) break;
X        rhs = ReadE(scanner, newPrec);
X        exp = NewCompoundExp(token[0], exp, rhs);
X    }
X    SaveToken(scanner, token);
X    return (exp);
}
X
/*
X * Function: ReadT
X * Usage: exp = ReadT(scanner);
X * ----------------------------
X * This function reads a single term from the scanner by matching
X * the input to one of the following grammatical rules:
X *
X *       T  ->  integer
X *       T  ->  identifier
X *       T  ->  ( E )
X *
X * In each case, the first token identifies the appropriate rule.
X */
X
expressionADT ReadT(scannerADT scanner)
{
X    expressionADT exp;
X    string token;
X
X    token = ReadToken(scanner);
X    if (StringEqual(token, "(")) {
X        exp = ReadE(scanner, 0);
X        if (!StringEqual(ReadToken(scanner), ")")) {
X            Error("Unbalanced parentheses");
X        }
X    } else if (isdigit(token[0])) {
X        exp = NewIntegerExp(StringToInteger(token));
X    } else if (isalpha(token[0])) {
X        exp = NewIdentifierExp(token);
X    } else {
X        Error("Illegal term in expression");
X    }
X    return (exp);
}
X
int Precedence(string token)
{
X    if (StringLength(token) > 1) return (0);
X    switch (token[0]) {
X      case '=': return (1);
X      case '+': case '-': return (2);
X      case '*': case '/': return (3);
X      default:  return (0);
X    }
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/14-Expression-Trees/parser.c' &&
  chmod 0644 'programs/14-Expression-Trees/parser.c' ||
  echo 'restore of programs/14-Expression-Trees/parser.c failed'
  shar_count="`wc -c < 'programs/14-Expression-Trees/parser.c'`"
  test 3687 -eq "$shar_count" ||
    echo "programs/14-Expression-Trees/parser.c: original size 3687, current size $shar_count"
fi
# ============= programs/14-Expression-Trees/parser.h ==============
if test -f 'programs/14-Expression-Trees/parser.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/14-Expression-Trees/parser.h (file already exists)'
else
  echo 'x - extracting programs/14-Expression-Trees/parser.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/14-Expression-Trees/parser.h' &&
/*
X * File: parser.h
X * --------------
X * This file acts as the interface to the parser module, which
X * exports functions to parse expressions from a scanner.
X */
X
#ifndef _parser_h
#define _parser_h
X
#include "exp.h"
#include "scanadt.h"
X
/*
X * Function: ParseExp
X * Usage: exp = ParseExp(scanner);
X * -------------------------------
X * This function parses an expression by reading tokens from
X * the scanner, which must be provided by the client.
X */
X
expressionADT ParseExp(scannerADT scanner);
X
/*
X * Functions: ReadE, ReadT
X * Usage: exp = ReadE(scanner, prec);
X *        exp = ReadT(scanner);
X * ----------------------------------
X * These functions provide low-level entry points to the parser,
X * which are useful to clients who need to use expression
X * parsing in larger applications.  ReadE(scanner, prec) returns
X * the next expression involving operators whose precedence
X * is at least prec; ReadT returns the next individual term.
X */
X
expressionADT ReadE(scannerADT scanner, int prec);
expressionADT ReadT(scannerADT scanner);
X
/*
X * Function: Precedence
X * Usage: prec = Precedence(token);
X * --------------------------------
X * This function returns the precedence of the specified operator
X * token.  If the token is not an operator, Precedence returns 0.
X */
X
int Precedence(string token);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/14-Expression-Trees/parser.h' &&
  chmod 0644 'programs/14-Expression-Trees/parser.h' ||
  echo 'restore of programs/14-Expression-Trees/parser.h failed'
  shar_count="`wc -c < 'programs/14-Expression-Trees/parser.h'`"
  test 1320 -eq "$shar_count" ||
    echo "programs/14-Expression-Trees/parser.h: original size 1320, current size $shar_count"
fi
# ============= programs/14-Expression-Trees/scanadt.c ==============
if test -f 'programs/14-Expression-Trees/scanadt.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/14-Expression-Trees/scanadt.c (file already exists)'
else
  echo 'x - extracting programs/14-Expression-Trees/scanadt.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/14-Expression-Trees/scanadt.c' &&
/*
X * File: scanadt.c
X * ---------------
X * This file implements the scanadt.h interface.
X */
X
#include <stdio.h>
#include <ctype.h>
#include "genlib.h"
#include "strlib.h"
#include "scanadt.h"
X
/*
X * Type: scannerCDT
X * ----------------
X * This structure is the concrete representation of the type
X * scannerADT, which is exported by this interface.  Its purpose
X * is to maintain the state of the scanner between calls.  The
X * details of the representation are invisible to the client,
X * but consist of the following fields:
X *
X * str          -- Copy of string passed to SetScannerString
X * len          -- Length of string, saved for efficiency
X * cp           -- Current character position in the string
X * savedToken   -- String saved by SaveToken (NULL indicates none)
X * spaceOption  -- Setting of the space option extension
X * numberOption -- Setting of the number option extension
X * stringOption -- Setting of string option extension
X */
X
struct scannerCDT {
X    string str;
X    int len;
X    int cp;
X    string savedToken;
X    spaceOptionT spaceOption;
X    numberOptionT numberOption;
X    stringOptionT stringOption;
};
X
/* Private function prototypes */
X
static void SkipSpaces(scannerADT scanner);
static int ScanToEndOfIdentifier(scannerADT scanner);
static int ScanToEndOfInteger(scannerADT scanner);
static int ScanToEndOfReal(scannerADT scanner);
static string ScanQuotedString(scannerADT scanner);
static char ScanEscapeCharacter(scannerADT scanner);
X
/* Exported entries */
X
scannerADT NewScanner(void)
{
X    scannerADT scanner;
X
X    scanner = New(scannerADT);
X    scanner->str = NULL;
X    scanner->spaceOption = PreserveSpaces;
X    scanner->numberOption = ScanNumbersAsLetters;
X    scanner->stringOption = ScanQuotesAsPunctuation;
X    return (scanner);
}
X
void FreeScanner(scannerADT scanner)
{
X    if (scanner->str != NULL) FreeBlock(scanner->str);
X    FreeBlock(scanner);
}
X
void SetScannerString(scannerADT scanner, string str)
{
X    if (scanner->str != NULL) FreeBlock(scanner->str);
X    scanner->str = CopyString(str);
X    scanner->len = StringLength(str);
X    scanner->cp = 0;
X    scanner->savedToken = NULL;
}
X
string ReadToken(scannerADT scanner)
{
X    char ch;
X    string token;
X    int start, finish;
X
X    if (scanner->str == NULL) {
X        Error("SetScannerString has not been called");
X    }
X    if (scanner->savedToken != NULL) {
X        token = scanner->savedToken;
X        scanner->savedToken = NULL;
X        return (token);
X    }
X    if (scanner->spaceOption == IgnoreSpaces) SkipSpaces(scanner);
X    start = finish = scanner->cp;
X    if (start >= scanner->len) return (CopyString(""));
X    ch = scanner->str[scanner->cp];
X    if (scanner->stringOption == ScanQuotesAsStrings
X            && ch == '"') {
X        return (ScanQuotedString(scanner));
X    }
X    if (isdigit(ch)) {
X        switch (scanner->numberOption) {
X          case ScanNumbersAsLetters:
X            finish = ScanToEndOfIdentifier(scanner);
X            break;
X          case ScanNumbersAsIntegers:
X            finish = ScanToEndOfInteger(scanner);
X            break;
X          case ScanNumbersAsReals:
X            finish = ScanToEndOfReal(scanner);
X            break;
X        }
X    } else if (isalnum(ch)) {
X        finish = ScanToEndOfIdentifier(scanner);
X    } else {
X        scanner->cp++;
X    }
X    return (SubString(scanner->str, start, finish));
}
X
bool MoreTokensExist(scannerADT scanner)
{
X    if (scanner->str == NULL) {
X        Error("SetScannerString has not been called");
X    }
X    if (scanner->savedToken != NULL) {
X        return (!StringEqual(scanner->savedToken, ""));
X    }
X    if (scanner->spaceOption == IgnoreSpaces) SkipSpaces(scanner);
X    return (scanner->cp < scanner->len);
}
X
void SaveToken(scannerADT scanner, string token)
{
X    if (scanner->str == NULL) {
X        Error("SetScannerString has not been called");
X    }
X    if (scanner->savedToken != NULL) {
X        Error("Token has already been saved");
X    }
X    scanner->savedToken = token;
}
X
void SetScannerSpaceOption(scannerADT scanner, spaceOptionT option)
{
X    scanner->spaceOption = option;
}
X
spaceOptionT GetScannerSpaceOption(scannerADT scanner)
{
X    return (scanner->spaceOption);
}
X
void SetScannerNumberOption(scannerADT scanner, numberOptionT option)
{
X    scanner->numberOption = option;
}
X
numberOptionT GetScannerNumberOption(scannerADT scanner)
{
X    return (scanner->numberOption);
}
X
void SetScannerStringOption(scannerADT scanner, stringOptionT option)
{
X    scanner->stringOption = option;
}
X
stringOptionT GetScannerStringOption(scannerADT scanner)
{
X    return (scanner->stringOption);
}
X
/* Private functions */
X
/*
X * Function: SkipSpaces
X * Usage: SkipSpaces(scanner);
X * ---------------------------
X * This function advances the position of the scanner until the
X * current character is not a whitespace character.
X */
X
static void SkipSpaces(scannerADT scanner)
{
X    while (isspace(scanner->str[scanner->cp])) {
X        scanner->cp++;
X    }
}
X
/*
X * Function: ScanToEndOfIdentifier
X * Usage: finish = ScanToEndOfIdentifier(scanner);
X * -----------------------------------------------
X * This function advances the position of the scanner until it
X * reaches the end of a sequence of letters or digits that make
X * up an identifier.  The return value is the index of the last
X * character in the identifier; the value of the stored index
X * cp is the first character after that.
X */
X
static int ScanToEndOfIdentifier(scannerADT scanner)
{
X    while (isalnum(scanner->str[scanner->cp])) {
X        scanner->cp++;
X    }
X    return (scanner->cp - 1);
}
X
/*
X * Function: ScanToEndOfInteger
X * Usage: finish = ScanToEndOfInteger(scanner);
X * --------------------------------------------
X * This function advances the position of the scanner until it
X * reaches the end of a sequence of digits.  The return value is
X * the index of the last character in the integer; the value
X * of the stored index cp is the first character after that.
X */
X
static int ScanToEndOfInteger(scannerADT scanner)
{
X    while (isdigit(scanner->str[scanner->cp])) {
X        scanner->cp++;
X    }
X    return (scanner->cp - 1);
}
X
/*
X * Function: ScanToEndOfReal
X * Usage: finish = ScanToEndOfReal(scanner);
X * -----------------------------------------
X * This function advances the position of the scanner until it
X * reaches the end of a legal number.  The return value is the
X * index of the last character in the identifier; the value
X * of the stored index cp is the first character after that.
X *
X * The function operates by simulating what computer scientists
X * call a finite-state machine.  The program uses the variable
X * state to record the history of the process and determine
X * what characters would be legal at this point in time.
X */
X
#define InitialState        0
#define BeforeDecimalPoint  1
#define AfterDecimalPoint   2
#define StartingExponent    3
#define FoundExponentSign   4
#define ScanningExponent    5
#define FinalState         -1
X
static int ScanToEndOfReal(scannerADT scanner)
{
X    int state;
X    char ch;
X
X    state = InitialState;
X    while (state != FinalState) {
X        ch = scanner->str[scanner->cp];
X        switch (state) {
X          case InitialState:
X            if (!isdigit(ch)) Error("ScanToEndOfReal called on nonnumber");
X             state = BeforeDecimalPoint;
X            break;
X          case BeforeDecimalPoint:
X            if (ch == '.') {
X                state = AfterDecimalPoint;
X            } else if (ch == 'E' || ch == 'e') {
X                state = StartingExponent;
X            } else if (!isdigit(ch)) {
X                state = FinalState;
X            }
X            break;
X          case AfterDecimalPoint:
X            if (ch == 'E' || ch == 'e') {
X                state = StartingExponent;
X            } else if (!isdigit(ch)) {
X                state = FinalState;
X            }
X            break;
X          case StartingExponent:
X            if (ch == '+' || ch == '-') {
X                state = FoundExponentSign;
X            } else if (isdigit(ch)) {
X                state = ScanningExponent;
X            } else {
X                scanner->cp--;
X                state = FinalState;
X            }
X            break;
X          case FoundExponentSign:
X            if (isdigit(ch)) {
X                state = ScanningExponent;
X            } else {
X                scanner->cp -= 2;
X                state = FinalState;
X            }
X            break;
X          case ScanningExponent:
X            if (!isdigit(ch)) {
X                state = FinalState;
X            }
X            break;
X        }
X        if (state != FinalState) scanner->cp++;
X    }
X    return (scanner->cp - 1);
}
X
/*
X * Function: ScanQuotedString
X * Usage: str = ScanQuotedString(scanner);
X * ---------------------------------------
X * This function reads and returns a quoted string from the
X * scanner.  The current position of the scanner must be the
X * opening quotation mark.  At the end, the current position
X * marker will be set to the character position after the
X * closing quote.  The scanner generates an error if there
X * is no closing quotation mark before the end of the string.
X */
X
static string ScanQuotedString(scannerADT scanner)
{
X    string token;
X    char ch;
X
X    token = "\"";
X    scanner->cp++;
X    while ((ch = scanner->str[scanner->cp++]) != '"') {
X        if (ch == '\0') Error("Unterminated string");
X        if (ch == '\\') ch = ScanEscapeCharacter(scanner);
X        token = Concat(token, CharToString(ch));
X    }
X    return (Concat(token, "\""));
}
X
/*
X * Function: ScanEscapeCharacter
X * Usage: ch = ScanEscapeCharacter(scanner);
X * -----------------------------------------
X * This function is used by ScanQuotedString to read an escape
X * character sequence from the scanner string.  The opening
X * backslash character has already been read.  Most of the
X * complexity comes in reading the '\ddd' and '\xdd' forms.
X */
X
static char ScanEscapeCharacter(scannerADT scanner)
{
X    char ch, result;
X    int digit, base;
X
X    ch = scanner->str[scanner->cp];
X    if (isdigit(ch) || ch == 'x') {
X        base = 8;
X        if (ch == 'x') {
X            base = 16;
X            scanner->cp++;
X        }
X        result = 0;
X        while (TRUE) {
X            ch = scanner->str[scanner->cp];
X            if (isdigit(ch)) {
X                digit = ch - '0';
X            } else if (isalpha(ch)) {
X                digit = toupper(ch) - 'A' + 10;
X            } else {
X                digit = base;
X            }
X            if (digit >= base) break;
X            result = base * result + digit;
X            scanner->cp++;
X        }
X        return (result);
X    }
X    scanner->cp++;
X    switch (ch) {
X      case 'a':  return ('\a');
X      case 'b':  return ('\b');
X      case 'f':  return ('\f');
X      case 'n':  return ('\n');
X      case 'r':  return ('\r');
X      case 't':  return ('\t');
X      case 'v':  return ('\v');
X      case '\\': return ('\\');
X      case '"':  return ('"');
X    }
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/14-Expression-Trees/scanadt.c' &&
  chmod 0644 'programs/14-Expression-Trees/scanadt.c' ||
  echo 'restore of programs/14-Expression-Trees/scanadt.c failed'
  shar_count="`wc -c < 'programs/14-Expression-Trees/scanadt.c'`"
  test 10928 -eq "$shar_count" ||
    echo "programs/14-Expression-Trees/scanadt.c: original size 10928, current size $shar_count"
fi
# ============= programs/14-Expression-Trees/scanadt.h ==============
if test -f 'programs/14-Expression-Trees/scanadt.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/14-Expression-Trees/scanadt.h (file already exists)'
else
  echo 'x - extracting programs/14-Expression-Trees/scanadt.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/14-Expression-Trees/scanadt.h' &&
/*
X * File: scanadt.h
X * ---------------
X * This file is the interface to a module that exports an abstract
X * data type to facilitate dividing a string into logical units
X * called "tokens," which are either
X *
X * 1. Strings of consecutive letters and digits representing words
X * 2. One-character strings representing punctuation or separators
X *
X * To use this package, you must first create an instance of a
X * scannerADT by calling
X *
X *      scanner = NewScanner();
X *
X * All other calls to the scanner package take this variable as their
X * first argument to identify a particular instance of the abstract
X * scanner type.
X *
X * You initialize the scanner to hold a particular string by calling
X *
X *      SetScannerString(scanner, str);
X *
X * where str is the string from which tokens should be read.  To
X * retrieve each individual token, you make the following call:
X *
X *      token = ReadToken(scanner);
X *
X * To determine whether any tokens remain to be read, you can call
X * the predicate function MoreTokensExist(scanner).  The ReadToken
X * function returns the empty string after the last token is read.
X *
X * The following code fragment serves as an idiom for processing
X * each token in the string inputString:
X *
X *      scanner = NewScanner();
X *      SetScannerString(scanner, inputString);
X *      while (MoreTokensExist(scanner)) {
X *          token = ReadToken(scanner);
X *          . . . process the token . . .
X *      }
X *
X * This version of scanadt.h also supports the following extensions,
X * which are documented later in the interface:
X *
X *   SaveToken
X *   SetScannerSpaceOption
X *   SetScannerStringOption
X *   SetScannerNumberOption
X */
X
#ifndef _scanadt_h
#define _scanadt_h
X
#include "genlib.h"
X
/*
X * Type: scannerADT
X * ----------------
X * This type is the abstract type used to represent a single instance
X * of a scanner.  As with any abstract type, the details of the
X * internal representation are hidden from the client.
X */
X
typedef struct scannerCDT *scannerADT;
X
/*
X * Function: NewScanner
X * Usage: scanner = NewScanner();
X * ------------------------------
X * This function creates a new scanner instance.  All other functions
X * in this interface take this scanner value as their first argument
X * so that they can identify what particular instance of the scanner
X * is in use.  This design makes it possible for clients to have more
X * than one scanner process active at the same time.
X */
X
scannerADT NewScanner(void);
X
/*
X * Function: FreeScanner
X * Usage: FreeScanner(scanner);
X * ----------------------------
X * This function frees the storage associated with scanner.
X */
X
void FreeScanner(scannerADT scanner);
X
/*
X * Function: SetScannerString
X * Usage: SetScannerString(scanner, str);
X * --------------------------------------
X * This function initializes the scanner so that it will start
X * extracting tokens from the string str.
X */
X
void SetScannerString(scannerADT scanner, string str);
X
/*
X * Function: ReadToken
X * Usage: token = ReadToken(scanner);
X * ----------------------------------
X * This function returns the next token from scanner.  If
X * ReadToken is called when no tokens are available, it returns
X * the empty string.  The token returned by ReadToken is always
X * allocated in the heap, which means that clients can call
X * FreeBlock when the token is no longer needed.
X */
X
string ReadToken(scannerADT scanner);
X
/*
X * Function: MoreTokensExist
X * Usage: if (MoreTokensExist(scanner)) . . .
X * ------------------------------------------
X * This function returns TRUE as long as there are additional
X * tokens for the scanner to read.
X */
X
bool MoreTokensExist(scannerADT scanner);
X
/*
X * Function: SaveToken
X * Usage: SaveToken(scanner, token);
X * ---------------------------------
X * This function stores the token in the scanner data structure
X * in such a way that the next time ReadToken is called, it will
X * return that token without reading any additional characters
X * from the input.
X */
X
void SaveToken(scannerADT scanner, string token);
X
/*
X * Functions: SetScannerSpaceOption, GetScannerSpaceOption
X * Usage: SetScannerSpaceOption(scanner, option);
X *        option = GetScannerSpaceOption(scanner);
X * -----------------------------------------------
X * The SetScannerSpaceOption function controls whether the scanner
X * ignores whitespace characters or treats them as valid tokens.
X * By default, the ReadToken function treats whitespace characters,
X * such as spaces and tabs, just like any other punctuation mark.
X * If, however, you call
X *
X *    SetScannerSpaceOption(scanner, IgnoreSpaces);
X *
X * the scanner will skip over any white space before reading a token.
X * You can restore the original behavior by calling
X *
X *    SetScannerSpaceOption(scanner, PreserveSpaces);
X *
X * The GetScannerSpaceOption function returns the current setting
X * of this option.
X */
X
typedef enum { PreserveSpaces, IgnoreSpaces } spaceOptionT;
X
void SetScannerSpaceOption(scannerADT scanner, spaceOptionT option);
spaceOptionT GetScannerSpaceOption(scannerADT scanner);
X
/*
X * Functions: SetScannerNumberOption, GetScannerNumberOption
X * Usage: SetScannerNumberOption(scanner, option);
X *        option = GetScannerNumberOption(scanner);
X * ------------------------------------------------
X * This function controls whether the scanner treats numeric values
X * specially.  The default behavior for the scanner is to treat
X * digits as equivalent to letters.  If you call
X *
X *    SetScannerNumberOption(scanner, ScanNumbersAsIntegers);
X *
X * a token beginning with a digit will end at the first nondigit.
X * (Note that digits can still be scanned as part of a token as in
X * the token "x1".)  If you call
X *
X *    SetScannerNumberOption(scanner, ScanNumbersAsReals);
X *
X * the scanner will return the longest token string that represents
X * a real number, if the next character to be scanned is a digit.
X * The format for a real number is a sequence of digit characters
X * that may include at most one decimal point, optionally followed
X * by the letter 'E' in either upper- or lowercase, an optional sign,
X * and an exponent.  You can restore the default behavior by calling
X *
X *    SetScannerNumberOption(scanner, ScanNumbersAsLetters);
X *
X * Even if the number options are enabled, ReadToken always returns
X * its result as a string, which means that you need to call
X * StringToInteger or StringToReal to convert the token to a number.
X */
X
typedef enum {
X    ScanNumbersAsLetters,
X    ScanNumbersAsIntegers,
X    ScanNumbersAsReals
} numberOptionT;
X
void SetScannerNumberOption(scannerADT scanner, numberOptionT option);
numberOptionT GetScannerNumberOption(scannerADT scanner);
X
/*
X * Functions: SetScannerStringOption, GetScannerStringOption
X * Usage: SetScannerStringOption(scanner, option);
X *        option = GetScannerStringOption(scanner);
X * ------------------------------------------------
X * This function controls how the scanner treats double quotation
X * marks in the input.  The default behavior for the scanner is
X * to treat quotes just like any other punctuation character.
X * If, however, you call
X *
X *    SetScannerStringOption(scanner, ScanQuotesAsStrings);
X *
X * a token beginning with a quotation mark will be scanned up to
X * the closing quotation mark.  The quotation marks are returned
X * as part of the scanned token so that clients can differentiate
X * strings from other token types.  The original behavior can be
X * restored by calling
X *
X *    SetScannerStringOption(scanner, ScanQuotesAsPunctuation);
X *
X * When scanning a string, the scanner recognizes the standard
X * escape sequences from ANSI C, such as \n and \t.
X */
X
typedef enum {
X    ScanQuotesAsPunctuation,
X    ScanQuotesAsStrings
} stringOptionT;
X
void SetScannerStringOption(scannerADT scanner, stringOptionT option);
stringOptionT GetScannerStringOption(scannerADT scanner);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/14-Expression-Trees/scanadt.h' &&
  chmod 0644 'programs/14-Expression-Trees/scanadt.h' ||
  echo 'restore of programs/14-Expression-Trees/scanadt.h failed'
  shar_count="`wc -c < 'programs/14-Expression-Trees/scanadt.h'`"
  test 7862 -eq "$shar_count" ||
    echo "programs/14-Expression-Trees/scanadt.h: original size 7862, current size $shar_count"
fi
# ============= programs/14-Expression-Trees/symtab.c ==============
if test -f 'programs/14-Expression-Trees/symtab.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/14-Expression-Trees/symtab.c (file already exists)'
else
  echo 'x - extracting programs/14-Expression-Trees/symtab.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/14-Expression-Trees/symtab.c' &&
/*
X * File: symtab.c
X * --------------
X * This file implements the symbol table abstraction.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "strlib.h"
#include "symtab.h"
X
/*
X * Constants
X * ---------
X * NBuckets -- Number of buckets in the hash table
X */
X
#define NBuckets 101
X
/*
X * Type: cellT
X * -----------
X * This type defines a linked list cell for the symbol table.
X */
X
typedef struct cellT {
X    string key;
X    void *value;
X    struct cellT *link;
} cellT;
X
/*
X * Type: symtabCDT
X * ---------------
X * This type defines the underlying concrete representation for a
X * symtabADT.  These details are not relevant to and therefore
X * not exported to the client.  In this implementation, the
X * underlying structure is a hash table organized as an array of
X * "buckets," in which each bucket is a linked list of elements
X * that share the same hash code.
X */
X
struct symtabCDT {
X    cellT *buckets[NBuckets];
};
X
/* Private function declarations */
X
static void FreeBucketChain(cellT *cp);
static cellT *FindCell(cellT *cp, string s);
static int Hash(string s, int nBuckets);
X
/* Public entries */
X
symtabADT NewSymbolTable(void)
{
X    symtabADT table;
X    int i;
X
X    table = New(symtabADT);
X    for (i = 0; i < NBuckets; i++) {
X        table->buckets[i] = NULL;
X    }
X    return (table);
}
X
void FreeSymbolTable(symtabADT table)
{
X    int i;
X
X    for (i = 0; i < NBuckets; i++) {
X        FreeBucketChain(table->buckets[i]);
X    }
X    FreeBlock(table);
}
X
void Enter(symtabADT table, string key, void *value)
{
X    int bucket;
X    cellT *cp;
X
X    bucket = Hash(key, NBuckets);
X    cp = FindCell(table->buckets[bucket], key);
X    if (cp == NULL) {
X        cp = New(cellT *);
X        cp->key = CopyString(key);
X        cp->link = table->buckets[bucket];
X        table->buckets[bucket] = cp;
X    }
X    cp->value = value;
}
X
void *Lookup(symtabADT table, string key)
{
X    int bucket;
X    cellT *cp;
X
X    bucket = Hash(key, NBuckets);
X    cp = FindCell(table->buckets[bucket], key);
X    if (cp == NULL) return(UNDEFINED);
X    return (cp->value);
}
X
/*
X * Implementation notes: DeleteSymbol
X * ----------------------------------
X * The implementation of DeleteSymbol must search the hash
X * chain for an entry with a matching key and then delete that
X * entry from the chain.  To delete the cell, the code must have
X * a pointer to the preceding cell, which is maintained in pp.
X * The first cell in the list is a special case because there
X * is no previous cell; this case is identified by having NULL
X * as the value of pp.
X */
X
void DeleteSymbol(symtabADT table, string key)
{
X    int bucket;
X    cellT *cp, *pp;
X
X    bucket = Hash(key, NBuckets);
X    pp = NULL;
X    cp = table->buckets[bucket];
X    while (cp != NULL && !StringEqual(cp->key, key)) {
X        pp = cp;
X        cp = cp->link;
X    }
X    if (cp == NULL) return;
X    if (pp == NULL) {
X        table->buckets[bucket] = cp->link;
X    } else {
X        pp->link = cp->link;
X    }
X    FreeBlock(cp);
}
X
void MapSymbolTable(symtabFnT fn, symtabADT table,
X                    void *clientData)
{
X    int i;
X    cellT *cp;
X
X    for (i = 0; i < NBuckets; i++) {
X        for (cp = table->buckets[i]; cp != NULL; cp = cp->link) {
X            fn(cp->key, cp->value, clientData);
X        }
X    }
}
X
/* Private functions */
X
/*
X * Function: FreeBucketChain
X * Usage: FreeBucketChain(cp);
X * ---------------------------
X * This function takes a chain pointer and frees all the cells
X * in that chain.  Because the package makes copies of the keys,
X * this function must free the string storage as well.
X */
X
static void FreeBucketChain(cellT *cp)
{
X    cellT *next;
X
X    while (cp != NULL) {
X        next = cp->link;
X        FreeBlock(cp->key);
X        FreeBlock(cp);
X        cp = next;
X    }
}
X
/*
X * Function: FindCell
X * Usage: cp = FindCell(cp, key);
X * ------------------------------
X * This function finds a cell in the chain beginning at cp that
X * matches key.  If a match is found, a pointer to that cell is
X * returned.  If no match is found, the function returns NULL.
X */
X
static cellT *FindCell(cellT *cp, string key)
{
X    while (cp != NULL && !StringEqual(cp->key, key)) {
X        cp = cp->link;
X    }
X    return (cp);
}
X
/*
X * Function: Hash
X * Usage: bucket = Hash(key, nBuckets);
X * ------------------------------------
X * This function takes the key and uses it to derive a hash code,
X * which is an integer in the range [0, nBuckets - 1].  The hash
X * code is computed using a method called linear congruence.  The
X * choice of the value for Multiplier can have a significant effect
X * on the performance of the algorithm, but not on its correctness.
X */
X
#define Multiplier -1664117991L
X
static int Hash(string s, int nBuckets)
{
X    int i;
X    unsigned long hashcode;
X
X    hashcode = 0;
X    for (i = 0; s[i] != '\0'; i++) {
X        hashcode = hashcode * Multiplier + s[i];
X    }
X    return (hashcode % nBuckets);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/14-Expression-Trees/symtab.c' &&
  chmod 0644 'programs/14-Expression-Trees/symtab.c' ||
  echo 'restore of programs/14-Expression-Trees/symtab.c failed'
  shar_count="`wc -c < 'programs/14-Expression-Trees/symtab.c'`"
  test 4897 -eq "$shar_count" ||
    echo "programs/14-Expression-Trees/symtab.c: original size 4897, current size $shar_count"
fi
# ============= programs/14-Expression-Trees/symtab.h ==============
if test -f 'programs/14-Expression-Trees/symtab.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/14-Expression-Trees/symtab.h (file already exists)'
else
  echo 'x - extracting programs/14-Expression-Trees/symtab.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/14-Expression-Trees/symtab.h' &&
/*
X * File: symtab.h
X * --------------
X * This interface exports a simple symbol table abstraction.
X */
X
#ifndef _symtab_h
#define _symtab_h
X
#include "genlib.h"
X
/*
X * Type: symtabADT
X * ---------------
X * This type is the ADT used to represent a symbol table.
X */
X
typedef struct symtabCDT *symtabADT;
X
/*
X * Type: symtabFnT
X * ---------------
X * This type defines the class of functions that can be used to
X * map over the entries in a symbol table.
X */
X
typedef void (*symtabFnT)(string key, void *value,
X                          void *clientData);
X
/* Exported entries */
X
/*
X * Function: NewSymbolTable
X * Usage: table = NewSymbolTable();
X * --------------------------------
X * This function allocates a new symbol table with no entries.
X */
X
symtabADT NewSymbolTable(void);
X
/*
X * Function: FreeSymbolTable
X * Usage: FreeSymbolTable(table);
X * ------------------------------
X * This function frees the storage associated with the symbol table.
X */
X
void FreeSymbolTable(symtabADT table);
X
/*
X * Function: Enter
X * Usage: Enter(table, key, value);
X * --------------------------------
X * This function associates key with value in the symbol table.
X * Each call to Enter supersedes any previous definition for key.
X */
X
void Enter(symtabADT table, string key, void *value);
X
/*
X * Function: Lookup
X * Usage: value = Lookup(table, key);
X * ----------------------------------
X * This function returns the value associated with key in the symbol
X * table, or UNDEFINED, if no such value exists.
X */
X
void *Lookup(symtabADT table, string key);
X
/*
X * Function: DeleteSymbol
X * Usage: DeleteSymbol(table, key);
X * --------------------------------
X * This function removes the most recent definition of key,
X * reexposing the previous one.  If no definition exists for
X * key, DeleteSymbol simply returns without taking any action.
X */
X
void DeleteSymbol(symtabADT table, string key);
X
/*
X * Function: MapSymbolTable
X * Usage: MapSymbolTable(fn, table, clientData);
X * ---------------------------------------------
X * This function goes through every entry in the symbol table
X * and calls the function fn, passing it the following arguments:
X * the current key, its associated value, and the clientData
X * pointer.  The clientData pointer allows the client to pass
X * additional state information to the function fn, if necessary.
X * If no clientData argument is required, this value should be NULL.
X */
X
void MapSymbolTable(symtabFnT fn, symtabADT table,
X                    void *clientData);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/14-Expression-Trees/symtab.h' &&
  chmod 0644 'programs/14-Expression-Trees/symtab.h' ||
  echo 'restore of programs/14-Expression-Trees/symtab.h failed'
  shar_count="`wc -c < 'programs/14-Expression-Trees/symtab.h'`"
  test 2504 -eq "$shar_count" ||
    echo "programs/14-Expression-Trees/symtab.h: original size 2504, current size $shar_count"
fi
# ============= programs/14-Expression-Trees/Makefile ==============
if test -f 'programs/14-Expression-Trees/Makefile' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/14-Expression-Trees/Makefile (file already exists)'
else
  echo 'x - extracting programs/14-Expression-Trees/Makefile (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/14-Expression-Trees/Makefile' &&
# Makefile for programs in directory 14-Expression-Trees
# ***************************************************************
X
PROGRAMS = \
X    interp
X
# ***************************************************************
# Parameters to control Makefile operation
# Note that the gccx command script must be defined
X
CC = gccx
CFLAGS = 
X
# ***************************************************************
# Entry to bring the package up to date
X
all: $(PROGRAMS)
X
# ***************************************************************
# Standard entries to remove files from the directories
#    tidy    -- eliminate unwanted files
#    scratch -- delete derived files in preparation for rebuild
X
tidy:
X	rm -f ,* .,* *~ core a.out graphics.ps
X
scratch: tidy
X	rm -f *.o *.a $(PROGRAMS)
X
# ***************************************************************
# C compilations
X
eval.o: eval.c eval.h exp.h symtab.h
X	$(CC) $(CFLAGS) -c eval.c
X
exp.o: exp.c exp.h
X	$(CC) $(CFLAGS) -c exp.c
X
interp.o: interp.c eval.h exp.h parser.h scanadt.h
X	$(CC) $(CFLAGS) -c interp.c
X
iverson.o: iverson.c exp.h parser.h scanadt.h
X	$(CC) $(CFLAGS) -c iverson.c
X
parser.o: parser.c exp.h parser.h scanadt.h
X	$(CC) $(CFLAGS) -c parser.c
X
scanadt.o: scanadt.c scanadt.h
X	$(CC) $(CFLAGS) -c scanadt.c
X
symtab.o: symtab.c symtab.h
X	$(CC) $(CFLAGS) -c symtab.c
X
X
# ***************************************************************
# Executable programs
X
interp: interp.o eval.o exp.o parser.o scanadt.o symtab.o
X	$(CC) $(CFLAGS) -o interp interp.o eval.o exp.o parser.o \
X                                  scanadt.o symtab.o
X
SHAR_EOF
  $shar_touch -am 0905213097 'programs/14-Expression-Trees/Makefile' &&
  chmod 0644 'programs/14-Expression-Trees/Makefile' ||
  echo 'restore of programs/14-Expression-Trees/Makefile failed'
  shar_count="`wc -c < 'programs/14-Expression-Trees/Makefile'`"
  test 1583 -eq "$shar_count" ||
    echo "programs/14-Expression-Trees/Makefile: original size 1583, current size $shar_count"
fi
# ============= programs/15-Sets/bst.c ==============
if test ! -d 'programs/15-Sets'; then
  echo 'x - creating directory programs/15-Sets'
  mkdir 'programs/15-Sets'
fi
if test -f 'programs/15-Sets/bst.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/15-Sets/bst.c (file already exists)'
else
  echo 'x - extracting programs/15-Sets/bst.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/15-Sets/bst.c' &&
/*
X * File: bst.c
X * -----------
X * This file implements the bst.h interface, which provides a
X * general implementation of binary search trees.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "cmpfn.h"
#include "bst.h"
X
/*
X * Type: treeT
X * -----------
X * Because the implementation does not know the structure of a
X * node, pointers to nodes cannot be defined explicitly and must
X * be represented using void *.  For readability, the code declares
X * any void * pointers that are in fact trees to be of type treeT.
X */
X
typedef void *treeT;
X
/*
X * Type: bstCDT
X * ------------
X * This type is the concrete type used to represent the bstADT.
X */
X
struct bstCDT {
X    treeT root;
X    int userSize, totalSize;
X    cmpFnT cmpFn;
X    nodeInitFnT nodeInitFn;
};
X
/*
X * Type: bstDataT
X * --------------
X * This record is allocated at the end of the client's structure
X * and is used to maintain the structure of the tree.  The code
X * calls BSTData on the node pointer to derive this address.
X */
X
typedef struct {
X    treeT left, right;
} bstDataT;
X
/* Private function prototypes */
X
static treeT *RecFindNode(bstADT bst, treeT t, void *kp);
static void *RecInsertNode(bstADT bst, treeT *tptr, void *kp,
X                           void *clientData);
static void *RecDeleteNode(bstADT bst, treeT *tptr, void *kp);
static void *DeleteTargetNode(bstADT bst, treeT *tptr);
static void RecMapBST(nodeFnT fn, bstADT bst, treeT t,
X                      traversalOrderT order, void *clientData);
static bstDataT *BSTData(bstADT bst, treeT t);
X
/* Exported entries */
X
bstADT NewBST(int size, cmpFnT cmpFn, nodeInitFnT nodeInitFn)
{
X    bstADT bst;
X
X    bst = New(bstADT);
X    bst->root = NULL;
X    bst->userSize = size;
X    bst->totalSize = bst->userSize + sizeof(bstDataT);
X    bst->cmpFn = cmpFn;
X    bst->nodeInitFn = nodeInitFn;
X    return (bst);
}
X
void FreeBST(bstADT bst, nodeFnT freeNodeFn)
{
X    MapBST(freeNodeFn, bst, PostOrder, NULL);
X    FreeBlock(bst);
}
X
/*
X * Implementation notes: FindBSTNode, RecFindNode
X * ----------------------------------------------
X * The FindBSTNode function simply calls RecFindNode to do
X * the work.  The recursive function takes the address of
X * the current node along with the original arguments.
X */
X
void *FindBSTNode(bstADT bst, void *kp)
{
X    return (RecFindNode(bst, bst->root, kp));
}
X
static treeT *RecFindNode(bstADT bst, treeT t, void *kp)
{
X    bstDataT *dp;
X    int sign;
X
X    if (t == NULL) return (NULL);
X    sign = bst->cmpFn(kp, t);
X    if (sign == 0) return (t);
X    dp = BSTData(bst, t);
X    if (sign < 0) {
X        return (RecFindNode(bst, dp->left, kp));
X    } else {
X        return (RecFindNode(bst, dp->right, kp));
X    }
}
X
/*
X * Implementation notes: InsertBSTNode, RecInsertNode
X * --------------------------------------------------
X * The InsertBSTNode function is implemented as a simple wrapper
X * to RecInsertNode, which does all the work.  The difference
X * between the prototypes is that RecInsertNode takes a pointer
X * to the root of the current subtree as an extra argument.
X */
X
void *InsertBSTNode(bstADT bst, void *kp, void *clientData)
{
X    return (RecInsertNode(bst, &bst->root, kp, clientData));
}
X
static void *RecInsertNode(bstADT bst, treeT *tptr, void *kp,
X                           void *clientData)
{
X    bstDataT *dp;
X    treeT t;
X    int sign;
X
X    t = *tptr;
X    if (t == NULL) {
X        t = GetBlock(bst->totalSize);
X        bst->nodeInitFn(t, kp, clientData);
X        dp = BSTData(bst, t);
X        dp->left = dp->right = NULL;
X        *tptr = t;
X        return (t);
X    }
X    sign = bst->cmpFn(kp, t);
X    if (sign == 0) return (t);
X    dp = BSTData(bst, t);
X    if (sign < 0) {
X        return (RecInsertNode(bst, &dp->left, kp, clientData));
X    } else {
X        return (RecInsertNode(bst, &dp->right, kp, clientData));
X    }
}
X
/*
X * Implementation notes: DeleteBSTNode, RecDeleteNode
X * --------------------------------------------------
X * The first step in deleting a node is to find it using binary
X * search, which is performed by these two functions.  If the
X * node is found, DeleteTargetNode does the actual deletion.
X */
X
void *DeleteBSTNode(bstADT bst, void *kp)
{
X    return (RecDeleteNode(bst, &bst->root, kp));
}
X
static void *RecDeleteNode(bstADT bst, treeT *tptr, void *kp)
{
X    bstDataT *dp;
X    treeT t;
X    int sign;
X
X    t = *tptr;
X    if (t == NULL) return (NULL);
X    sign = bst->cmpFn(kp, t);
X    if (sign == 0) {
X        return (DeleteTargetNode(bst, tptr));
X    }
X    dp = BSTData(bst, t);
X    if (sign < 0) {
X        return (RecDeleteNode(bst, &dp->left, kp));
X    } else {
X        return (RecDeleteNode(bst, &dp->right, kp));
X    }
}
X
/*
X * Implementation notes: DeleteTargetNode
X * --------------------------------------
X * This function deletes the node whose address is passed by
X * reference in tptr.  The easy case occurs when either of the
X * children is NULL; all you need to do is replace the node with
X * its non-NULL child.  If both children are non-NULL, this code
X * finds the rightmost descendant of the left child; this node
X * may not be a leaf, but will have no right child.  Its left
X * child replaces it in the tree, after which the replacement
X * node is moved to the position occupied by the target node.
X */
X
static void *DeleteTargetNode(bstADT bst, treeT *tptr)
{
X    treeT target, *rptr;
X    bstDataT *tdp, *rdp;
X
X    target = *tptr;
X    tdp = BSTData(bst, target);
X    if (tdp->left == NULL) {
X        *tptr = tdp->right;
X    } else if (tdp->right == NULL) {
X        *tptr = tdp->left;
X    } else {
X        rptr = &tdp->left;
X        rdp = BSTData(bst, *rptr);
X        while (rdp->right != NULL) {
X            rptr = &rdp->right;
X            rdp = BSTData(bst, *rptr);
X        }
X        *tptr = *rptr;
X        *rptr = rdp->left;
X        rdp->left = tdp->left;
X        rdp->right = tdp->right;
X    }
X    return (target);
}
X
/*
X * Implementation notes: MapBST, RecMapBST
X * ---------------------------------------
X * The MapBST function is implemented as a wrapper to the
X * recursive function RecMapBST, which does the actual work.
X */
X
void MapBST(nodeFnT fn, bstADT bst, traversalOrderT order,
X            void *clientData)
{
X    RecMapBST(fn, bst, bst->root, order, clientData);
}
X
static void RecMapBST(nodeFnT fn, bstADT bst, treeT t,
X                      traversalOrderT order, void *clientData)
{
X    bstDataT *dp;
X
X    if (t != NULL) {
X        dp = BSTData(bst, t);
X        if (order == PreOrder) fn(t, clientData);
X        RecMapBST(fn, bst, dp->left, order, clientData);
X        if (order == InOrder) fn(t, clientData);
X        RecMapBST(fn, bst, dp->right, order, clientData);
X        if (order == PostOrder) fn(t, clientData);
X    }
}
X
/* Low-level functions */
X
void *BSTRoot(bstADT bst)
{
X    return (bst->root);
}
X
void *BSTLeftChild(bstADT bst, void *np)
{
X    bstDataT *dp;
X
X    if (np == NULL) Error("BSTLeftChild: Argument is NULL");
X    dp = BSTData(bst, np);
X    return (dp->left);
}
X
void *BSTRightChild(bstADT bst, void *np)
{
X    bstDataT *dp;
X
X    if (np == NULL) Error("BSTRightChild: Argument is NULL");
X    dp = BSTData(bst, np);
X    return (dp->right);
}
X
/*
X * Function: BSTData
X * Usage: dp = BSTData(bst, t);
X * ----------------------------
X * This function determines the address of the data record
X * containing the pointers for the binary tree.  This record
X * appears at the end of the user structure that begins at t.
X */
X
static bstDataT *BSTData(bstADT bst, treeT t)
{
X    return ((bstDataT *) ((char *) t + bst->userSize));
}
X
X
SHAR_EOF
  $shar_touch -am 0903182097 'programs/15-Sets/bst.c' &&
  chmod 0644 'programs/15-Sets/bst.c' ||
  echo 'restore of programs/15-Sets/bst.c failed'
  shar_count="`wc -c < 'programs/15-Sets/bst.c'`"
  test 7517 -eq "$shar_count" ||
    echo "programs/15-Sets/bst.c: original size 7517, current size $shar_count"
fi
# ============= programs/15-Sets/bst.h ==============
if test -f 'programs/15-Sets/bst.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/15-Sets/bst.h (file already exists)'
else
  echo 'x - extracting programs/15-Sets/bst.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/15-Sets/bst.h' &&
/*
X * File: bst.h
X * -----------
X * This file provides an interface for a general binary search
X * tree facility that allows the client to maintain control of
X * the structure of the node.
X */
X
#ifndef _bst_h
#define _bst_h
X
#include "genlib.h"
#include "cmpfn.h"
X
/*
X * Type: bstADT
X * ------------
X * This is the abstract type for a binary search tree.
X */
X
typedef struct bstCDT *bstADT;
X
/*
X * Type: nodeFnT
X * -------------
X * This type defines the class of callback functions for nodes.
X */
X
typedef void (*nodeFnT)(void *np, void *clientData);
X
/*
X * Type: nodeInitFnT
X * -----------------
X * This type defines the class of functions used to initialize
X * a newly created node.
X */
X
typedef void (*nodeInitFnT)(void *np, void *kp, void *clientData);
X
/*
X * Function: NewBST
X * Usage: bst = NewBST(sizeof (nodeT), cmpFn, nodeInitFn);
X * -------------------------------------------------------
X * This function allocates and returns a new empty binary search
X * tree.  The first argument is the size of the client node.  The
X * second is a comparison function, which is called with the address
X * of the search key and the address of a node.  By storing the key
X * at the beginning of the structure, clients can use the standard
X * comparison functions from cmpfn.h.  The third argument is a
X * function that initializes the client's fields in the node, which
X * is described in more detail in the comments for InsertBSTNode.
X */
X
bstADT NewBST(int size, cmpFnT cmpFn, nodeInitFnT nodeInitFn);
X
/*
X * Function: FreeBST
X * Usage: FreeBST(bst, freeNodeFn);
X * --------------------------------
X * This function frees the storage for a tree, but calls the
X * client-supplied freeNodeFn to free each individual node.
X * The clientData value passed to the callback function is
X * always NULL.
X */
X
void FreeBST(bstADT bst, nodeFnT freeNodeFn);
X
/*
X * Function: FindBSTNode
X * Usage: np = FindBSTNode(bst, &key);
X * -----------------------------------
X * This function applies the binary search algorithm to find a
X * particular key in the tree represented by bst.  The second
X * argument represents the address of the key in the client
X * space rather than the key itself, which makes it possible to
X * use this package for keys that are not pointer types.  If a
X * node matching the key appears in the tree, FindBSTNode
X * returns a pointer to it; if not, FindBSTNode returns NULL.
X */
X
void *FindBSTNode(bstADT bst, void *kp);
X
/*
X * Function: InsertBSTNode
X * Usage: np = InsertBSTNode(bst, &key, clientData);
X * -------------------------------------------------
X * This function is used to insert a new node into a binary search
X * tree.  The bst and &key arguments are interpreted as they are
X * in FindBSTNode.  If the key already exists, the result is
X * simply the address of the old node.  If the key is not found,
X * InsertBSTNode allocates a new node and then calls the node
X * initialization function specified in the NewBST call to
X * initialize it.  The call has the following form:
X *
X *     nodeInitFn(np, kp, clientData);
X *
X * where np is a pointer to the node, kp is the pointer to the key,
X * and clientData is the value (typically NULL) supplied in the
X * InsertBSTNode call.  The initialization function must initialize
X * the key field in the node, but may perform other initialization
X * as well.
X */
X
void *InsertBSTNode(bstADT bst, void *kp, void *clientData);
X
/*
X * Function: DeleteBSTNode
X * Usage: np = DeleteBSTNode(bst, &key);
X * -------------------------------------
X * This function deletes a node in the tree that matches the
X * specified key pointer.  The arguments are interpreted as
X * in FindBSTNode.  The function returns the address of the
X * deleted node so that clients can free its storage.  If the
X * key is not found in the tree, DeleteBSTNode returns NULL.
X */
X
void *DeleteBSTNode(bstADT bst, void *kp);
X
/*
X * Function: MapBST
X * Usage: MapBST(fn, bst, order, clientData);
X * ------------------------------------------
X * This function calls fn on every node in the binary search tree,
X * passing it a pointer to a node and the clientData pointer.  The
X * type of traversal is given by the order argument, which must
X * be one of the constants InOrder, PreOrder, or PostOrder.
X */
X
typedef enum { InOrder, PreOrder, PostOrder } traversalOrderT;
X
void MapBST(nodeFnT fn, bstADT bst, traversalOrderT order,
X            void *clientData);
X
/*
X * Low-level functions: BSTRoot, BSTLeftChild, BSTRightChild
X * Usage: root = BSTRoot(bst);
X *        child = BSTLeftChild(bst, np);
X *        child = BSTRightChild(bst, np);
X * ---------------------------------------------------------
X * These functions allow the client to trace the structure of the
X * binary search tree and are useful primarily for debugging.
X */
X
void *BSTRoot(bstADT bst);
void *BSTLeftChild(bstADT bst, void *np);
void *BSTRightChild(bstADT bst, void *np);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/15-Sets/bst.h' &&
  chmod 0644 'programs/15-Sets/bst.h' ||
  echo 'restore of programs/15-Sets/bst.h failed'
  shar_count="`wc -c < 'programs/15-Sets/bst.h'`"
  test 4877 -eq "$shar_count" ||
    echo "programs/15-Sets/bst.h: original size 4877, current size $shar_count"
fi
# ============= programs/15-Sets/cmpfn.c ==============
if test -f 'programs/15-Sets/cmpfn.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/15-Sets/cmpfn.c (file already exists)'
else
  echo 'x - extracting programs/15-Sets/cmpfn.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/15-Sets/cmpfn.c' &&
/*
X * File: cmpfn.c
X * -------------
X * This file implements the comparison functions exported by
X * the cmpfn.h interface.  The reason to centralize them in
X * a single module is to allow the same functions to be
X * shared among many different modules.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "strlib.h"
#include "cmpfn.h"
X
/* Exported entries */
X
int IntCmpFn(const void *p1, const void *p2)
{
X    int v1, v2;
X
X    v1 = *((int *) p1);
X    v2 = *((int *) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : +1);
}
X
int ShortCmpFn(const void *p1, const void *p2)
{
X    short v1, v2;
X
X    v1 = *((short *) p1);
X    v2 = *((short *) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : +1);
}
X
int LongCmpFn(const void *p1, const void *p2)
{
X    long v1, v2;
X
X    v1 = *((long *) p1);
X    v2 = *((long *) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : +1);
}
X
int CharCmpFn(const void *p1, const void *p2)
{
X    unsigned char v1, v2;
X
X    v1 = *((unsigned char *) p1);
X    v2 = *((unsigned char *) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : +1);
}
X
int FloatCmpFn(const void *p1, const void *p2)
{
X    float v1, v2;
X
X    v1 = *((float *) p1);
X    v2 = *((float *) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : +1);
}
X
int DoubleCmpFn(const void *p1, const void *p2)
{
X    double v1, v2;
X
X    v1 = *((double *) p1);
X    v2 = *((double *) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : +1);
}
X
int UnsignedCmpFn(const void *p1, const void *p2)
{
X    unsigned v1, v2;
X
X    v1 = *((unsigned *) p1);
X    v2 = *((unsigned *) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : +1);
}
X
int UnsignedShortCmpFn(const void *p1, const void *p2)
{
X    unsigned short v1, v2;
X
X    v1 = *((unsigned short *) p1);
X    v2 = *((unsigned short *) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : +1);
}
X
int UnsignedLongCmpFn(const void *p1, const void *p2)
{
X    unsigned long v1, v2;
X
X    v1 = *((unsigned long *) p1);
X    v2 = *((unsigned long *) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : +1);
}
X
int UnsignedCharCmpFn(const void *p1, const void *p2)
{
X    unsigned char v1, v2;
X
X    v1 = *((unsigned char *) p1);
X    v2 = *((unsigned char *) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : +1);
}
X
int StringCmpFn(const void *p1, const void *p2)
{
X    return (StringCompare(*((string *) p1), *((string *) p2)));
}
X
int PtrCmpFn(const void *p1, const void *p2)
{
X    void *v1, *v2;
X
X    v1 = *((void **) p1);
X    v2 = *((void **) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : +1);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/15-Sets/cmpfn.c' &&
  chmod 0644 'programs/15-Sets/cmpfn.c' ||
  echo 'restore of programs/15-Sets/cmpfn.c failed'
  shar_count="`wc -c < 'programs/15-Sets/cmpfn.c'`"
  test 2658 -eq "$shar_count" ||
    echo "programs/15-Sets/cmpfn.c: original size 2658, current size $shar_count"
fi
# ============= programs/15-Sets/cmpfn.h ==============
if test -f 'programs/15-Sets/cmpfn.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/15-Sets/cmpfn.h (file already exists)'
else
  echo 'x - extracting programs/15-Sets/cmpfn.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/15-Sets/cmpfn.h' &&
/*
X * File: cmpfn.h
X * -------------
X * This interface exports several comparison functions for use
X * with ANSI library functions like qsort and bsearch as well
X * as various functions in the extended library.
X */
X
#ifndef _cmpfn_h
#define _cmpfn_h
X
/*
X * Type: cmpFnT
X * ------------
X * This type defines the type space of comparison functions,
X * each of which take the addresses of their arguments and
X * return an integer from the set {-1, 0, +1} depending on
X * whether the first argument is less than, equal to, or
X * greater than the second.
X */
X
typedef int (*cmpFnT)(const void *p1, const void *p2);
X
/*
X * Standard comparison functions
X * -----------------------------
X * The remainder of this interface exports standard comparison
X * functions for the most common built-in types.
X */
X
int IntCmpFn(const void *p1, const void *p2);
int ShortCmpFn(const void *p1, const void *p2);
int LongCmpFn(const void *p1, const void *p2);
int CharCmpFn(const void *p1, const void *p2);
int FloatCmpFn(const void *p1, const void *p2);
int DoubleCmpFn(const void *p1, const void *p2);
int UnsignedCmpFn(const void *p1, const void *p2);
int UnsignedShortCmpFn(const void *p1, const void *p2);
int UnsignedLongCmpFn(const void *p1, const void *p2);
int UnsignedCharCmpFn(const void *p1, const void *p2);
int StringCmpFn(const void *p1, const void *p2);
int PtrCmpFn(const void *p1, const void *p2);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/15-Sets/cmpfn.h' &&
  chmod 0644 'programs/15-Sets/cmpfn.h' ||
  echo 'restore of programs/15-Sets/cmpfn.h failed'
  shar_count="`wc -c < 'programs/15-Sets/cmpfn.h'`"
  test 1402 -eq "$shar_count" ||
    echo "programs/15-Sets/cmpfn.h: original size 1402, current size $shar_count"
fi
# ============= programs/15-Sets/cvecset.c ==============
if test -f 'programs/15-Sets/cvecset.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/15-Sets/cvecset.c (file already exists)'
else
  echo 'x - extracting programs/15-Sets/cvecset.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/15-Sets/cvecset.c' &&
/*
X * File: cvecset.c
X * ---------------
X * This file implements the set.h interface using the cvector.h
X * package so that the same test programs can be used for both
X * implementations.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "itertype.h"
#include "iterator.h"
#include "cvector.h"
#include "set.h"
X
/* Define the concrete type */
X
struct setCDT {
X    iteratorHeaderT header;
X    cVectorADT cvec;
};
X
/* Private function prototypes */
X
static setADT SetFromCVector(cVectorADT cvec);
static iteratorADT NewSetIterator(void *collection);
X
/* Exported entries */
X
setADT NewIntSet(void)
{
X    return (SetFromCVector(NewCVector()));
}
X
setADT NewPtrSet(cmpFnT cmpFn)
{
X    Error("NewPtrSet: Not implemented in CVector version");
}
X
void FreeSet(setADT set)
{
X    FreeCVector(set->cvec);
}
X
void AddIntElement(setADT set, int element)
{
X    CVectorSet(set->cvec, element);
}
X
void AddPtrElement(setADT set, void *element)
{
X    Error("AddPtrElement: Not implemented in CVector version");
}
X
void AddArrayToSet(setADT set, void *array, int n)
{
X    int i;
X
X    for (i = 0; i < n; i++) {
X        CVectorSet(set->cvec, ((int *) array)[i]);
X    }
}
X
void DeleteIntElement(setADT set, int element)
{
X    CVectorClear(set->cvec, element);
}
X
void DeletePtrElement(setADT set, void *element)
{
X    Error("DeletePtrElement: Not implemented in CVector version");
}
X
int NElements(setADT set)
{
X    int i, n;
X
X    n = 0;
X    for (i = 0; i < RangeSize; i++) {
X        if (CVectorTest(set->cvec, i)) n++;
X    }
X    return (n);
}
X
bool IsIntElement(setADT set, int element)
{
X    return (CVectorTest(set->cvec, element));
}
X
bool IsPtrElement(setADT set, void *element)
{
X    Error("IsPtrElement: Not implemented in CVector version");
}
X
bool IsSubset(setADT s1, setADT s2)
{
X    int i;
X    cVectorADT cv1 = s1->cvec;
X    cVectorADT cv2 = s2->cvec;
X
X    for (i = 0; i < RangeSize; i++) {
X        if (CVectorTest(cv1, i) && !CVectorTest(cv2, i)) {
X            return (FALSE);
X        }
X    }
X    return (TRUE);
}
X
setADT Union(setADT s1, setADT s2)
{
X    return (SetFromCVector(CVectorUnion(s1->cvec, s2->cvec)));
}
X
setADT Intersection(setADT s1, setADT s2)
{
X    return (SetFromCVector(CVectorIntersection(s1->cvec, s2->cvec)));
}
X
setADT SetDifference(setADT s1, setADT s2)
{
X    return (SetFromCVector(CVectorDifference(s1->cvec, s2->cvec)));
}
X
/* Private functions */
X
static setADT SetFromCVector(cVectorADT cvec)
{
X    setADT set;
X
X    set = New(setADT);
X    EnableIteration(set, NewSetIterator);
X    set->cvec = cvec;
X    return (set);
}
X
static iteratorADT NewSetIterator(void *collection)
{
X    setADT set = collection;
X    iteratorADT iterator;
X    int i;
X
X    iterator = NewIteratorList(sizeof (int), UnsortedFn);
X    for (i = 0; i < RangeSize; i++) {
X        if (CVectorTest(set->cvec, i)) {
X            AddToIteratorList(iterator, &i);
X        }
X    }
X    return (iterator);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/15-Sets/cvecset.c' &&
  chmod 0644 'programs/15-Sets/cvecset.c' ||
  echo 'restore of programs/15-Sets/cvecset.c failed'
  shar_count="`wc -c < 'programs/15-Sets/cvecset.c'`"
  test 2888 -eq "$shar_count" ||
    echo "programs/15-Sets/cvecset.c: original size 2888, current size $shar_count"
fi
# ============= programs/15-Sets/cvector.c ==============
if test -f 'programs/15-Sets/cvector.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/15-Sets/cvector.c (file already exists)'
else
  echo 'x - extracting programs/15-Sets/cvector.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/15-Sets/cvector.c' &&
/*
X * File: cvector.c
X * ---------------
X * This file implements the characteristic vector operations
X * exported by cvector.h.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "cvector.h"
X
/*
X * Constants: BitsPerLong, CVecWords
X * ---------------------------------
X * These constants determine the size of the concrete structure
X * used to represent a cVectorADT.  The constant BitsPerLong is
X * the number of bits in a long word; CVecWords is the number
X * of long words required to provide one bit for each element
X * in a set of size RangeSize.  Note that the calculation of
X * CVecWords must round up to the nearest word boundary.
X */
X
#define BitsPerByte 8
#define BitsPerLong (BitsPerByte * sizeof (long))
#define CVecWords ((RangeSize + BitsPerLong - 1) / BitsPerLong)
X
/*
X * Type: cVectorCDT
X * ----------------
X * This type is the concrete representation of a cVectorADT.
X * The underlying structure is an array of long words that has
X * enough bits to designate one bit for each integer in the
X * legal range from 0 to RangeSize - 1.
X */
X
struct cVectorCDT {
X    unsigned long words[CVecWords];
};
X
/* Private function prototypes */
X
static unsigned long BitMask(int k);
X
/* Exported entries */
X
cVectorADT NewCVector(void)
{
X    cVectorADT cv;
X    int i;
X
X    cv = New(cVectorADT);
X    for (i = 0; i < CVecWords; i++) {
X        cv->words[i] = 0;
X    }
X    return (cv);
}
X
void FreeCVector(cVectorADT cv)
{
X    FreeBlock(cv);
}
X
/*
X * Implementation notes: CVectorSet, CVectorClear, CVectorTest
X * -----------------------------------------------------------
X * These functions are quite similar in their implementation.
X * Each function simply calculates one of the bit operations on
X * the appropriate element of the characteristic vector array
X * and a mask that has a 1 bit in the appropriate position.
X */
X
void CVectorSet(cVectorADT cv, int k)
{
X    if (k < 0 || k >= RangeSize) {
X        Error("CVectorSet: Value is out of range");
X    }
X    cv->words[k / BitsPerLong] |= BitMask(k);
}
X
void CVectorClear(cVectorADT cv, int k)
{
X    if (k < 0 || k >= RangeSize) {
X        Error("CVectorClear: Value is out of range");
X    }
X    cv->words[k / BitsPerLong] &= ~BitMask(k);
}
X
bool CVectorTest(cVectorADT cv, int k)
{
X    if (k < 0 || k >= RangeSize) {
X        Error("CVectorTest: Value is out of range");
X    }
X    return ((cv->words[k / BitsPerLong] & BitMask(k)) != 0);
}
X
/*
X * Implementation notes: CVector set operations
X * --------------------------------------------
X * These functions CVectorUnion, CVectorIntersection, and
X * CVectorDifference compute their results very efficiently
X * by performing bitwise operation on entire words.
X */
X
cVectorADT CVectorUnion(cVectorADT cv1, cVectorADT cv2)
{
X    cVectorADT result;
X    int i;
X
X    result = New(cVectorADT);
X    for (i = 0; i < CVecWords; i++) {
X        result->words[i] = cv1->words[i] | cv2->words[i];
X    }
X    return (result);
}
X
cVectorADT CVectorIntersection(cVectorADT cv1, cVectorADT cv2)
{
X    cVectorADT result;
X    int i;
X
X    result = New(cVectorADT);
X    for (i = 0; i < CVecWords; i++) {
X        result->words[i] = cv1->words[i] & cv2->words[i];
X    }
X    return (result);
}
X
cVectorADT CVectorDifference(cVectorADT cv1, cVectorADT cv2)
{
X    cVectorADT result;
X    int i;
X
X    result = New(cVectorADT);
X    for (i = 0; i < CVecWords; i++) {
X        result->words[i] = cv1->words[i] & ~cv2->words[i];
X    }
X    return (result);
}
X
/* Private functions */
X
/*
X * Function: BitMask
X * Usage: mask = BitMask(k);
X * -------------------------
X * This function returns an unsigned long value in which the bit
X * corresponding to the value k is set and all others are clear.
X */
X
unsigned long BitMask(int k)
{
X    return ((unsigned long) 1 << (k % BitsPerLong));
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/15-Sets/cvector.c' &&
  chmod 0644 'programs/15-Sets/cvector.c' ||
  echo 'restore of programs/15-Sets/cvector.c failed'
  shar_count="`wc -c < 'programs/15-Sets/cvector.c'`"
  test 3757 -eq "$shar_count" ||
    echo "programs/15-Sets/cvector.c: original size 3757, current size $shar_count"
fi
# ============= programs/15-Sets/cvector.h ==============
if test -f 'programs/15-Sets/cvector.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/15-Sets/cvector.h (file already exists)'
else
  echo 'x - extracting programs/15-Sets/cvector.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/15-Sets/cvector.h' &&
/*
X * File: cvector.h
X * ---------------
X * This interface exports functions that implement set operations
X * on integers using a highly efficient representation called
X * characteristic vectors, which is logically an array of bits.
X * This interface, however, does not provide a general set
X * facility because the characteristic-vector representation
X * limits the range of integers that can be stored.   Despite
X * the lack of generality, this interface is extremely useful
X * as the basis for higher-level packages.
X */
X
#ifndef _cvector_h
#define _cvector_h
X
/*
X * Type: cVectorADT
X * ----------------
X * This type defines the ADT for a characteristic vector.
X */
X
typedef struct cVectorCDT *cVectorADT;
X
/*
X * Constant: RangeSize
X * -------------------
X * This constant specifies the range of integers that can be
X * stored in a set implemented as a characteristic vector.  The
X * values are restricted to the interval [0, RangeSize - 1].
X */
X
#define RangeSize 256
X
/* Exported entries */
X
cVectorADT NewCVector(void);
void FreeCVector(cVectorADT cv);
X
void CVectorSet(cVectorADT cv, int k);
void CVectorClear(cVectorADT cv, int k);
bool CVectorTest(cVectorADT cv, int k);
X
cVectorADT CVectorUnion(cVectorADT cv1, cVectorADT cv2);
cVectorADT CVectorIntersection(cVectorADT cv1, cVectorADT cv2);
cVectorADT CVectorDifference(cVectorADT cv1, cVectorADT cv2);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/15-Sets/cvector.h' &&
  chmod 0644 'programs/15-Sets/cvector.h' ||
  echo 'restore of programs/15-Sets/cvector.h failed'
  shar_count="`wc -c < 'programs/15-Sets/cvector.h'`"
  test 1372 -eq "$shar_count" ||
    echo "programs/15-Sets/cvector.h: original size 1372, current size $shar_count"
fi
# ============= programs/15-Sets/iterator.c ==============
if test -f 'programs/15-Sets/iterator.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/15-Sets/iterator.c (file already exists)'
else
  echo 'x - extracting programs/15-Sets/iterator.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/15-Sets/iterator.c' &&
/*
X * File: iterator.c
X * ----------------
X * This file implements a polymorphic version of the iterator
X * and the tools necessary to construct types that support
X * iteration.  This module implements both the iterator.h and
X * itertype.h interfaces.
X */
X
#include <stdio.h>
#include <string.h>
#include "genlib.h"
#include "cmpfn.h"
#include "iterator.h"
#include "itertype.h"
X
/*
X * Constant: IteratorPassword
X * --------------------------
X * This constant is stored in the header block of collection
X * types to catch the case when a client tries to call
X * NewIterator on a value for which iteration is not defined.
X */
X
#define IteratorPassword 3141592653UL
X
/*
X * Type: cellT, iteratorCDT
X * ------------------------
X * The iterator is implemented as a linked list chained
X * through the first word in the structure.  Because the size
X * of the actual data element can vary, the data field is not
X * represented as part of the structure.  Instead, each cell is
X * allocated dynamically with enough memory for both the link
X * field and the data value, however large it turns out to be.
X * The list is arranged like a queue, with a tail pointer to
X * its final element for efficiency.  The AddToIteratorList
X * function first checks to see whether the element belongs at
X * the end.  By checking for this case explicitly, it is often
X * possible to avoid searching the list at all.
X */
X
typedef struct cellT {
X    struct cellT *link;
X    /* The actual data is allocated here */
} cellT;
X
struct iteratorCDT {
X    int elementSize;
X    cmpFnT cmpFn;
X    cellT *head, *tail;
};
X
/* Part 1 -- Implementation of iterator.h */
X
iteratorADT NewIterator(void *collection)
{
X    iteratorHeaderT *hp = collection;
X
X    if (hp->password != IteratorPassword) {
X        Error("Iteration is not defined for this type");
X    }
X    return (hp->newFn(collection));
}
X
bool StepIterator(iteratorADT iterator, void *ep)
{
X    cellT *cp;
X    void *dp;
X
X    cp = iterator->head;
X    if (cp == NULL) {
X        iterator->tail = NULL;
X        return (FALSE);
X    }
X    dp = ((char *) cp) + sizeof (cellT);
X    memcpy(ep, dp, iterator->elementSize);
X    iterator->head = cp->link;
X    FreeBlock(cp);
X    return (TRUE);
}
X
void FreeIterator(iteratorADT iterator)
{
X    cellT *cp;
X
X    while ((cp = iterator->head) != NULL) {
X        iterator->head = cp->link;
X        FreeBlock(cp);
X    }
X    FreeBlock(iterator);
}
X
/* Part 2 -- Implementation of itertype.h */
X
void EnableIteration(void *collection, newIteratorFnT newFn)
{
X    iteratorHeaderT *hp = collection;
X
X    hp->password = IteratorPassword;
X    hp->newFn = newFn;
}
X
iteratorADT NewIteratorList(int size, cmpFnT cmpFn)
{
X    iteratorADT iterator;
X
X    iterator = New(iteratorADT);
X    iterator->elementSize = size;
X    iterator->cmpFn = cmpFn;
X    iterator->head = iterator->tail = NULL;
X    return (iterator);
}
X
/*
X * Implementation notes: AddToIteratorList
X * ---------------------------------------
X * Most of the work of the package occurs in this function, which
X * inserts the element addressed by ep into its correct position.
X * If the list is unordered or if the element belongs at the end,
X * the element is immediately inserted at the tail.  If not, the
X * implementation walks the list to find the correct position.
X * The local pointers have the following interpretations:
X *
X * np -- pointer to the newly allocated cell
X * pp -- pointer to the cell preceding the insertion point
X * ip -- pointer used as an index in the for loop
X * dp -- pointer to the data field in the block
X */
X
void AddToIteratorList(iteratorADT iterator, void *ep)
{
X    cellT *np, *pp, *ip;
X    void *dp;
X
X    np = GetBlock(sizeof (cellT) + iterator->elementSize);
X    dp = ((char *) np) + sizeof (cellT);
X    memcpy(dp, ep, iterator->elementSize);
X    pp = NULL;
X    if (iterator->tail != NULL) {
X        if (iterator->cmpFn == UnsortedFn) {
X            pp = iterator->tail;
X        } else {
X            dp = ((char *) iterator->tail) + sizeof (cellT);
X            if (iterator->cmpFn(ep, dp) >= 0) pp = iterator->tail;
X        }
X    }
X    if (pp == NULL) {
X        for (ip = iterator->head; ip != NULL; ip = ip->link) {
X            dp = ((char *) ip) + sizeof (cellT);
X            if (iterator->cmpFn(ep, dp) < 0) break;
X            pp = ip;
X        }
X    }
X    if (pp == NULL) {
X        np->link = iterator->head;
X        if (iterator->head == NULL) iterator->tail = np;
X        iterator->head = np;
X    } else {
X        np->link = pp->link;
X        if (pp->link == NULL) iterator->tail = np;
X        pp->link = np;
X    }
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/15-Sets/iterator.c' &&
  chmod 0644 'programs/15-Sets/iterator.c' ||
  echo 'restore of programs/15-Sets/iterator.c failed'
  shar_count="`wc -c < 'programs/15-Sets/iterator.c'`"
  test 4556 -eq "$shar_count" ||
    echo "programs/15-Sets/iterator.c: original size 4556, current size $shar_count"
fi
# ============= programs/15-Sets/iterator.h ==============
if test -f 'programs/15-Sets/iterator.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/15-Sets/iterator.h (file already exists)'
else
  echo 'x - extracting programs/15-Sets/iterator.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/15-Sets/iterator.h' &&
/*
X * File: iterator.h
X * ----------------
X * Many abstract data types -- including those for such common
X * structures as sets and symbol tables -- represent collections
X * of values.  In many cases, clients need to perform some
X * operation on each of the values in that collection.  This
X * file provides a polymorphic interface for iterators, which
X * provide that capability in a very general way.
X */
X
#ifndef _iterator_h
#define _iterator_h
X
#include "genlib.h"
X
/*
X * Type: iteratorADT
X * -----------------
X * This abstract type is used to iterate over the elements
X * of any collection.
X */
X
typedef struct iteratorCDT *iteratorADT;
X
/* Exported entries */
X
/*
X * Functions: NewIterator, StepIterator, FreeIterator
X * Usage: iterator = NewIterator(collection);
X *        while (StepIterator(iterator, &element)) {
X *            . . . body of loop involving element . . .
X *        }
X *        FreeIterator(iterator);
X * -----------------------------------------------------
X * These functions make it possible to iterate over the
X * elements in any collection that supports iteration.  Each
X * call to StepIterator advances the iterator and returns the
X * next element using the reference parameter.  StepIterator
X * returns TRUE until the keys are exhausted, after which it
X * returns FALSE.  The FreeIterator function releases any
X * storage associated with the iterator.
X */
X
iteratorADT NewIterator(void *collection);
bool StepIterator(iteratorADT iterator, void *ep);
void FreeIterator(iteratorADT iterator);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/15-Sets/iterator.h' &&
  chmod 0644 'programs/15-Sets/iterator.h' ||
  echo 'restore of programs/15-Sets/iterator.h failed'
  shar_count="`wc -c < 'programs/15-Sets/iterator.h'`"
  test 1531 -eq "$shar_count" ||
    echo "programs/15-Sets/iterator.h: original size 1531, current size $shar_count"
fi
# ============= programs/15-Sets/itertype.h ==============
if test -f 'programs/15-Sets/itertype.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/15-Sets/itertype.h (file already exists)'
else
  echo 'x - extracting programs/15-Sets/itertype.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/15-Sets/itertype.h' &&
/*
X * File: itertype.h
X * ----------------
X * This file provides an interface that package designers can
X * use to export new collection types that support iteration.
X * Clients of those collection types who merely want to use
X * iterators will not need to import this interface.
X */
X
#ifndef _itertype_h
#define _itertype_h
X
#include "genlib.h"
#include "iterator.h"
#include "cmpfn.h"
X
/*
X * General overview
X * ----------------
X * In order to create a collection type that supports iteration,
X * the implementor of the type must first allocate space at the
X * beginning of the concrete record for an iteratorHeaderT that
X * contains a function pointer which allows NewIterator to make
X * a new iterator for that collection type.  The implementor
X * must initialize this header in the constructor function by
X * calling EnableIteration.  The specific NewIterator functions
X * for each type must perform the following operations:
X *
X * 1. Call NewIteratorList to create an empty iterator.
X * 2. Call AddToIteratorList for each element.
X * 3. Return the completed iterator.
X *
X * Elements in the iterator may be sorted or unsorted depending
X * on the comparison function passed to NewIteratorList.
X */
X
/*
X * Type: newIteratorFnT
X * --------------------
X * This type represents the class of functions that create new
X * iterators.
X */
X
typedef iteratorADT (*newIteratorFnT)(void *collection);
X
/*
X * Constant function: UnsortedFn
X * -----------------------------
X * This constant creates a NULL function pointer that can be
X * used in place of the comparison function to indicate that the
X * values in the iterator should not be sorted.  The constant 0
X * is used in place of NULL because some compilers do not allow
X * casting NULL to a function pointer.
X */
X
#define UnsortedFn ((cmpFnT) 0)
X
/*
X * Type: iteratorHeaderT
X * ---------------------
X * This structure must appear at the beginning of any concrete
X * structure that supports iteration.
X */
X
typedef struct {
X    unsigned long password;
X    newIteratorFnT newFn;
} iteratorHeaderT;
X
/*
X * Functions: EnableIteration
X * Usage: EnableIteration(collection, newFn);
X * ------------------------------------------
X * This function enables iteration for the collection.  The
X * function pointer newFn is used to initialize an iterator
X * for this type.
X */
X
void EnableIteration(void *collection, newIteratorFnT newFn);
X
/*
X * Functions: NewIteratorList
X * Usage: iterator = NewIteratorList(sizeof (type), cmpFn);
X * --------------------------------------------------------
X * This function creates a new iterator with an empty iterator
X * list.  The first argument is the size of the element type,
X * which makes it possible for the package to allocate storage
X * for values of that type.  The cmpFn is the comparison function
X * used to sort the iterator elements.  If cmpFn is the constant
X * pointer UnsortedFn, the elements are entered in the order in
X * which AddToIteratorList is called.
X */
X
iteratorADT NewIteratorList(int size, cmpFnT cmpFn);
X
/*
X * Functions: AddToIteratorList
X * Usage: AddToIteratorList(iterator, &element);
X * ---------------------------------------------
X * This function takes an iterator and a pointer to an element
X * and inserts the element into the iterator list.
X */
X
void AddToIteratorList(iteratorADT iterator, void *ep);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/15-Sets/itertype.h' &&
  chmod 0644 'programs/15-Sets/itertype.h' ||
  echo 'restore of programs/15-Sets/itertype.h failed'
  shar_count="`wc -c < 'programs/15-Sets/itertype.h'`"
  test 3324 -eq "$shar_count" ||
    echo "programs/15-Sets/itertype.h: original size 3324, current size $shar_count"
fi
# ============= programs/15-Sets/permute.c ==============
if test -f 'programs/15-Sets/permute.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/15-Sets/permute.c (file already exists)'
else
  echo 'x - extracting programs/15-Sets/permute.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/15-Sets/permute.c' &&
/*
X * File: permute.c
X * ---------------
X * This file implements and tests the ListPermutation function.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "strlib.h"
#include "simpio.h"
#include "iterator.h"
#include "cmpfn.h"
#include "set.h"
X
/* Private function prototypes */
X
static void ListPermutations(string str);
static void RecursivePermute(string str, int k, setADT set);
static void ExchangeCharacters(string str, int p1, int p2);
X
/* Main program */
X
main()
{
X    string str;
X
X    printf("This program lists unique permutations.\n");
X    printf("Enter a string: ");
X    str = GetLine();
X    ListPermutations(str);
}
X
/*
X * Function: ListPermutations
X * Usage: ListPermutations(str)
X * ----------------------------
X * This function lists all permutations of the characters in the
X * string str.  If the same string is generated more than once
X * in the course of the algorithm, each of those permutations is
X * listed only once.
X */
X
static void ListPermutations(string str)
{
X    setADT set;
X    iteratorADT iterator;
X    string s;
X
X    set = NewPtrSet(StringCmpFn);
X    RecursivePermute(str, 0, set);
X    iterator = NewIterator(set);
X    while (StepIterator(iterator, &s)) {
X        printf("%s\n", s);
X    }
X    FreeIterator(iterator);
}
X
/*
X * Function: RecursivePermute
X * Usage: RecursivePermute(str, k, set);
X * -------------------------------------
X * This function implements the recursive permutation algorithm,
X * adding each permutation to the set as it goes.
X */
X
static void RecursivePermute(string str, int k, setADT set)
{
X    int i;
X
X    if (k == StringLength(str)) {
X        AddPtrElement(set, CopyString(str));
X    } else {
X        for (i = k; i < StringLength(str); i++) {
X            ExchangeCharacters(str, k, i);
X            RecursivePermute(str, k + 1, set);
X            ExchangeCharacters(str, k, i);
X        }
X    }
}
X
/*
X * Function: ExchangeCharacters
X * Usage: ExchangeCharacters(str, p1, p2);
X * ---------------------------------------
X * This function exchanges the characters at positions p1
X * and p2 of the string s.
X */
X
static void ExchangeCharacters(string str, int p1, int p2)
{
X    char tmp;
X
X    tmp = str[p1];
X    str[p1] = str[p2];
X    str[p2] = tmp;
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/15-Sets/permute.c' &&
  chmod 0644 'programs/15-Sets/permute.c' ||
  echo 'restore of programs/15-Sets/permute.c failed'
  shar_count="`wc -c < 'programs/15-Sets/permute.c'`"
  test 2209 -eq "$shar_count" ||
    echo "programs/15-Sets/permute.c: original size 2209, current size $shar_count"
fi
# ============= programs/15-Sets/set.c ==============
if test -f 'programs/15-Sets/set.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/15-Sets/set.c (file already exists)'
else
  echo 'x - extracting programs/15-Sets/set.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/15-Sets/set.c' &&
/*
X * File: set.c
X * -----------
X * This file implements the set abstraction defined in set.h.
X */
X
#include <stdio.h>
#include <stdarg.h>
#include "genlib.h"
#include "bst.h"
#include "itertype.h"
#include "iterator.h"
#include "set.h"
X
/*
X * Type: setCDT
X * ------------
X * This type defines the concrete structure of a set.
X */
X
struct setCDT {
X    iteratorHeaderT header;
X    setClassT class;
X    cmpFnT cmpFn;
X    int nElements;
X    bstADT bst;
};
X
/*
X * Type: setElementT
X * -----------------
X * This union type combines the two representations of an element.
X * It is used in the implementation to allocate storage for an
X * element that is guaranteed to be large enough no matter whether
X * the set contains integers or pointers.  This type is used only
X * to reduce the number of special cases in the code and is not
X * exported to the client.
X */
X
typedef union {
X    int intRep;
X    void *ptrRep;
} setElementT;
X
/* Private function prototypes */
X
static setADT NewSet(setClassT class, cmpFnT cmpFn);
static void InitSetNodeFn(void *np, void *kp, void *clientData);
static void FreeNodeFn(void *np, void *clientData);
static void AddERef(setADT set, void *ep);
static void DeleteERef(setADT set, void *ep);
static bool TestERef(setADT set, void *ep);
static iteratorADT NewSetIterator(void *collection);
static void AddElementToIterator(void *np, void *clientData);
X
/* Exported entries */
X
/*
X * Implementation notes: NewIntSet, NewPtrSet
X * ------------------------------------------
X * The contructor functions call a common function that creates
X * a new set from a class and a comparison function.  The
X * elements in the set are stored in a binary search tree.
X */
X
setADT NewIntSet(void)
{
X    return (NewSet(IntSet, IntCmpFn));
}
X
setADT NewPtrSet(cmpFnT cmpFn)
{
X    return (NewSet(PtrSet, cmpFn));
}
X
static setADT NewSet(setClassT class, cmpFnT cmpFn)
{
X    setADT set;
X
X    set = New(setADT);
X    EnableIteration(set, NewSetIterator);
X    set->class = class;
X    set->cmpFn = cmpFn;
X    set->nElements = 0;
X    set->bst = NewBST(sizeof (setElementT), cmpFn, InitSetNodeFn);
X    return (set);
}
X
static void InitSetNodeFn(void *np, void *kp, void *clientData)
{
X    setADT set = (setADT) clientData;
X
X    switch (set->class) {
X      case IntSet: *((int *) np) = *((int *) kp); break;
X      case PtrSet: *((void **) np) = *((void **) kp); break;
X    }
X    set->nElements++;
}
X
void FreeSet(setADT set)
{
X    FreeBST(set->bst, FreeNodeFn);
X    FreeBlock(set);
}
X
static void FreeNodeFn(void *np, void *clientData)
{
X    FreeBlock(np);
}
X
/* Selection functions */
X
setClassT GetSetClass(setADT set)
{
X    return (set->class);
}
X
cmpFnT GetCompareFunction(setADT set)
{
X    return (set->cmpFn);
}
X
/*
X * Implementation notes: NElements, SetIsEmpty
X * -------------------------------------------
X * For efficiency, this package stores the number of elements
X * as part of the set data structure, updating it as necessary.
X */
X
int NElements(setADT set)
{
X    return (set->nElements);
}
X
bool SetIsEmpty(setADT set)
{
X    return (set->nElements == 0);
}
X
/*
X * Implementation notes: AddIntElement, AddPtrElement
X * --------------------------------------------------
X * These functions call a common function AddERef, which takes
X * a pointer to the element.
X */
X
X
void AddIntElement(setADT set, int element)
{
X    if (set->class != IntSet) Error("Set is not an integer set");
X    AddERef(set, &element);
}
X
void AddPtrElement(setADT set, void *element)
{
X    if (set->class != PtrSet) Error("Set is not a pointer set");
X    AddERef(set, &element);
}
X
void AddElement(setADT set, ...)
{
X    va_list args;
X    int n;
X    void *p, *np, *ep;
X
X    va_start(args, set);
X    switch (set->class) {
X      case IntSet: n = va_arg(args, int); ep = &n; break;
X      case PtrSet: p = va_arg(args, void *); ep = &p; break;
X    }
X    va_end(args);
X    AddERef(set, ep);
}
X
static void AddERef(setADT set, void *ep)
{
X    (void) InsertBSTNode(set->bst, ep, set);
}
X
/*
X * Implementation note: AddArrayToSet
X * ----------------------------------
X * This function calls AddERef for each element in the array.
X * Note that the addressing depends on the set class.
X */
X
void AddArrayToSet(setADT set, void *array, int n)
{
X    int i;
X
X    for (i = 0; i < n; i++) {
X        switch (set->class) {
X          case IntSet: AddERef(set, ((int *) array) + i); break;
X          case PtrSet: AddERef(set, ((void **) array) + i); break;
X        }
X    }
}
X
/*
X * Implementation notes: DeleteIntElement, DeletePtrElement
X * --------------------------------------------------------
X * These functions simply check to see that the set type is
X * appropriate and then call a common function.
X */
X
void DeleteIntElement(setADT set, int element)
{
X    if (set->class != IntSet) Error("Set is not an integer set");
X    DeleteERef(set, &element);
}
X
void DeletePtrElement(setADT set, void *element)
{
X    if (set->class != PtrSet) Error("Set is not a pointer set");
X    DeleteERef(set, &element);
}
X
void DeleteElement(setADT set, ...)
{
X    va_list args;
X    int n;
X    void *p, *np, *ep;
X
X    va_start(args, set);
X    switch (set->class) {
X      case IntSet: n = va_arg(args, int); ep = &n; break;
X      case PtrSet: p = va_arg(args, void *); ep = &p; break;
X    }
X    va_end(args);
X    DeleteERef(set, ep);
}
X
static void DeleteERef(setADT set, void *ep)
{
X    void *np;
X
X    np = DeleteBSTNode(set->bst, ep);
X    if (np != NULL) {
X        FreeBlock(np);
X        set->nElements--;
X    }
}
X
/*
X * Implementation notes: IsIntElement, IsPtrElement
X * ------------------------------------------------
X * These implementations call a common TestERef function, which
X * in turn calls FindBSTNode to look up the element.
X */
X
bool IsIntElement(setADT set, int element)
{
X    if (set->class != IntSet) Error("Set is not an integer set");
X    return (TestERef(set, &element));
}
X
bool IsPtrElement(setADT set, void *element)
{
X    if (set->class != PtrSet) Error("Set is not a pointer set");
X    return (TestERef(set, &element));
}
X
bool IsElement(setADT set, ...)
{
X    va_list args;
X    int n;
X    void *p, *np, *ep;
X
X    va_start(args, set);
X    switch (set->class) {
X      case IntSet: n = va_arg(args, int); ep = &n; break;
X      case PtrSet: p = va_arg(args, void *); ep = &p; break;
X    }
X    va_end(args);
X    return (TestERef(set, ep));
}
X
static bool TestERef(setADT set, void *ep)
{
X    return (FindBSTNode(set->bst, ep) != NULL);
}
X
/*
X * Implementation notes: Set operations
X * ------------------------------------
X * The functions IsSubset, Union, Intersection, and SetDifference
X * are similar in structure.  Each one uses an iterator to walk over
X * the appropriate set.  Because the functions in bst.h need only
X * the address of an element, the functions can use the union type
X * setElementT to avoid special-case code for the two set classes.
X */
X
bool SetEqual(setADT s1, setADT s2)
{
X    return (IsSubset(s1, s2) && IsSubset(s2, s1));
}
X
bool IsSubset(setADT s1, setADT s2)
{
X    iteratorADT iterator;
X    setElementT element;
X    bool result;
X
X    if (s1->class != s2->class || s1->cmpFn != s2->cmpFn) {
X        Error("IsSubset: Set types do not match");
X    }
X    result = TRUE;
X    iterator = NewIterator(s1);
X    while (result && StepIterator(iterator, &element)) {
X        if (!TestERef(s2, &element)) result = FALSE;
X    }
X    FreeIterator(iterator);
X    return (result);
}
X
setADT Union(setADT s1, setADT s2)
{
X    iteratorADT iterator;
X    setElementT element;
X    setADT set;
X
X    if (s1->class != s2->class || s1->cmpFn != s2->cmpFn) {
X        Error("Union: Set types do not match");
X    }
X    set = NewSet(s1->class, s1->cmpFn);
X    iterator = NewIterator(s1);
X    while (StepIterator(iterator, &element)) {
X        AddERef(set, &element);
X    }
X    FreeIterator(iterator);
X    iterator = NewIterator(s2);
X    while (StepIterator(iterator, &element)) {
X        AddERef(set, &element);
X    }
X    FreeIterator(iterator);
X    return (set);
}
X
setADT Intersection(setADT s1, setADT s2)
{
X    iteratorADT iterator;
X    setElementT element;
X    setADT set;
X
X    if (s1->class != s2->class || s1->cmpFn != s2->cmpFn) {
X        Error("Intersection: Set types do not match");
X    }
X    set = NewSet(s1->class, s1->cmpFn);
X    iterator = NewIterator(s1);
X    while (StepIterator(iterator, &element)) {
X        if (TestERef(s2, &element)) AddERef(set, &element);
X    }
X    FreeIterator(iterator);
X    return (set);
}
X
setADT SetDifference(setADT s1, setADT s2)
{
X    iteratorADT iterator;
X    setElementT element;
X    setADT set;
X
X    if (s1->class != s2->class || s1->cmpFn != s2->cmpFn) {
X        Error("SetDifference: Set types do not match");
X    }
X    set = NewSet(s1->class, s1->cmpFn);
X    iterator = NewIterator(s1);
X    while (StepIterator(iterator, &element)) {
X        if (!TestERef(s2, &element)) AddERef(set, &element);
X    }
X    FreeIterator(iterator);
X    return (set);
}
X
/*
X * Implementation notes: NewSetIterator, AddElementToIterator
X * ----------------------------------------------------------
X * These functions make it possible to use the general iterator
X * facility on sets.  For details on the general strategy, see
X * the comments in the itertype.h interface.  The comparison
X * function passed to NewIteratorList is UnsortedFn because the
X * InOrder walk already guarantees that the elements will appear
X * in sorted order.
X */
X
static iteratorADT NewSetIterator(void *collection)
{
X    setADT set = collection;
X    int elementSize;
X    iteratorADT iterator;
X
X    switch (set->class) {
X      case IntSet: elementSize = sizeof(int); break;
X      case PtrSet: elementSize = sizeof(void *); break;
X    }
X    iterator = NewIteratorList(elementSize, UnsortedFn);
X    MapBST(AddElementToIterator, set->bst, InOrder, iterator);
X    return (iterator);
}
X
static void AddElementToIterator(void *np, void *clientData)
{
X    AddToIteratorList((iteratorADT) clientData, np);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/15-Sets/set.c' &&
  chmod 0644 'programs/15-Sets/set.c' ||
  echo 'restore of programs/15-Sets/set.c failed'
  shar_count="`wc -c < 'programs/15-Sets/set.c'`"
  test 9887 -eq "$shar_count" ||
    echo "programs/15-Sets/set.c: original size 9887, current size $shar_count"
fi
# ============= programs/15-Sets/set.h ==============
if test -f 'programs/15-Sets/set.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/15-Sets/set.h (file already exists)'
else
  echo 'x - extracting programs/15-Sets/set.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/15-Sets/set.h' &&
/*
X * File: set.h
X * -----------
X * This interface exports the type setADT, which can be used
X * to represent sets of objects.  The objects themselves can
X * be either of the following two types:
X *
X * int     This base type makes it easy to represent sets
X *         of integers (or any other scalar type), which come
X *         up frequently in practice.
X *
X * void *  This base type makes it possible for clients to
X *         use the set package with more sophisticated
X *         client-defined types.  The only requirement is that
X *         the client must supply a comparison function that
X *         compares two elements of the specified type.
X *
X * These two base types define two classes of sets, IntSet and
X * PtrSet.  The class of the set is determined when the set is
X * created, and the interface in some cases provides separate
X * functions for dealing with sets of each class.
X *
X * In addition to the set operations shown in this interface,
X * the set type allows iteration, as described in the iterator.h
X * interface.  The standard iterator idiom looks like this:
X *
X *     iterator = NewIterator(s);
X *     while (StepIterator(iterator, &x)) {
X *        . . . body of loop involving x . . .
X *     }
X *     FreeIterator(iterator);
X */
X
#ifndef _set_h
#define _set_h
X
#include "genlib.h"
#include "cmpfn.h"
X
/*
X * Type: setClassT
X * ---------------
X * This enumeration type defines the two possible set classes.
X */
X
typedef enum { IntSet, PtrSet } setClassT;
X
/*
X * Type: setADT
X * ------------
X * This type defines the abstract set type.  Depending on how
X * you initialize it, a set may be of either class.
X */
X
typedef struct setCDT *setADT;
X
/* Exported entries */
X
/*
X * Functions: NewIntSet, NewPtrSet
X * Usage: set = NewIntSet();
X *        set = NewPtrSet(cmpFn);
X * ------------------------------
X * These functions are used to create empty setADT values of the
X * specified class.  The NewIntSet function creates sets capable
X * of holding integers; the NewPtrSet function creates a more
X * general set type capable of holding client-specified types.
X */
X
setADT NewIntSet(void);
setADT NewPtrSet(cmpFnT cmpFn);
X
/*
X * Function: FreeSet
X * Usage: FreeSet(set);
X * --------------------
X * This function frees the storage associated with set, which
X * may be of either class.
X */
X
void FreeSet(setADT set);
X
/*
X * Functions: GetSetClass, GetCompareFunction
X * Usage: class = GetSetClass(set);
X *        fn = GetCompareFunction(set);
X * ------------------------------------
X * These functions return the set class and the comparison
X * function for an existing set.
X */
X
setClassT GetSetClass(setADT set);
cmpFnT GetCompareFunction(setADT set);
X
/*
X * Function: NElements
X * Usage: n = NElements(set);
X * --------------------------
X * This function returns the number of elements in the set.
X */
X
int NElements(setADT set);
X
/*
X * Function: SetIsEmpty
X * Usage: if (SetIsEmpty(set)) . . .
X * ---------------------------------
X * This function returns TRUE if the set has no elements.
X */
X
bool SetIsEmpty(setADT set);
X
/*
X * Functions: AddIntElement, AddPtrElement
X * Usage: AddIntElement(set, element);
X *        AddPtrElement(set, element);
X * ---------------------------------------
X * These functions each add a new element to an existing set
X * and differ only in the type of that element.
X */
X
void AddIntElement(setADT set, int element);
void AddPtrElement(setADT set, void *element);
X
/*
X * Function: AddElement
X * Usage: AddElement(set, element);
X * --------------------------------
X * This function adds an element to the set, using the set class
X * to determine the addressing structure of the element.
X */
X
void AddElement(setADT set, ...);
X
/*
X * Function: AddArrayToSet
X * Usage: AddArrayToSet(set, array, n);
X * ------------------------------------
X * This function adds the elements in the specified array to the
X * set.  The parameter n gives the effective size of the array.
X * The client is responsible for ensuring that the type of the
X * array matches the element type of the set.
X */
X
void AddArrayToSet(setADT set, void *array, int n);
X
/*
X * Functions: DeleteIntElement, DeletePtrElement
X * Usage: DeleteIntElement(set, element);
X *        DeletePtrElement(set, element);
X * ---------------------------------------------
X * These functions delete the element from the set, if it exists.
X */
X
void DeleteIntElement(setADT set, int element);
void DeletePtrElement(setADT set, void *element);
X
/*
X * Function: DeleteElement
X * Usage: DeleteElement(set, element);
X * -----------------------------------
X * This function deletes an element from the set, using the set
X * class to determine the addressing structure of the element.
X */
X
void DeleteElement(setADT set, ...);
X
/*
X * Functions: IsIntElement, IsPtrElement
X * Usage: if (IsIntElement(set, element)) . . .
X *        if (IsPtrElement(set, element)) . . .
X * --------------------------------------------
X * These functions return TRUE if the element is in the set.
X */
X
bool IsIntElement(setADT set, int element);
bool IsPtrElement(setADT set, void *element);
X
/*
X * Function: IsElement
X * Usage: if (IsElement(set, element)) . . .
X * -----------------------------------------
X * This function returns TRUE if the element is in the set.
X */
X
bool IsElement(setADT set, ...);
X
/*
X * Functions: SetEqual, IsSubset
X * Usage: if (SetEqual(s1, s2)) . . .
X *        if (IsSubset(s1, s2)) . . .
X * ----------------------------------
X * These predicate functions implement the equality and subset
X * relations on sets, respectively.  SetEqual(s1, s2) returns
X * TRUE if s1 and s2 have the same elements.  IsSubset(s1, s2)
X * returns TRUE if all elements of s1 are also elements of s2.
X */
X
bool SetEqual(setADT s1, setADT s2);
bool IsSubset(setADT s1, setADT s2);
X
/*
X * Functions: Union, Intersection, SetDifference
X * Usage: set = Union(s1, s2);
X *        set = Intersection(s1, s2);
X *        set = SetDifference(s1, s2);
X * ---------------------------------------------
X * These functions each return a new set, as follows:
X *
X * Union(s1, s2)          All elements in either s1 or s2.
X * Intersection(s1, s2)   All elements in both s1 and s2.
X * SetDifference(s1, s2)  All elements in s1 but not in s2.
X */
X
setADT Union(setADT s1, setADT s2);
setADT Intersection(setADT s1, setADT s2);
setADT SetDifference(setADT s1, setADT s2);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/15-Sets/set.h' &&
  chmod 0644 'programs/15-Sets/set.h' ||
  echo 'restore of programs/15-Sets/set.h failed'
  shar_count="`wc -c < 'programs/15-Sets/set.h'`"
  test 6341 -eq "$shar_count" ||
    echo "programs/15-Sets/set.h: original size 6341, current size $shar_count"
fi
# ============= programs/15-Sets/settest.c ==============
if test -f 'programs/15-Sets/settest.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/15-Sets/settest.c (file already exists)'
else
  echo 'x - extracting programs/15-Sets/settest.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/15-Sets/settest.c' &&
/*
X * File: settest.c
X * ---------------
X * This program performs a simple test of the set abstraction
X * by calling the basic functions on some constant sets.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "foreach.h"
#include "iterator.h"
#include "set.h"
X
#define DisplaySet(set) DisplaySetWithLabel(set, #set)
static void DisplaySetWithLabel(setADT set, string label);
static int SumIntSet(setADT set);
X
main()
{
X    setADT s13579, s2468, s1248, s2357, s23, s1234;
X
X    s13579 = NewIntSet();
X    AddIntElement(s13579, 1);
X    AddIntElement(s13579, 3);
X    AddIntElement(s13579, 5);
X    AddIntElement(s13579, 7);
X    AddIntElement(s13579, 9);
X    s2468 = NewIntSet();
X    AddIntElement(s2468, 2);
X    AddIntElement(s2468, 4);
X    AddIntElement(s2468, 6);
X    AddIntElement(s2468, 8);
X    s1248 = NewIntSet();
X    AddIntElement(s1248, 1);
X    AddIntElement(s1248, 2);
X    AddIntElement(s1248, 4);
X    AddIntElement(s1248, 8);
X    s2357 = NewIntSet();
X    AddIntElement(s2357, 2);
X    AddIntElement(s2357, 3);
X    AddIntElement(s2357, 5);
X    AddIntElement(s2357, 7);
X    s23 = NewIntSet();
X    AddIntElement(s23, 2);
X    AddIntElement(s23, 3);
X    s1234 = NewIntSet();
X    AddIntElement(s1234, 1);
X    AddIntElement(s1234, 2);
X    AddIntElement(s1234, 3);
X    AddIntElement(s1234, 4);
X    DisplaySet(Union(s13579, s2468));
X    DisplaySet(Union(s1248, s2357));
X    DisplaySet(Union(s23, s1234));
X    printf("\n");
X    DisplaySet(Intersection(s13579, s2468));
X    DisplaySet(Intersection(s1248, s2357));
X    DisplaySet(Intersection(s23, s1234));
X    printf("\n");
X    DisplaySet(SetDifference(s13579, s2468));
X    DisplaySet(SetDifference(s1248, s2357));
X    DisplaySet(SetDifference(s23, s1234));
X    printf("\n");
X    printf("SumIntSet(s13579) = %d\n", SumIntSet(s13579));
}
X
static void DisplaySetWithLabel(setADT set, string label)
{
X    iteratorADT iterator;
X    int x;
X    bool first;
X
X    printf("%s = { ", label);
X    iterator = NewIterator(set);
X    first = TRUE;
X    while (StepIterator(iterator, &x)) {
X        if (!first) printf(", ");
X        first = FALSE;
X        printf("%d", x);
X    }
X    printf(" }\n");
}
X
int SumIntSet(setADT set)
{
X    int x, sum;
X
X    sum = 0;
X    foreach (x in set) {
X        sum += x;
X    }
X    return (sum);
}
X
X
SHAR_EOF
  $shar_touch -am 0903182097 'programs/15-Sets/settest.c' &&
  chmod 0644 'programs/15-Sets/settest.c' ||
  echo 'restore of programs/15-Sets/settest.c failed'
  shar_count="`wc -c < 'programs/15-Sets/settest.c'`"
  test 2260 -eq "$shar_count" ||
    echo "programs/15-Sets/settest.c: original size 2260, current size $shar_count"
fi
# ============= programs/15-Sets/strtest.c ==============
if test -f 'programs/15-Sets/strtest.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/15-Sets/strtest.c (file already exists)'
else
  echo 'x - extracting programs/15-Sets/strtest.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/15-Sets/strtest.c' &&
/*
X * File: strtest.c
X * ---------------
X * This program tests the set abstraction.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "strlib.h"
#include "iterator.h"
#include "set.h"
X
static string monthNames[] = {
X    "January", "February", "March", "April",
X    "May", "June", "July", "August", "September",
X    "October", "November", "December"
};
static string shorterNames[] = {
X    "September", "April", "June", "November", "February"
};
static string firstNames[] = {
X    "January", "February", "March", "April", "May", "June"
};
X
#define DisplaySet(set) DisplaySetWithLabel(set, #set)
static void DisplaySetWithLabel(setADT set, string label);
X
main()
{
X    setADT months, shorter, first;
X
X    months = NewPtrSet(StringCmpFn);
X    AddArrayToSet(months, monthNames, sizeof monthNames / sizeof (string));
X    shorter = NewPtrSet(StringCmpFn);
X    AddArrayToSet(shorter, shorterNames, sizeof shorterNames / sizeof (string));
X    first = NewPtrSet(StringCmpFn);
X    AddArrayToSet(first, firstNames, sizeof firstNames / sizeof (string));
X    DisplaySet(shorter);
X    DisplaySet(first);
X    DisplaySet(Intersection(shorter, first));
X    DisplaySet(Union(shorter, first));
}
X
static void DisplaySetWithLabel(setADT set, string label)
{
X    iteratorADT iterator;
X    string x;
X    bool first;
X
X    printf("%s:\n  {", label);
X    iterator = NewIterator(set);
X    first = TRUE;
X    while (StepIterator(iterator, &x)) {
X        if (!first) printf(", ");
X        first = FALSE;
X        printf("%s", x);
X    }
X    printf("}\n");
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/15-Sets/strtest.c' &&
  chmod 0644 'programs/15-Sets/strtest.c' ||
  echo 'restore of programs/15-Sets/strtest.c failed'
  shar_count="`wc -c < 'programs/15-Sets/strtest.c'`"
  test 1530 -eq "$shar_count" ||
    echo "programs/15-Sets/strtest.c: original size 1530, current size $shar_count"
fi
# ============= programs/15-Sets/Makefile ==============
if test -f 'programs/15-Sets/Makefile' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/15-Sets/Makefile (file already exists)'
else
  echo 'x - extracting programs/15-Sets/Makefile (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/15-Sets/Makefile' &&
# Makefile for programs in directory 15-Sets
# ***************************************************************
X
PROGRAMS = \
X    permute \
X    intsettest \
X    settest \
X    strtest
X
# ***************************************************************
# Parameters to control Makefile operation
# Note that the gccx command script must be defined
X
CC = gccx
CFLAGS = 
X
# ***************************************************************
# Entry to bring the package up to date
X
all: $(PROGRAMS)
X
# ***************************************************************
# Standard entries to remove files from the directories
#    tidy    -- eliminate unwanted files
#    scratch -- delete derived files in preparation for rebuild
X
tidy:
X	rm -f ,* .,* *~ core a.out graphics.ps
X
scratch: tidy
X	rm -f *.o *.a $(PROGRAMS)
X
# ***************************************************************
# C compilations
X
bst.o: bst.c bst.h cmpfn.h
X	$(CC) $(CFLAGS) -c bst.c
X
cmpfn.o: cmpfn.c cmpfn.h
X	$(CC) $(CFLAGS) -c cmpfn.c
X
cvecset.o: cvecset.c cvector.h iterator.h itertype.h set.h
X	$(CC) $(CFLAGS) -c cvecset.c
X
cvector.o: cvector.c cvector.h
X	$(CC) $(CFLAGS) -c cvector.c
X
foreach.o: foreach.c foreach.h iterator.h
X	$(CC) $(CFLAGS) -c foreach.c
X
iterator.o: iterator.c cmpfn.h iterator.h itertype.h
X	$(CC) $(CFLAGS) -c iterator.c
X
permute.o: permute.c cmpfn.h iterator.h set.h
X	$(CC) $(CFLAGS) -c permute.c
X
set.o: set.c bst.h iterator.h itertype.h set.h
X	$(CC) $(CFLAGS) -c set.c
X
settest.o: settest.c iterator.h set.h
X	$(CC) $(CFLAGS) -c settest.c
X
strtest.o: strtest.c iterator.h set.h
X	$(CC) $(CFLAGS) -c strtest.c
X
X
# ***************************************************************
# Executable programs
X
permute: permute.o bst.o cmpfn.o iterator.o set.o
X	$(CC) $(CFLAGS) -o permute bst.o permute.o cmpfn.o \
X                                  iterator.o set.o 
X
intsettest: settest.o cvecset.o cvector.o foreach.o iterator.o
X	$(CC) $(CFLAGS) -o intsettest settest.o cvecset.o cvector.o \
X                                      foreach.o iterator.o
X
settest: settest.o bst.o cmpfn.o foreach.o iterator.o set.o
X	$(CC) $(CFLAGS) -o settest settest.o bst.o cmpfn.o \
X                                  foreach.o iterator.o set.o
X
strtest: strtest.o bst.o cmpfn.o iterator.o set.o
X	$(CC) $(CFLAGS) -o strtest strtest.o bst.o cmpfn.o \
X                                  iterator.o set.o
SHAR_EOF
  $shar_touch -am 0905214097 'programs/15-Sets/Makefile' &&
  chmod 0644 'programs/15-Sets/Makefile' ||
  echo 'restore of programs/15-Sets/Makefile failed'
  shar_count="`wc -c < 'programs/15-Sets/Makefile'`"
  test 2363 -eq "$shar_count" ||
    echo "programs/15-Sets/Makefile: original size 2363, current size $shar_count"
fi
# ============= programs/15-Sets/foreach.c ==============
if test -f 'programs/15-Sets/foreach.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/15-Sets/foreach.c (file already exists)'
else
  echo 'x - extracting programs/15-Sets/foreach.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/15-Sets/foreach.c' &&
/*
X * File: foreach.c
X * ---------------
X * This interface implements the foreach construct.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "iterator.h"
#include "foreach.h"
X
typedef struct cellT {
X    void *ep;
X    iteratorADT iterator;
X    struct cellT *link;
} cellT;
X
static cellT *iteratorList = NULL;
X
/* Entry points */
X
void InitForEach(void *ep, void *collection)
{
X    cellT *cp;
X
X    for (cp = iteratorList; cp != NULL && cp->ep != ep; cp = cp->link) {
X        /* no action */
X    }
X    if (cp == NULL) {
X        cp = New(cellT *);
X        cp->ep = ep;
X        cp->link = iteratorList;
X        iteratorList = cp;
X    } else {
X        if (cp->iterator != NULL) FreeIterator(cp->iterator);
X    }
X    cp->iterator = NewIterator(collection);
}
X
bool StepForEach(void *ep)
{
X    cellT *cp;
X    bool result;
X
X    for (cp = iteratorList; cp != NULL && cp->ep != ep; cp = cp->link) {
X        /* no action */
X    }
X    if (cp == NULL) Error("foreach iterator undefined");
X    result = StepIterator(cp->iterator, ep);
X    if (!result) {
X        FreeIterator(cp->iterator);
X        cp->iterator = NULL;
X    }
X    return (result);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/15-Sets/foreach.c' &&
  chmod 0644 'programs/15-Sets/foreach.c' ||
  echo 'restore of programs/15-Sets/foreach.c failed'
  shar_count="`wc -c < 'programs/15-Sets/foreach.c'`"
  test 1138 -eq "$shar_count" ||
    echo "programs/15-Sets/foreach.c: original size 1138, current size $shar_count"
fi
# ============= programs/15-Sets/foreach.h ==============
if test -f 'programs/15-Sets/foreach.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/15-Sets/foreach.h (file already exists)'
else
  echo 'x - extracting programs/15-Sets/foreach.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/15-Sets/foreach.h' &&
/*
X * File: foreach.h
X * ---------------
X * This interface provides a simple syntactic extension for
X * iterators that makes them easier to read.
X */
X
#ifndef _foreach_h
#define _foreach_h
X
#include "genlib.h"
X
/*
X * Statement form: foreach
X * Usage: foreach (element in collection) {
X *            . . . code involving element . . .
X *        }
X * ---------------------------------------------
X * This macro definition creates a new statement form that
X * simplifies the use of iterators.  The variable element
X * must be declared in the current scope and must be
X * compatible with the base type of the collection.  The
X * functions InitForEach and StepForEach are not called
X * directly by the client.
X */
X
#define in ,
#define foreach(arg) _foreach(arg)
#define _foreach(e, c) for (InitForEach(&e, c); StepForEach(&e); )
X
void InitForEach(void *ep, void *collection);
bool StepForEach(void *ep);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/15-Sets/foreach.h' &&
  chmod 0644 'programs/15-Sets/foreach.h' ||
  echo 'restore of programs/15-Sets/foreach.h failed'
  shar_count="`wc -c < 'programs/15-Sets/foreach.h'`"
  test 908 -eq "$shar_count" ||
    echo "programs/15-Sets/foreach.h: original size 908, current size $shar_count"
fi
# ============= programs/16-Graphs/adjmat-graph.c ==============
if test ! -d 'programs/16-Graphs'; then
  echo 'x - creating directory programs/16-Graphs'
  mkdir 'programs/16-Graphs'
fi
if test -f 'programs/16-Graphs/adjmat-graph.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/16-Graphs/adjmat-graph.c (file already exists)'
else
  echo 'x - extracting programs/16-Graphs/adjmat-graph.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/16-Graphs/adjmat-graph.c' &&
/*
X * File: graph.c (adjacency matrix version)
X * ----------------------------------------
X * This file implements the preliminary version of the graph.h
X * interface using an adjacency matrix.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "graph.h"
X
/*
X * Constant: MaxNodes
X * ------------------
X * This constant defines the maximum number of nodes in a
X * graph and is used in this implementation to simplify the
X * presentation.  In practice, it would be better to let the
X * structure expand dynamically.
X */
X
#define MaxNodes 25
X
/*
X * Type: nodeCDT
X * -------------
X * This type defines the concrete representation of a node
X * in the adjacency matrix representation.  The connections
X * are stored as part of the graph.  The index in the node
X * structure identifies the position of this node in the
X * adjacency matrix.
X */
X
struct nodeCDT {
X    graphADT graph;
X    int index;
};
X
/*
X * Type: graphCDT
X * --------------
X * This definition provides the concrete type for a graphADT in
X * the adjacency matrix representation.  The graph includes a
X * fixed array of nodes and a boolean matrix representing the
X * connections.  Note that the array uses the concrete node type,
X * which means that the addresses of these elements are nodeADTs.
X */
X
struct graphCDT {
X    struct nodeCDT nodes[MaxNodes];
X    bool matrix[MaxNodes][MaxNodes];
X    int nNodes;
};
X
/* Exported entries */
X
graphADT NewGraph(void)
{
X    graphADT graph;
X
X    graph = New(graphADT);
X    graph->nNodes = 0;
X    return (graph);
}
X
nodeADT NewNode(graphADT graph)
{
X    nodeADT node;
X    int i, index;
X
X    if (graph->nNodes >= MaxNodes) Error("NewNode: Too many nodes");
X    index = graph->nNodes++;
X    node = &graph->nodes[index];
X    node->graph = graph;
X    node->index = index;
X    for (i = 0; i < graph->nNodes; i++) {
X        graph->matrix[i][index] = FALSE;
X        graph->matrix[index][i] = FALSE;
X    }
X    return (node);
}
X
void Connect(nodeADT n1, nodeADT n2)
{
X    if (n1->graph != n2->graph) {
X        Error("Connect: Nodes are in different graphs");
X    }
X    n1->graph->matrix[n1->index][n2->index] = TRUE;
}
X
bool IsConnected(nodeADT n1, nodeADT n2)
{
X    if (n1->graph != n2->graph) {
X        Error("Connect: Nodes are in different graphs");
X    }
X    return (n1->graph->matrix[n1->index][n2->index]);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/16-Graphs/adjmat-graph.c' &&
  chmod 0644 'programs/16-Graphs/adjmat-graph.c' ||
  echo 'restore of programs/16-Graphs/adjmat-graph.c failed'
  shar_count="`wc -c < 'programs/16-Graphs/adjmat-graph.c'`"
  test 2307 -eq "$shar_count" ||
    echo "programs/16-Graphs/adjmat-graph.c: original size 2307, current size $shar_count"
fi
# ============= programs/16-Graphs/bst.c ==============
if test -f 'programs/16-Graphs/bst.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/16-Graphs/bst.c (file already exists)'
else
  echo 'x - extracting programs/16-Graphs/bst.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/16-Graphs/bst.c' &&
/*
X * File: bst.c
X * -----------
X * This file implements the bst.h interface, which provides a
X * general implementation of binary search trees.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "cmpfn.h"
#include "bst.h"
X
/*
X * Type: treeT
X * -----------
X * Because the implementation does not know the structure of a
X * node, pointers to nodes cannot be defined explicitly and must
X * be represented using void *.  For readability, the code declares
X * any void * pointers that are in fact trees to be of type treeT.
X */
X
typedef void *treeT;
X
/*
X * Type: bstCDT
X * ------------
X * This type is the concrete type used to represent the bstADT.
X */
X
struct bstCDT {
X    treeT root;
X    int userSize, totalSize;
X    cmpFnT cmpFn;
X    nodeInitFnT nodeInitFn;
};
X
/*
X * Type: bstDataT
X * --------------
X * This record is allocated at the end of the client's structure
X * and is used to maintain the structure of the tree.  The code
X * calls BSTData on the node pointer to derive this address.
X */
X
typedef struct {
X    treeT left, right;
} bstDataT;
X
/* Private function prototypes */
X
static treeT *RecFindNode(bstADT bst, treeT t, void *kp);
static void *RecInsertNode(bstADT bst, treeT *tptr, void *kp,
X                           void *clientData);
static void *RecDeleteNode(bstADT bst, treeT *tptr, void *kp);
static void *DeleteTargetNode(bstADT bst, treeT *tptr);
static void RecMapBST(nodeFnT fn, bstADT bst, treeT t,
X                      traversalOrderT order, void *clientData);
static bstDataT *BSTData(bstADT bst, treeT t);
X
/* Exported entries */
X
bstADT NewBST(int size, cmpFnT cmpFn, nodeInitFnT nodeInitFn)
{
X    bstADT bst;
X
X    bst = New(bstADT);
X    bst->root = NULL;
X    bst->userSize = size;
X    bst->totalSize = bst->userSize + sizeof(bstDataT);
X    bst->cmpFn = cmpFn;
X    bst->nodeInitFn = nodeInitFn;
X    return (bst);
}
X
void FreeBST(bstADT bst, nodeFnT freeNodeFn)
{
X    MapBST(freeNodeFn, bst, PostOrder, NULL);
X    FreeBlock(bst);
}
X
/*
X * Implementation notes: FindBSTNode, RecFindNode
X * ----------------------------------------------
X * The FindBSTNode function simply calls RecFindNode to do
X * the work.  The recursive function takes the address of
X * the current node along with the original arguments.
X */
X
void *FindBSTNode(bstADT bst, void *kp)
{
X    return (RecFindNode(bst, bst->root, kp));
}
X
static treeT *RecFindNode(bstADT bst, treeT t, void *kp)
{
X    bstDataT *dp;
X    int sign;
X
X    if (t == NULL) return (NULL);
X    sign = bst->cmpFn(kp, t);
X    if (sign == 0) return (t);
X    dp = BSTData(bst, t);
X    if (sign < 0) {
X        return (RecFindNode(bst, dp->left, kp));
X    } else {
X        return (RecFindNode(bst, dp->right, kp));
X    }
}
X
/*
X * Implementation notes: InsertBSTNode, RecInsertNode
X * --------------------------------------------------
X * The InsertBSTNode function is implemented as a simple wrapper
X * to RecInsertNode, which does all the work.  The difference
X * between the prototypes is that RecInsertNode takes a pointer
X * to the root of the current subtree as an extra argument.
X */
X
void *InsertBSTNode(bstADT bst, void *kp, void *clientData)
{
X    return (RecInsertNode(bst, &bst->root, kp, clientData));
}
X
static void *RecInsertNode(bstADT bst, treeT *tptr, void *kp,
X                           void *clientData)
{
X    bstDataT *dp;
X    treeT t;
X    int sign;
X
X    t = *tptr;
X    if (t == NULL) {
X        t = GetBlock(bst->totalSize);
X        bst->nodeInitFn(t, kp, clientData);
X        dp = BSTData(bst, t);
X        dp->left = dp->right = NULL;
X        *tptr = t;
X        return (t);
X    }
X    sign = bst->cmpFn(kp, t);
X    if (sign == 0) return (t);
X    dp = BSTData(bst, t);
X    if (sign < 0) {
X        return (RecInsertNode(bst, &dp->left, kp, clientData));
X    } else {
X        return (RecInsertNode(bst, &dp->right, kp, clientData));
X    }
}
X
/*
X * Implementation notes: DeleteBSTNode, RecDeleteNode
X * --------------------------------------------------
X * The first step in deleting a node is to find it using binary
X * search, which is performed by these two functions.  If the
X * node is found, DeleteTargetNode does the actual deletion.
X */
X
void *DeleteBSTNode(bstADT bst, void *kp)
{
X    return (RecDeleteNode(bst, &bst->root, kp));
}
X
static void *RecDeleteNode(bstADT bst, treeT *tptr, void *kp)
{
X    bstDataT *dp;
X    treeT t;
X    int sign;
X
X    t = *tptr;
X    if (t == NULL) return (NULL);
X    sign = bst->cmpFn(kp, t);
X    if (sign == 0) {
X        return (DeleteTargetNode(bst, tptr));
X    }
X    dp = BSTData(bst, t);
X    if (sign < 0) {
X        return (RecDeleteNode(bst, &dp->left, kp));
X    } else {
X        return (RecDeleteNode(bst, &dp->right, kp));
X    }
}
X
/*
X * Implementation notes: DeleteTargetNode
X * --------------------------------------
X * This function deletes the node whose address is passed by
X * reference in tptr.  The easy case occurs when either of the
X * children is NULL; all you need to do is replace the node with
X * its non-NULL child.  If both children are non-NULL, this code
X * finds the rightmost descendent of the left child; this node
X * may not be a leaf, but will have no right child.  Its left
X * child replaces it in the tree, after which the replacement
X * node is moved to the position occupied by the target node.
X */
X
static void *DeleteTargetNode(bstADT bst, treeT *tptr)
{
X    treeT target, *rptr;
X    bstDataT *tdp, *rdp;
X
X    target = *tptr;
X    tdp = BSTData(bst, target);
X    if (tdp->left == NULL) {
X        *tptr = tdp->right;
X    } else if (tdp->right == NULL) {
X        *tptr = tdp->left;
X    } else {
X        rptr = &tdp->left;
X        rdp = BSTData(bst, *rptr);
X        while (rdp->right != NULL) {
X            rptr = &rdp->right;
X            rdp = BSTData(bst, *rptr);
X        }
X        *tptr = *rptr;
X        *rptr = rdp->left;
X        rdp->left = tdp->left;
X        rdp->right = tdp->right;
X    }
X    return (target);
}
X
/*
X * Implementation notes: MapBST, RecMapBST
X * ---------------------------------------
X * The MapBST function is implemented as a wrapper to the
X * recursive function RecMapBST, which does the actual work.
X */
X
void MapBST(nodeFnT fn, bstADT bst, traversalOrderT order,
X            void *clientData)
{
X    RecMapBST(fn, bst, bst->root, order, clientData);
}
X
static void RecMapBST(nodeFnT fn, bstADT bst, treeT t,
X                      traversalOrderT order, void *clientData)
{
X    bstDataT *dp;
X
X    if (t != NULL) {
X        dp = BSTData(bst, t);
X        if (order == PreOrder) fn(t, clientData);
X        RecMapBST(fn, bst, dp->left, order, clientData);
X        if (order == InOrder) fn(t, clientData);
X        RecMapBST(fn, bst, dp->right, order, clientData);
X        if (order == PostOrder) fn(t, clientData);
X    }
}
X
/* Low-level functions */
X
void *BSTRoot(bstADT bst)
{
X    return (bst->root);
}
X
void *BSTLeftChild(bstADT bst, void *np)
{
X    bstDataT *dp;
X
X    if (np == NULL) Error("BSTLeftChild: Argument is NULL");
X    dp = BSTData(bst, np);
X    return (dp->left);
}
X
void *BSTRightChild(bstADT bst, void *np)
{
X    bstDataT *dp;
X
X    if (np == NULL) Error("BSTRightChild: Argument is NULL");
X    dp = BSTData(bst, np);
X    return (dp->right);
}
X
/*
X * Function: BSTData
X * Usage: dp = BSTData(bst, t);
X * ----------------------------
X * This function determines the address of the data record
X * containing the pointers for the binary tree.  This record
X * appears at the end of the user structure that begins at t.
X */
X
static bstDataT *BSTData(bstADT bst, treeT t)
{
X    return ((bstDataT *) ((char *) t + bst->userSize));
}
X
X
SHAR_EOF
  $shar_touch -am 0903182097 'programs/16-Graphs/bst.c' &&
  chmod 0644 'programs/16-Graphs/bst.c' ||
  echo 'restore of programs/16-Graphs/bst.c failed'
  shar_count="`wc -c < 'programs/16-Graphs/bst.c'`"
  test 7517 -eq "$shar_count" ||
    echo "programs/16-Graphs/bst.c: original size 7517, current size $shar_count"
fi
# ============= programs/16-Graphs/bst.h ==============
if test -f 'programs/16-Graphs/bst.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/16-Graphs/bst.h (file already exists)'
else
  echo 'x - extracting programs/16-Graphs/bst.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/16-Graphs/bst.h' &&
/*
X * File: bst.h
X * -----------
X * This file provides an interface for a general binary search
X * tree facility that allows the client to maintain control of
X * the structure of the node.
X */
X
#ifndef _bst_h
#define _bst_h
X
#include "genlib.h"
#include "cmpfn.h"
X
/*
X * Type: bstADT
X * ------------
X * This is the abstract type for a binary search tree.
X */
X
typedef struct bstCDT *bstADT;
X
/*
X * Type: nodeFnT
X * -------------
X * This type defines the class of callback functions for nodes.
X */
X
typedef void (*nodeFnT)(void *np, void *clientData);
X
/*
X * Type: nodeInitFnT
X * -----------------
X * This type defines the class of functions used to initialize
X * a newly created node.
X */
X
typedef void (*nodeInitFnT)(void *np, void *kp, void *clientData);
X
/*
X * Function: NewBST
X * Usage: bst = NewBST(sizeof (nodeT), cmpFn, nodeInitFn);
X * -------------------------------------------------------
X * This function allocates and returns a new empty binary search
X * tree.  The first argument is the size of the client node.  The
X * second is a comparison function, which is called with the address
X * of the search key and the address of a node.  By storing the key
X * at the beginning of the structure, client's can use the standard
X * comparison functions from cmpfn.h.  The third argument is a
X * function that initializes the client's fields in the node, which
X * is described in more detail in the comments for InsertBSTNode.
X */
X
bstADT NewBST(int size, cmpFnT cmpFn, nodeInitFnT nodeInitFn);
X
/*
X * Function: FreeBST
X * Usage: FreeBST(bst, freeNodeFn);
X * --------------------------------
X * This function frees the storage for a tree, but calls the
X * client-supplied freeNodeFn to free each individual node.
X * The clientData value passed to the callback function is
X * always NULL.
X */
X
void FreeBST(bstADT bst, nodeFnT freeNodeFn);
X
/*
X * Function: FindBSTNode
X * Usage: np = FindBSTNode(bst, &key);
X * -----------------------------------
X * This function applies the binary search algorithm to find a
X * particular key in the tree represented by bst.  The second
X * argument represents the address of the key in the client
X * space rather than the key itself, which makes it possible to
X * use this package for keys that are not pointer types.  If a
X * node matching the key appears in the tree, FindBSTNode
X * returns a pointer to it; if not, FindBSTNode returns NULL.
X */
X
void *FindBSTNode(bstADT bst, void *kp);
X
/*
X * Function: InsertBSTNode
X * Usage: np = InsertBSTNode(bst, &key, clientData);
X * -------------------------------------------------
X * This function is used to insert a new node into a binary search
X * tree.  The bst and &key arguments are interpreted as they are
X * in FindBSTNode.  If the key already exists, the result is
X * simply the address of the old node.  If the key is not found,
X * InsertBSTNode allocates a new node and then calls the node
X * initialization function specified in the NewBST call to
X * initialize it.  The call has the following form:
X *
X *     nodeInitFn(np, kp, clientData);
X *
X * where np is a pointer to the node, kp is the pointer to the key,
X * and clientData is the value (typically NULL) supplied in the
X * InsertBSTNode call.  The initialization function must initialize
X * the key field in the node, but may perform other initialization
X * as well.
X */
X
void *InsertBSTNode(bstADT bst, void *kp, void *clientData);
X
/*
X * Function: DeleteBSTNode
X * Usage: np = DeleteBSTNode(bst, &key);
X * -------------------------------------
X * This function deletes a node in the tree that matches the
X * specified key pointer.  The arguments are interpreted as
X * in FindBSTNode.  The function returns the address of the
X * deleted node so that clients can free its storage.  If the
X * key is not found in the tree, DeleteBSTNode returns NULL.
X */
X
void *DeleteBSTNode(bstADT bst, void *kp);
X
/*
X * Function: MapBST
X * Usage: MapBST(fn, bst, order, clientData);
X * ------------------------------------------
X * This function calls fn on every node in the binary search tree,
X * passing it a pointer to a node and the clientData pointer.  The
X * type of traversal is given by the order argument, which must
X * be one of the constants InOrder, PreOrder, or PostOrder.
X */
X
typedef enum { InOrder, PreOrder, PostOrder } traversalOrderT;
X
void MapBST(nodeFnT fn, bstADT bst, traversalOrderT order,
X            void *clientData);
X
/*
X * Low-level functions: BSTRoot, BSTLeftChild, BSTRightChild
X * Usage: root = BSTRoot(bst);
X *        child = BSTLeftChild(bst, np);
X *        child = BSTRightChild(bst, np);
X * ---------------------------------------------------------
X * These functions allow the client to trace the structure of the
X * binary search tree and are useful primarily for debugging.
X */
X
void *BSTRoot(bstADT bst);
void *BSTLeftChild(bstADT bst, void *np);
void *BSTRightChild(bstADT bst, void *np);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/16-Graphs/bst.h' &&
  chmod 0644 'programs/16-Graphs/bst.h' ||
  echo 'restore of programs/16-Graphs/bst.h failed'
  shar_count="`wc -c < 'programs/16-Graphs/bst.h'`"
  test 4878 -eq "$shar_count" ||
    echo "programs/16-Graphs/bst.h: original size 4878, current size $shar_count"
fi
# ============= programs/16-Graphs/cmdscan.c ==============
if test -f 'programs/16-Graphs/cmdscan.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/16-Graphs/cmdscan.c (file already exists)'
else
  echo 'x - extracting programs/16-Graphs/cmdscan.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/16-Graphs/cmdscan.c' &&
/*
X * File: cmdscan.c
X * ---------------
X * This file implements the cmdscan.h interface.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "exception.h"
#include "strlib.h"
#include "simpio.h"
#include "symtab.h"
#include "scanadt.h"
#include "cmdscan.h"
X
/*
X * Type: cmdScannerCDT
X * -------------------
X * This type defines the concrete structure of the command scanner.
X */
X
struct cmdScannerCDT {
X    string line;
X    string cmdName;
X    symtabADT cmdTable;
X    scannerADT scanner;
X    void *data;
X    bool quit;
};
X
/*
X * Type: cmdEntryT
X * ---------------
X * This type defines the entry for an individual command.
X */
X
typedef struct {
X    string cmdName;
X    cmdFnT cmdFn;
} *cmdEntryT;
X
/* Exported entries */
X
cmdScannerADT NewCommandScanner(void)
{
X    cmdScannerADT cs;
X
X    cs = New(cmdScannerADT);
X    cs->cmdTable = NewSymbolTable();
X    cs->scanner = NewScanner();
X    SetScannerSpaceOption(cs->scanner, IgnoreSpaces);
X    cs->data = NULL;
X    cs->quit = FALSE;
X    return (cs);
}
X
void FreeCommandScanner(cmdScannerADT cs)
{
X    FreeSymbolTable(cs->cmdTable);
X    FreeScanner(cs->scanner);
X    FreeBlock(cs);
}
X
void DefineCommand(cmdScannerADT cs, string cmdName, cmdFnT cmdFn)
{
X    cmdEntryT entry;
X    int len;
X
X    entry = New(cmdEntryT);
X    entry->cmdName = CopyString(cmdName);
X    entry->cmdFn = cmdFn;
X    Enter(cs->cmdTable, cmdName, entry);
}
X
void SetCommandData(cmdScannerADT cs, void *data)
{
X    cs->data = data;
}
X
void *GetCommandData(cmdScannerADT cs)
{
X    return (cs->data);
}
X
string ReadCommandToken(cmdScannerADT cs)
{
X    return (ReadToken(cs->scanner));
}
X
string GetCommandLine(cmdScannerADT cs)
{
X    return (CopyString(cs->line));
}
X
string GetCommandName(cmdScannerADT cs)
{
X    return (CopyString(cs->cmdName));
}
X
scannerADT GetTokenScanner(cmdScannerADT cs)
{
X    return (cs->scanner);
}
X
void CommandLoop(cmdScannerADT cs, string prompt)
{
X    while (!cs->quit) {
X        printf("%s", prompt);
X        try {
X            if (!ExecuteCommand(cs, GetLine())) {
X                printf("Illegal command: %s\n", cs->line);
X            }
X          except(ErrorException)
X            printf("Error: %s\n", (string) GetExceptionValue());
X        } endtry
X    }
}
X
bool ExecuteCommand(cmdScannerADT cs, string line)
{
X    cmdEntryT entry;
X
X    cs->line = line;
X    SetScannerString(cs->scanner, line);
X    cs->cmdName = ReadToken(cs->scanner);
X    entry = Lookup(cs->cmdTable, cs->cmdName);
X    if (entry == UNDEFINED) return (FALSE);
X    entry->cmdFn(cs);
X    return (TRUE);
}
X
void QuitCmdFn(cmdScannerADT cs)
{
X    cs->quit = TRUE;
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/16-Graphs/cmdscan.c' &&
  chmod 0644 'programs/16-Graphs/cmdscan.c' ||
  echo 'restore of programs/16-Graphs/cmdscan.c failed'
  shar_count="`wc -c < 'programs/16-Graphs/cmdscan.c'`"
  test 2581 -eq "$shar_count" ||
    echo "programs/16-Graphs/cmdscan.c: original size 2581, current size $shar_count"
fi
# ============= programs/16-Graphs/cmdscan.h ==============
if test -f 'programs/16-Graphs/cmdscan.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/16-Graphs/cmdscan.h (file already exists)'
else
  echo 'x - extracting programs/16-Graphs/cmdscan.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/16-Graphs/cmdscan.h' &&
/*
X * File: cmdscan.h
X * ---------------
X * This interface provides a simple command-scanning interface
X * that is primarily used to construct test programs.  The
X * typical pattern of use requires the following steps:
X *
X * 1. Call NewCommandScanner to create an empty command scanner.
X * 2. Call DefineCommand to associate commands with functions.
X * 3. Call CommandLoop to execute a command loop.
X */
X
#ifndef _cmdscan_h
#define _cmdscan_h
X
#include "genlib.h"
#include "scanadt.h"
X
/*
X * Type: cmdScannerADT
X * -------------------
X * This abstract type represents the command scanner.
X */
X
typedef struct cmdScannerCDT *cmdScannerADT;
X
/*
X * Type: cmdFnT
X * ------------
X * This type represents the space of functions that can be used
X * as commands.  Each command takes the entire command scanner
X * as an argument, which gives the callback function access to
X * the various data fields associated with the scanner.
X */
X
typedef void (*cmdFnT)(cmdScannerADT cs);
X
/*
X * Functions: NewCommandScanner, FreeCommandScanner
X * Usage: cs = NewCommandScanner();
X *        FreeCommandScanner(cs);
X * ------------------------------------------------
X * These functions allocate and free command scanners.
X */
X
cmdScannerADT NewCommandScanner(void);
void FreeCommandScanner(cmdScannerADT cs);
X
/*
X * Function: DefineCommand
X * Usage: DefineCommand(cs, cmdName, cmdFn);
X * -----------------------------------------
X * This function adds an entry to the internal command table for
X * the command scanner that associates the command name with the
X * specified function.
X */
X
void DefineCommand(cmdScannerADT cs, string cmdName, cmdFnT cmdFn);
X
/*
X * Function: CommandLoop
X * Usage: CommandLoop(cs, prompt);
X * -------------------------------
X * This function executes a simple command loop that repeatedly
X *
X * 1. Prints the specified prompt
X * 2. Reads in a line from the user
X * 3. Checks to see if the first token on the line is a command
X * 4. Executes the function associated with that command
X *
X * If a command is undefined, CommandLoop displays a message
X * to that effect and allows the user to enter a new command.
X */
X
void CommandLoop(cmdScannerADT cs, string prompt);
X
/*
X * Function: ExecuteCommand
X * Usage: ok = ExecuteCommand(cs, line);
X * -------------------------------------
X * This function executes a command line as if it were entered
X * by the user.  The function returns TRUE if the command is
X * defined, and FALSE otherwise.
X */
X
bool ExecuteCommand(cmdScannerADT cs, string line);
X
/*
X * Functions: SetCommandData, GetCommandData
X * Usage: SetCommandData(cs, data);
X *        data = GetCommandData(cs);
X * ------------------------------------------
X * These functions make it possible for the client to associate
X * a data block with the command scanner, which makes it available
X * to the callback functions used for the individual commands.
X */
X
void SetCommandData(cmdScannerADT cs, void *data);
void *GetCommandData(cmdScannerADT cs);
X
/*
X * Function: ReadCommandToken(cs);
X * Usage: token = ReadCommandToken(cs);
X * ------------------------------------
X * This function returns the next token from the command line.  If
X * no more tokens exist, ReadCommandToken returns the empty string.
X */
X
string ReadCommandToken(cmdScannerADT cs);
X
/*
X * Functions: GetCommandLine, GetCommandName, GetTokenScanner
X * Usage: line = GetCommandLine(cs);
X *        name = GetCommandName(cs);
X *        scanner = GetTokenScanner(cs);
X * ----------------------------------------------------------
X * These functions return the current command line, the current
X * command name, and the token scanner used by the command
X * processor.  Providing these values to the client makes it
X * possible to perform more sophisticated command analysis than
X * is possible with ReadCommandToken alone.
X */
X
string GetCommandLine(cmdScannerADT cs);
string GetCommandName(cmdScannerADT cs);
scannerADT GetTokenScanner(cmdScannerADT cs);
X
/*
X * Function: QuitCmdFn
X * Usage: DefineCommand(cs, "quit", QuitCmdFn);
X * --------------------------------------------
X * This callback function is exported by the command scanner
X * interface so that clients can define a command that exits
X * from the command loop.
X */
X
void QuitCmdFn(cmdScannerADT cs);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/16-Graphs/cmdscan.h' &&
  chmod 0644 'programs/16-Graphs/cmdscan.h' ||
  echo 'restore of programs/16-Graphs/cmdscan.h failed'
  shar_count="`wc -c < 'programs/16-Graphs/cmdscan.h'`"
  test 4248 -eq "$shar_count" ||
    echo "programs/16-Graphs/cmdscan.h: original size 4248, current size $shar_count"
fi
# ============= programs/16-Graphs/cmpfn.c ==============
if test -f 'programs/16-Graphs/cmpfn.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/16-Graphs/cmpfn.c (file already exists)'
else
  echo 'x - extracting programs/16-Graphs/cmpfn.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/16-Graphs/cmpfn.c' &&
/*
X * File: cmpfn.c
X * -------------
X * This file implements the comparison functions exported by
X * the cmpfn.h interface.  The reason to centralize them in
X * a single module is to allow the same functions to be
X * shared among many different modules.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "strlib.h"
#include "cmpfn.h"
X
/* Exported entries */
X
int IntCmpFn(const void *p1, const void *p2)
{
X    int v1, v2;
X
X    v1 = *((int *) p1);
X    v2 = *((int *) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : +1);
}
X
int ShortCmpFn(const void *p1, const void *p2)
{
X    short v1, v2;
X
X    v1 = *((short *) p1);
X    v2 = *((short *) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : +1);
}
X
int LongCmpFn(const void *p1, const void *p2)
{
X    long v1, v2;
X
X    v1 = *((long *) p1);
X    v2 = *((long *) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : +1);
}
X
int CharCmpFn(const void *p1, const void *p2)
{
X    unsigned char v1, v2;
X
X    v1 = *((unsigned char *) p1);
X    v2 = *((unsigned char *) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : +1);
}
X
int FloatCmpFn(const void *p1, const void *p2)
{
X    float v1, v2;
X
X    v1 = *((float *) p1);
X    v2 = *((float *) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : +1);
}
X
int DoubleCmpFn(const void *p1, const void *p2)
{
X    double v1, v2;
X
X    v1 = *((double *) p1);
X    v2 = *((double *) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : +1);
}
X
int UnsignedCmpFn(const void *p1, const void *p2)
{
X    unsigned v1, v2;
X
X    v1 = *((unsigned *) p1);
X    v2 = *((unsigned *) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : +1);
}
X
int UnsignedShortCmpFn(const void *p1, const void *p2)
{
X    unsigned short v1, v2;
X
X    v1 = *((unsigned short *) p1);
X    v2 = *((unsigned short *) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : +1);
}
X
int UnsignedLongCmpFn(const void *p1, const void *p2)
{
X    unsigned long v1, v2;
X
X    v1 = *((unsigned long *) p1);
X    v2 = *((unsigned long *) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : +1);
}
X
int UnsignedCharCmpFn(const void *p1, const void *p2)
{
X    unsigned char v1, v2;
X
X    v1 = *((unsigned char *) p1);
X    v2 = *((unsigned char *) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : +1);
}
X
int StringCmpFn(const void *p1, const void *p2)
{
X    return (StringCompare(*((string *) p1), *((string *) p2)));
}
X
int PtrCmpFn(const void *p1, const void *p2)
{
X    void *v1, *v2;
X
X    v1 = *((void **) p1);
X    v2 = *((void **) p2);
X    if (v1 == v2) return (0);
X    return ((v1 < v2) ? -1 : +1);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/16-Graphs/cmpfn.c' &&
  chmod 0644 'programs/16-Graphs/cmpfn.c' ||
  echo 'restore of programs/16-Graphs/cmpfn.c failed'
  shar_count="`wc -c < 'programs/16-Graphs/cmpfn.c'`"
  test 2658 -eq "$shar_count" ||
    echo "programs/16-Graphs/cmpfn.c: original size 2658, current size $shar_count"
fi
# ============= programs/16-Graphs/cmpfn.h ==============
if test -f 'programs/16-Graphs/cmpfn.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/16-Graphs/cmpfn.h (file already exists)'
else
  echo 'x - extracting programs/16-Graphs/cmpfn.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/16-Graphs/cmpfn.h' &&
/*
X * File: cmpfn.h
X * -------------
X * This interface exports several comparison functions for use
X * with ANSI library functions like qsort and bsearch as well
X * as various functions in the extended library.
X */
X
#ifndef _cmpfn_h
#define _cmpfn_h
X
/*
X * Type: cmpFnT
X * ------------
X * This type defines the type space of comparison functions,
X * each of which take the addresses of their arguments and
X * return an integer from the set {-1, 0, +1} depending on
X * whether the first argument is less than, equal to, or
X * greater than the second.
X */
X
typedef int (*cmpFnT)(const void *p1, const void *p2);
X
/*
X * Standard comparison functions
X * -----------------------------
X * The remainder of this interface exports standard comparison
X * functions for the most common built-in types.
X */
X
int IntCmpFn(const void *p1, const void *p2);
int ShortCmpFn(const void *p1, const void *p2);
int LongCmpFn(const void *p1, const void *p2);
int CharCmpFn(const void *p1, const void *p2);
int FloatCmpFn(const void *p1, const void *p2);
int DoubleCmpFn(const void *p1, const void *p2);
int UnsignedCmpFn(const void *p1, const void *p2);
int UnsignedShortCmpFn(const void *p1, const void *p2);
int UnsignedLongCmpFn(const void *p1, const void *p2);
int UnsignedCharCmpFn(const void *p1, const void *p2);
int StringCmpFn(const void *p1, const void *p2);
int PtrCmpFn(const void *p1, const void *p2);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/16-Graphs/cmpfn.h' &&
  chmod 0644 'programs/16-Graphs/cmpfn.h' ||
  echo 'restore of programs/16-Graphs/cmpfn.h failed'
  shar_count="`wc -c < 'programs/16-Graphs/cmpfn.h'`"
  test 1402 -eq "$shar_count" ||
    echo "programs/16-Graphs/cmpfn.h: original size 1402, current size $shar_count"
fi
# ============= programs/16-Graphs/foreach.c ==============
if test -f 'programs/16-Graphs/foreach.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/16-Graphs/foreach.c (file already exists)'
else
  echo 'x - extracting programs/16-Graphs/foreach.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/16-Graphs/foreach.c' &&
/*
X * File: foreach.c
X * ---------------
X * This interface implements the foreach construct.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "iterator.h"
#include "foreach.h"
X
typedef struct cellT {
X    void *ep;
X    iteratorADT iterator;
X    struct cellT *link;
} cellT;
X
static cellT *iteratorList = NULL;
X
/* Entry points */
X
void InitForEach(void *ep, void *collection)
{
X    cellT *cp;
X
X    for (cp = iteratorList; cp != NULL && cp->ep != ep; cp = cp->link) {
X        /* no action */
X    }
X    if (cp == NULL) {
X        cp = New(cellT *);
X        cp->ep = ep;
X        cp->link = iteratorList;
X        iteratorList = cp;
X    } else {
X        if (cp->iterator != NULL) FreeIterator(cp->iterator);
X    }
X    cp->iterator = NewIterator(collection);
}
X
bool StepForEach(void *ep)
{
X    cellT *cp;
X    bool result;
X
X    for (cp = iteratorList; cp != NULL && cp->ep != ep; cp = cp->link) {
X        /* no action */
X    }
X    if (cp == NULL) Error("foreach iterator undefined");
X    result = StepIterator(cp->iterator, ep);
X    if (!result) {
X        FreeIterator(cp->iterator);
X        cp->iterator = NULL;
X    }
X    return (result);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/16-Graphs/foreach.c' &&
  chmod 0644 'programs/16-Graphs/foreach.c' ||
  echo 'restore of programs/16-Graphs/foreach.c failed'
  shar_count="`wc -c < 'programs/16-Graphs/foreach.c'`"
  test 1138 -eq "$shar_count" ||
    echo "programs/16-Graphs/foreach.c: original size 1138, current size $shar_count"
fi
# ============= programs/16-Graphs/foreach.h ==============
if test -f 'programs/16-Graphs/foreach.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/16-Graphs/foreach.h (file already exists)'
else
  echo 'x - extracting programs/16-Graphs/foreach.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/16-Graphs/foreach.h' &&
/*
X * File: foreach.h
X * ---------------
X * This interface provides a simple syntactic extension for
X * iterators that makes them easier to read.
X */
X
#ifndef _foreach_h
#define _foreach_h
X
#include "genlib.h"
X
/*
X * Statement form: foreach
X * Usage: foreach (element in collection) {
X *            . . . code involving element . . .
X *        }
X * ---------------------------------------------
X * This macro definition creates a new statement form that
X * simplifies the use of iterators.  The variable element
X * must be declared in the current scope and must be
X * compatible with the base type of the collection.  The
X * functions InitForEach and StepForEach are not called
X * directly by the client.
X */
X
#define in ,
#define foreach(arg) _foreach(arg)
#define _foreach(e, c) for (InitForEach(&e, c); StepForEach(&e); )
X
void InitForEach(void *ep, void *collection);
bool StepForEach(void *ep);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/16-Graphs/foreach.h' &&
  chmod 0644 'programs/16-Graphs/foreach.h' ||
  echo 'restore of programs/16-Graphs/foreach.h failed'
  shar_count="`wc -c < 'programs/16-Graphs/foreach.h'`"
  test 908 -eq "$shar_count" ||
    echo "programs/16-Graphs/foreach.h: original size 908, current size $shar_count"
fi
# ============= programs/16-Graphs/graph.c ==============
if test -f 'programs/16-Graphs/graph.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/16-Graphs/graph.c (file already exists)'
else
  echo 'x - extracting programs/16-Graphs/graph.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/16-Graphs/graph.c' &&
/*
X * File: graph.c
X * -------------
X * This file implements the graph.h interface using sets to
X * represent the nodes and arcs.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "set.h"
#include "graph.h"
#include "foreach.h"
X
/*
X * Type: graphCDT
X * --------------
X * This definition provides the concrete type for a graphADT,
X * which is implemented as a set of nodes and a set of arcs.
X */
X
struct graphCDT {
X    setADT nodes, arcs;
X    void *data;
};
X
/*
X * Type: nodeCDT
X * -------------
X * This type defines the concrete structure of a node, which
X * consists of the graph pointer, a flag indicating whether
X * the node has been visited, and a client data field.
X */
X
struct nodeCDT {
X    graphADT graph;
X    bool visited;
X    void *data;
};
X
/*
X * Type: arcCDT
X * ------------
X * The concrete type for an arc consists of its endpoints, plus
X * a data field for the client.
X */
X
struct arcCDT {
X    nodeADT from, to;
X    void *data;
};
X
/* Exported entries */
X
graphADT NewGraph(void)
{
X    graphADT graph;
X
X    graph = New(graphADT);
X    graph->nodes = NewPtrSet(PtrCmpFn);
X    graph->arcs = NewPtrSet(PtrCmpFn);
X    graph->data = NULL;
X    return (graph);
}
X
void FreeGraph(graphADT graph)
{
X    nodeADT node;
X    arcADT arc;
X
X    foreach (node in graph->nodes) {
X        FreeBlock(node);
X    }
X    foreach (arc in graph->arcs) {
X        FreeBlock(arc);
X    }
X    FreeSet(graph->nodes);
X    FreeSet(graph->arcs);
X    FreeBlock(graph);
}
X
nodeADT NewNode(graphADT graph)
{
X    nodeADT node;
X
X    node = New(nodeADT);
X    node->graph = graph;
X    node->visited = FALSE;
X    node->data = NULL;
X    AddPtrElement(graph->nodes, node);
X    return (node);
}
X
arcADT NewArc(nodeADT n1, nodeADT n2)
{
X    arcADT arc;
X
X    if (n1->graph != n2->graph) {
X        Error("Connect: Nodes are in different graphs");
X    }
X    arc = New(arcADT);
X    arc->from = n1;
X    arc->to = n2;
X    arc->data = NULL;
X    AddPtrElement(n1->graph->arcs, arc);
X    return (arc);
}
X
void Connect(nodeADT n1, nodeADT n2)
{
X    (void) NewArc(n1, n2);
}
X
bool IsConnected(nodeADT n1, nodeADT n2)
{
X    arcADT arc;
X
X    if (n1->graph != n2->graph) {
X        Error("IsConnected: Nodes are in different graphs");
X    }
X    foreach (arc in n1->graph->arcs) {
X        if (arc->from == n1 && arc->to == n2) return (TRUE);
X    }
X    return (FALSE);
}
X
setADT Nodes(graphADT graph)
{
X    return (graph->nodes);
}
X
setADT ConnectedNodes(nodeADT node)
{
X    setADT result;
X    arcADT arc;
X
X    result = NewPtrSet(PtrCmpFn);
X    foreach (arc in node->graph->arcs) {
X        if (arc->from == node) AddPtrElement(result, arc->to);
X    }
X    return (result);
}
X
setADT Arcs(graphADT graph)
{
X    return (graph->arcs);
}
X
setADT ArcsFrom(nodeADT node)
{
X    setADT result;
X    arcADT arc;
X
X    result = NewPtrSet(PtrCmpFn);
X    foreach (arc in node->graph->arcs) {
X        if (arc->from == node) AddPtrElement(result, arc);
X    }
X    return (result);
}
X
setADT ArcsTo(nodeADT node)
{
X    setADT result;
X    arcADT arc;
X
X    result = NewPtrSet(PtrCmpFn);
X    foreach (arc in node->graph->arcs) {
X        if (arc->to == node) AddPtrElement(result, arc);
X    }
X    return (result);
}
X
nodeADT StartOfArc(arcADT arc)
{
X    return (arc->from);
}
X
nodeADT EndOfArc(arcADT arc)
{
X    return (arc->to);
}
X
graphADT GetGraph(nodeADT node)
{
X    return (node->graph);
}
X
void SetVisitedFlag(nodeADT node)
{
X    node->visited = TRUE;
}
X
void ClearVisitedFlag(nodeADT node)
{
X    node->visited = FALSE;
}
X
bool HasBeenVisited(nodeADT node)
{
X    return (node->visited);
}
X
void SetGraphData(graphADT graph, void *data)
{
X    graph->data = data;
}
X
void *GetGraphData(graphADT graph)
{
X    return (graph->data);
}
X
void SetNodeData(nodeADT node, void *data)
{
X    node->data = data;
}
X
void *GetNodeData(nodeADT node)
{
X    return (node->data);
}
X
void SetArcData(arcADT arc, void *data)
{
X    arc->data = data;
}
X
void *GetArcData(arcADT arc)
{
X    return (arc->data);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/16-Graphs/graph.c' &&
  chmod 0644 'programs/16-Graphs/graph.c' ||
  echo 'restore of programs/16-Graphs/graph.c failed'
  shar_count="`wc -c < 'programs/16-Graphs/graph.c'`"
  test 3922 -eq "$shar_count" ||
    echo "programs/16-Graphs/graph.c: original size 3922, current size $shar_count"
fi
# ============= programs/16-Graphs/graph.h ==============
if test -f 'programs/16-Graphs/graph.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/16-Graphs/graph.h (file already exists)'
else
  echo 'x - extracting programs/16-Graphs/graph.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/16-Graphs/graph.h' &&
/*
X * File: graph.h
X * -------------
X * This interface allows the client to manipulate graphs, which
X * are defined in keeping with their mathematical formulation
X * as a set of nodes connected by a set of arcs.
X */
X
#ifndef _graph_h
#define _graph_h
X
#include "genlib.h"
#include "set.h"
X
/*
X * Types: graphADT, nodeADT, arcADT
X * --------------------------------
X * These abstract types are used to represent graphs, nodes, and
X * arcs, respectively.
X */
X
typedef struct graphCDT *graphADT;
typedef struct nodeCDT *nodeADT;
typedef struct arcCDT *arcADT;
X
/*
X * Function: NewGraph
X * Usage: graph = NewGraph();
X * --------------------------
X * This function returns a new graph with no nodes.
X */
X
graphADT NewGraph(void);
X
/*
X * Function: FreeGraph
X * Usage: FreeGraph(graph);
X * ------------------------
X * This function frees the storage for the graph, along with
X * its nodes and arcs.
X */
X
void FreeGraph(graphADT graph);
X
/*
X * Function: NewNode
X * Usage: node = NewNode(graph);
X * -----------------------------
X * This function creates a new node and adds it to the graph.
X */
X
nodeADT NewNode(graphADT graph);
X
/*
X * Function: NewArc
X * Usage: arc = NewArc(n1, n2);
X * ----------------------------
X * This function creates a connection from node n1 to n2
X * and returns a new arcADT representing that connection.
X */
X
arcADT NewArc(nodeADT n1, nodeADT n2);
X
/*
X * Function: Connect
X * Usage: Connect(n1, n2);
X * -----------------------
X * This function creates a new arc from node n1 to n2, but
X * does not actually return the arcADT.
X */
X
void Connect(nodeADT n1, nodeADT n2);
X
/*
X * Function: IsConnected
X * Usage: if (IsConnected(n1, n2)) . . .
X * -------------------------------------
X * This function returns TRUE if there is an arc from n1 to n2.
X */
X
bool IsConnected(nodeADT n1, nodeADT n2);
X
/*
X * Functions: Nodes, ConnectedNodes
X * Usage: nodeSet = Nodes(graph);
X *        nodeSet = ConnectedNodes(node);
X * --------------------------------------
X * These functions return a set consisting of all nodes in
X * the graph and a set of the nodes to which a given node
X * is connected, respectively.  These functions are typically
X * used to initialize an iterator.  For example, the following
X * idiom iterates over the nodes connected to start:
X *
X *     foreach (node in ConnectedNodes(start))
X */
X
setADT Nodes(graphADT graph);
setADT ConnectedNodes(nodeADT node);
X
/*
X * Functions: Arcs, ArcsFrom, ArcsTo
X * Usage: arcSet = Arcs(graph);
X *        arcSet = ArcsFrom(node);
X *        arcSet = ArcsTo(node);
X * ---------------------------------
X * Each of these functions returns a set of arcs.   The Arcs
X * function returns all the arcs in the graph; the ArcsFrom
X * and ArcsTo functions return the set of arcs that begin or
X * end at a given node, respectively.  These functions are
X * typically used in conjunction with an iterator, as in the
X * following foreach idiom:
X *
X *     foreach (arc in Arcs(graph)) . . .
X */
X
setADT Arcs(graphADT graph);
setADT ArcsFrom(nodeADT node);
setADT ArcsTo(nodeADT node);
X
/*
X * Functions: StartOfArc, EndOfArc
X * Usage: node = StartOfArc(arc);
X *        node = EndOfArc(arc);
X * -------------------------------
X * These functions return the nodes at the endpoints of the
X * specified arc.
X */
X
nodeADT StartOfArc(arcADT arc);
nodeADT EndOfArc(arcADT arc);
X
/*
X * Function: GetGraph
X * Usage: graph = GetGraph(node);
X * ------------------------------
X * This function returns the graph of which a node is a part.
X */
X
graphADT GetGraph(nodeADT node);
X
/*
X * Functions: SetVisitedFlag, ClearVisitedFlag, HasBeenVisited
X * Usage: SetVisitedFlag(node);
X *        ClearVisitedFlag(node);
X *        if (HasBeenVisitedFlag(node)) . . .
X * -----------------------------------------------------------
X * These functions allow clients to manipulate the state of an
X * internal flag associated with each node.  That flag is used
X * to indicate whether the node has been visited as part of a
X * traversal operation.
X */
X
void SetVisitedFlag(nodeADT node);
void ClearVisitedFlag(nodeADT node);
bool HasBeenVisited(nodeADT node);
X
/*
X * Functions: SetGraphData, SetNodeData, SetArcData
X *            GetGraphData, GetNodeData, GetArcData
X * Usage: SetGraphData(graph, data);
X *        data = GetGraphData(graph);
X * ------------------------------------------------
X * These functions make it possible for the client to associate
X * data blocks with graphs, nodes, and arcs.
X */
X
void SetGraphData(graphADT graph, void *data);
void *GetGraphData(graphADT graph);
void SetNodeData(nodeADT node, void *data);
void *GetNodeData(nodeADT node);
void SetArcData(arcADT arc, void *data);
void *GetArcData(arcADT arc);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/16-Graphs/graph.h' &&
  chmod 0644 'programs/16-Graphs/graph.h' ||
  echo 'restore of programs/16-Graphs/graph.h failed'
  shar_count="`wc -c < 'programs/16-Graphs/graph.h'`"
  test 4665 -eq "$shar_count" ||
    echo "programs/16-Graphs/graph.h: original size 4665, current size $shar_count"
fi
# ============= programs/16-Graphs/gtest.c ==============
if test -f 'programs/16-Graphs/gtest.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/16-Graphs/gtest.c (file already exists)'
else
  echo 'x - extracting programs/16-Graphs/gtest.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/16-Graphs/gtest.c' &&
/*
X * File: gtest.c
X * -------------
X * This program tests the graph abstraction.  The user types in
X * command lines, which must to be in one of the following forms:
X *
X *   node name        Create a new node
X *   connect n1 n2    Add an arc between n1 and n2
X *   list             List the contents of the graph
X *   dfs start        Perform a depth-first search from start
X *   bfs start        Perform a breadth-first search from start
X *   source "file"    Read commands from a file
X *   help             Generate a list of commands
X *   quit             Exit from the program
X */
X
#include <stdio.h>
#include <ctype.h>
#include "genlib.h"
#include "strlib.h"
#include "simpio.h"
#include "symtab.h"
#include "iterator.h"
#include "foreach.h"
#include "scanadt.h"
#include "set.h"
#include "cmpfn.h"
#include "graph.h"
#include "cmdscan.h"
X
/* Private function prototypes */
X
static void InitCommandTable(cmdScannerADT cs);
static void NodeCmdFn(cmdScannerADT cs);
static void ConnectCmdFn(cmdScannerADT cs);
static void ListCmdFn(cmdScannerADT cs);
static void DFSCmdFn(cmdScannerADT cs);
static void BFSCmdFn(cmdScannerADT cs);
static void SourceCmdFn(cmdScannerADT cs);
static void HelpCmdFn(cmdScannerADT cs);
static void DepthFirstSearch(nodeADT start);
static void BreadthFirstSearch(nodeADT start);
static nodeADT ReadNamedNode(cmdScannerADT cs);
static void UnmarkAllNodes(graphADT graph);
static void Visit(nodeADT node);
X
/* Main program */
X
main()
{
X    cmdScannerADT cs;
X    scannerADT scanner;
X    graphADT graph;
X
X    printf("Graph test program\n");
X    cs = NewCommandScanner();
X    scanner = GetTokenScanner(cs);
X    SetScannerStringOption(scanner, ScanQuotesAsStrings);
X    graph = NewGraph();
X    SetGraphData(graph, NewSymbolTable());
X    SetCommandData(cs, graph);
X    InitCommandTable(cs);
X    CommandLoop(cs, "G> ");
X    FreeCommandScanner(cs);
}
X
static void InitCommandTable(cmdScannerADT cs)
{
X    DefineCommand(cs, "node",    NodeCmdFn);
X    DefineCommand(cs, "connect", ConnectCmdFn);
X    DefineCommand(cs, "list",    ListCmdFn);
X    DefineCommand(cs, "dfs",     DFSCmdFn);
X    DefineCommand(cs, "bfs",     BFSCmdFn);
X    DefineCommand(cs, "source",  SourceCmdFn);
X    DefineCommand(cs, "help",    HelpCmdFn);
X    DefineCommand(cs, "quit",    QuitCmdFn);
}
X
static void NodeCmdFn(cmdScannerADT cs)
{
X    scannerADT scanner;
X    symtabADT nodeTable;
X    graphADT graph;
X    nodeADT node;
X    string label;
X
X    scanner = GetTokenScanner(cs);
X    graph = GetCommandData(cs);
X    nodeTable = GetGraphData(graph);
X    label = ReadToken(scanner);
X    if (Lookup(nodeTable, label) != UNDEFINED) {
X        printf("That node already exists\n");
X    } else {
X        node = NewNode(graph);
X        SetNodeData(node, label);
X        Enter(nodeTable, label, node);
X    }
}
X
static void ConnectCmdFn(cmdScannerADT cs)
{
X    nodeADT n1, n2;
X
X    n1 = ReadNamedNode(cs);
X    n2 = ReadNamedNode(cs);
X    Connect(n1, n2);
}
X
static void ListCmdFn(cmdScannerADT cs)
{
X    scannerADT scanner;
X    symtabADT nodeTable;
X    graphADT graph;
X    nodeADT node, target;
X
X    graph = GetCommandData(cs);
X    foreach (node in Nodes(graph)) {
X        printf("%s:", (string) GetNodeData(node));
X        foreach (target in ConnectedNodes(node)) {
X            printf(" %s", (string) GetNodeData(target));
X        }
X        printf("\n");
X    }
}
X
static void DFSCmdFn(cmdScannerADT cs)
{
X    UnmarkAllNodes((graphADT) GetCommandData(cs));
X    DepthFirstSearch(ReadNamedNode(cs));
X    printf("\n");
}
X
static void BFSCmdFn(cmdScannerADT cs)
{
X    UnmarkAllNodes((graphADT) GetCommandData(cs));
X    BreadthFirstSearch(ReadNamedNode(cs));
X    printf("\n");
}
X
static void SourceCmdFn(cmdScannerADT cs)
{
X    scannerADT scanner;
X    string token, filename, line;
X    int len;
X    FILE *infile;
X
X    scanner = GetTokenScanner(cs);
X    token = ReadToken(scanner);
X    len = StringLength(token);
X    if (token[0] != '"' || token[len - 1] != '"') {
X        Error("Source: filename is not enclosed in quotes");
X    }
X    filename = SubString(token, 1, len - 2);
X    infile = fopen(filename, "r");
X    if (infile == NULL) Error("Source: cannot open file");
X    while ((line = ReadLine(infile)) != NULL) {
X        printf("-> %s\n", line);
X        if (!ExecuteCommand(cs, line)) {
X            Error("Source: Illegal command (%s)", line);
X        }
X    }
X    fclose(infile);
}
X
static void HelpCmdFn(cmdScannerADT cs)
{
X    printf("Legal commands:\n");
X    printf("  node name        Create a new node\n");
X    printf("  connect n1 n2    Add an arc between n1 and n2\n");
X    printf("  list             List the contents of the graph\n");
X    printf("  dfs start        Perform a depth-first search\n");
X    printf("  bfs start        Perform a breadth-first search\n");
X    printf("  source \"file\"    Read commands from a file\n");
X    printf("  help             Generate a list of commands\n");
X    printf("  quit             Exit from the program\n");
}
X
/*
X * Function: DepthFirstSearch
X * Usage: DepthFirstSearch(start);
X * -------------------------------
X * This function visits each node in the graph containing start,
X * using a depth-first traversal beginning at the start node.
X */
X
static void DepthFirstSearch(nodeADT start)
{
X    nodeADT node;
X
X    if (HasBeenVisited(start)) return;
X    Visit(start);
X    foreach (node in ConnectedNodes(start)) {
X        DepthFirstSearch(node);
X    }
}
X
/*
X * Function: BreadthFirstSearch
X * Usage: BreadthFirstSearch(start);
X * -------------------------------
X * This function visits each node in the graph containing start,
X * using a breadth-first traversal beginning at the start node.
X */
X
static void BreadthFirstSearch(nodeADT start)
{
X    setADT frontier, oldFrontier;
X    nodeADT node, target;
X
X    frontier = NewPtrSet(PtrCmpFn);
X    AddPtrElement(frontier, start);
X    while (NElements(frontier) > 0) {
X        oldFrontier = frontier;
X        frontier = NewPtrSet(PtrCmpFn);
X        foreach (node in oldFrontier) {
X            if (!HasBeenVisited(node)) {
X                Visit(node);
X                foreach (target in ConnectedNodes(node)) {
X                    AddPtrElement(frontier, target);
X                }
X            }
X        }
X    }
}
X
/* Utility functions */
X
/*
X * Function: ReadNamedNode
X * Usage: node = ReadNamedNode(cs);
X * --------------------------------
X * This function reads the next token from the command scanner
X * and interprets it as the name of a node.
X */
X
static nodeADT ReadNamedNode(cmdScannerADT cs)
{
X    scannerADT scanner;
X    symtabADT nodeTable;
X    graphADT graph;
X    nodeADT node;
X    string label;
X
X    scanner = GetTokenScanner(cs);
X    label = ReadToken(scanner);
X    if (StringLength(label) == 0) {
X        Error("%s: Node name is missing", GetCommandName(cs));
X    }
X    graph = GetCommandData(cs);
X    nodeTable = GetGraphData(graph);
X    node = Lookup(nodeTable, label);
X    if (node == NULL) {
X        Error("%s: No node named %s", GetCommandName(cs), label);
X    }
X    return (node);
}
X
static void UnmarkAllNodes(graphADT graph)
{
X    nodeADT node;
X
X    foreach (node in Nodes(graph)) {
X        ClearVisitedFlag(node);
X    }
}
X
static void Visit(nodeADT node)
{
X    printf(" %s", (string) GetNodeData(node));
X    SetVisitedFlag(node);
}
SHAR_EOF
  $shar_touch -am 0906095297 'programs/16-Graphs/gtest.c' &&
  chmod 0664 'programs/16-Graphs/gtest.c' ||
  echo 'restore of programs/16-Graphs/gtest.c failed'
  shar_count="`wc -c < 'programs/16-Graphs/gtest.c'`"
  test 7238 -eq "$shar_count" ||
    echo "programs/16-Graphs/gtest.c: original size 7238, current size $shar_count"
fi
# ============= programs/16-Graphs/iterator.c ==============
if test -f 'programs/16-Graphs/iterator.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/16-Graphs/iterator.c (file already exists)'
else
  echo 'x - extracting programs/16-Graphs/iterator.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/16-Graphs/iterator.c' &&
/*
X * File: iterator.c
X * ----------------
X * This file implements a polymorphic version of the iterator
X * and the tools necessary to construct types that support
X * iteration.  This module implements both the iterator.h and
X * itertype.h interfaces.
X */
X
#include <stdio.h>
#include <string.h>
#include "genlib.h"
#include "cmpfn.h"
#include "iterator.h"
#include "itertype.h"
X
/*
X * Constant: IteratorPassword
X * --------------------------
X * This constant is stored in the header block of collection
X * types to catch the case when a client tries to call
X * NewIterator on a value for which iteration is not defined.
X */
X
#define IteratorPassword 3141592653UL
X
/*
X * Type: cellT, iteratorCDT
X * ------------------------
X * The iterator is implemented as a linked list chained
X * through the first word in the structure.  Because the size
X * of the actual data element can vary, the data field is not
X * represented as part of the structure.  Instead, each cell is
X * allocated dynamically with enough memory for both the link
X * field and the data value, however large it turns out to be.
X * The list is arranged like a queue, with a tail pointer to
X * its final element for efficiency.  The AddToIteratorList
X * function first checks to see whether the element belongs at
X * the end.  By checking for this case explicitly, it is often
X * possible to avoid searching the list at all.
X */
X
typedef struct cellT {
X    struct cellT *link;
X    /* The actual data is allocated here */
} cellT;
X
struct iteratorCDT {
X    int elementSize;
X    cmpFnT cmpFn;
X    cellT *head, *tail;
};
X
/* Part 1 -- Implementation of iterator.h */
X
iteratorADT NewIterator(void *collection)
{
X    iteratorHeaderT *hp = collection;
X
X    if (hp->password != IteratorPassword) {
X        Error("Iteration is not defined for this type");
X    }
X    return (hp->newFn(collection));
}
X
bool StepIterator(iteratorADT iterator, void *ep)
{
X    cellT *cp;
X    void *dp;
X
X    cp = iterator->head;
X    if (cp == NULL) {
X        iterator->tail = NULL;
X        return (FALSE);
X    }
X    dp = ((char *) cp) + sizeof (cellT);
X    memcpy(ep, dp, iterator->elementSize);
X    iterator->head = cp->link;
X    FreeBlock(cp);
X    return (TRUE);
}
X
void FreeIterator(iteratorADT iterator)
{
X    cellT *cp;
X
X    while ((cp = iterator->head) != NULL) {
X        iterator->head = cp->link;
X        FreeBlock(cp);
X    }
X    FreeBlock(iterator);
}
X
/* Part 2 -- Implementation of itertype.h */
X
void EnableIteration(void *collection, newIteratorFnT newFn)
{
X    iteratorHeaderT *hp = collection;
X
X    hp->password = IteratorPassword;
X    hp->newFn = newFn;
}
X
iteratorADT NewIteratorList(int size, cmpFnT cmpFn)
{
X    iteratorADT iterator;
X
X    iterator = New(iteratorADT);
X    iterator->elementSize = size;
X    iterator->cmpFn = cmpFn;
X    iterator->head = iterator->tail = NULL;
X    return (iterator);
}
X
/*
X * Implementation notes: AddToIteratorList
X * ---------------------------------------
X * Most of the work of the package occurs in this function, which
X * inserts the element addressed by ep into its correct position.
X * If the list is unordered or if the element belongs at the end,
X * the element is immediately inserted at the tail.  If not, the
X * implementation walks the list to find the correct position.
X * The local pointers have the following interpretations:
X *
X * np -- pointer to the newly allocated cell
X * pp -- pointer to the cell preceding the insertion point
X * ip -- pointer used as an index in the for loop
X * dp -- pointer to the data field in the block
X */
X
void AddToIteratorList(iteratorADT iterator, void *ep)
{
X    cellT *np, *pp, *ip;
X    void *dp;
X
X    np = GetBlock(sizeof (cellT) + iterator->elementSize);
X    dp = ((char *) np) + sizeof (cellT);
X    memcpy(dp, ep, iterator->elementSize);
X    pp = NULL;
X    if (iterator->tail != NULL) {
X        if (iterator->cmpFn == UnsortedFn) {
X            pp = iterator->tail;
X        } else {
X            dp = ((char *) iterator->tail) + sizeof (cellT);
X            if (iterator->cmpFn(ep, dp) >= 0) pp = iterator->tail;
X        }
X    }
X    if (pp == NULL) {
X        for (ip = iterator->head; ip != NULL; ip = ip->link) {
X            dp = ((char *) ip) + sizeof (cellT);
X            if (iterator->cmpFn(ep, dp) < 0) break;
X            pp = ip;
X        }
X    }
X    if (pp == NULL) {
X        np->link = iterator->head;
X        if (iterator->head == NULL) iterator->tail = np;
X        iterator->head = np;
X    } else {
X        np->link = pp->link;
X        if (pp->link == NULL) iterator->tail = np;
X        pp->link = np;
X    }
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/16-Graphs/iterator.c' &&
  chmod 0644 'programs/16-Graphs/iterator.c' ||
  echo 'restore of programs/16-Graphs/iterator.c failed'
  shar_count="`wc -c < 'programs/16-Graphs/iterator.c'`"
  test 4556 -eq "$shar_count" ||
    echo "programs/16-Graphs/iterator.c: original size 4556, current size $shar_count"
fi
# ============= programs/16-Graphs/iterator.h ==============
if test -f 'programs/16-Graphs/iterator.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/16-Graphs/iterator.h (file already exists)'
else
  echo 'x - extracting programs/16-Graphs/iterator.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/16-Graphs/iterator.h' &&
/*
X * File: iterator.h
X * ----------------
X * Many abstract data types -- including those for such common
X * structures as sets and symbol tables -- represent collections
X * of values.  In many cases, clients need to perform some
X * operation on each of the values in that collection.  This
X * file provides a polymorphic interface for iterators, which
X * provide that capability in a very general way.
X */
X
#ifndef _iterator_h
#define _iterator_h
X
#include "genlib.h"
X
/*
X * Type: iteratorADT
X * -----------------
X * This abstract type is used to iterate over the elements
X * of any collection.
X */
X
typedef struct iteratorCDT *iteratorADT;
X
/* Exported entries */
X
/*
X * Functions: NewIterator, StepIterator, FreeIterator
X * Usage: iterator = NewIterator(collection);
X *        while (StepIterator(iterator, &element)) {
X *            . . . body of loop involving element . . .
X *        }
X *        FreeIterator(iterator);
X * -----------------------------------------------------
X * These functions make it possible to iterate over the
X * elements in any collection that supports iteration.  Each
X * call to StepIterator advances the iterator and returns the
X * next element using the reference parameter.  StepIterator
X * returns TRUE until the keys are exhausted, after which it
X * returns FALSE.  The FreeIterator function releases any
X * storage associated with the iterator.
X */
X
iteratorADT NewIterator(void *collection);
bool StepIterator(iteratorADT iterator, void *ep);
void FreeIterator(iteratorADT iterator);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/16-Graphs/iterator.h' &&
  chmod 0644 'programs/16-Graphs/iterator.h' ||
  echo 'restore of programs/16-Graphs/iterator.h failed'
  shar_count="`wc -c < 'programs/16-Graphs/iterator.h'`"
  test 1531 -eq "$shar_count" ||
    echo "programs/16-Graphs/iterator.h: original size 1531, current size $shar_count"
fi
# ============= programs/16-Graphs/itertype.h ==============
if test -f 'programs/16-Graphs/itertype.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/16-Graphs/itertype.h (file already exists)'
else
  echo 'x - extracting programs/16-Graphs/itertype.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/16-Graphs/itertype.h' &&
/*
X * File: itertype.h
X * ----------------
X * This file provides an interface that package designers can
X * use to export new collection types that support iteration.
X * Clients of those collection types who merely want to use
X * iterators will not need to import this interface.
X */
X
#ifndef _itertype_h
#define _itertype_h
X
#include "genlib.h"
#include "iterator.h"
#include "cmpfn.h"
X
/*
X * General overview
X * ----------------
X * In order to create a collection type that supports iteration,
X * the implementor of the type must first allocate space at the
X * beginning of the concrete record for an iteratorHeaderT that
X * contains a function pointer which allows NewIterator to make
X * a new iterator for that collection type.  The implementor
X * must initialize this header in the constructor function by
X * calling EnableIteration.  The specific NewIterator functions
X * for each type must perform the following operations:
X *
X * 1. Call NewIteratorList to create an empty iterator.
X * 2. Call AddToIteratorList for each element.
X * 3. Return the completed iterator.
X *
X * Elements in the iterator may be sorted or unsorted depending
X * on the comparison function passed to NewIteratorList.
X */
X
/*
X * Type: newIteratorFnT
X * --------------------
X * This type represents the class of functions that create new
X * iterators.
X */
X
typedef iteratorADT (*newIteratorFnT)(void *collection);
X
/*
X * Constant function: UnsortedFn
X * -----------------------------
X * This constant creates a NULL function pointer that can be
X * used in place of the comparison function to indicate that the
X * values in the iterator should not be sorted.  The constant 0
X * is used in place of NULL because some compilers do not allow
X * casting NULL to a function pointer.
X */
X
#define UnsortedFn ((cmpFnT) 0)
X
/*
X * Type: iteratorHeaderT
X * ---------------------
X * This structure must appear at the beginning of any concrete
X * structure that supports iteration.
X */
X
typedef struct {
X    unsigned long password;
X    newIteratorFnT newFn;
} iteratorHeaderT;
X
/*
X * Functions: EnableIteration
X * Usage: EnableIteration(collection, newFn);
X * ------------------------------------------
X * This function enables iteration for the collection.  The
X * function pointer newFn is used to initialize an iterator
X * for this type.
X */
X
void EnableIteration(void *collection, newIteratorFnT newFn);
X
/*
X * Functions: NewIteratorList
X * Usage: iterator = NewIteratorList(sizeof (type), cmpFn);
X * --------------------------------------------------------
X * This function creates a new iterator with an empty iterator
X * list.  The first argument is the size of the element type,
X * which makes it possible for the package to allocate storage
X * for values of that type.  The cmpFn is the comparison function
X * used to sort the iterator elements.  If cmpFn is the constant
X * pointer UnsortedFn, the elements are entered in the order in
X * which AddToIteratorList is called.
X */
X
iteratorADT NewIteratorList(int size, cmpFnT cmpFn);
X
/*
X * Functions: AddToIteratorList
X * Usage: AddToIteratorList(iterator, &element);
X * ---------------------------------------------
X * This function takes an iterator and a pointer to an element
X * and inserts the element into the iterator list.
X */
X
void AddToIteratorList(iteratorADT iterator, void *ep);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/16-Graphs/itertype.h' &&
  chmod 0644 'programs/16-Graphs/itertype.h' ||
  echo 'restore of programs/16-Graphs/itertype.h failed'
  shar_count="`wc -c < 'programs/16-Graphs/itertype.h'`"
  test 3324 -eq "$shar_count" ||
    echo "programs/16-Graphs/itertype.h: original size 3324, current size $shar_count"
fi
# ============= programs/16-Graphs/list.c ==============
if test -f 'programs/16-Graphs/list.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/16-Graphs/list.c (file already exists)'
else
  echo 'x - extracting programs/16-Graphs/list.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/16-Graphs/list.c' &&
/*
X * File: list.c
X * ------------
X * This file implements the list.h interface, which defines
X * an immutable abstraction for manipulating lists of values.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "list.h"
X
/*
X * Type: listCDT
X * -------------
X * The type listCDT is the concrete representation of the type
X * listADT defined by the interface.  Because the list exported
X * by this interface is immutable, there is no need for an extra
X * level of structure.  Thus, the concrete list type is just a
X * linked-list cell containing an element and another list.
X */
X
struct listCDT {
X    listElementT head;
X    listADT tail;
};
X
/* Exported entries */
X
listADT ListCons(listElementT head, listADT tail)
{
X    listADT list;
X
X    list = New(listADT);
X    list->head = head;
X    list->tail = tail;
X    return (list);
}
X
listElementT ListHead(listADT list)
{
X    if (list == NULL) Error("ListHead called on NULL list");
X    return (list->head);
}
X
listADT ListTail(listADT list)
{
X    if (list == NULL) Error("ListTail called on NULL list");
X    return (list->tail);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/16-Graphs/list.c' &&
  chmod 0644 'programs/16-Graphs/list.c' ||
  echo 'restore of programs/16-Graphs/list.c failed'
  shar_count="`wc -c < 'programs/16-Graphs/list.c'`"
  test 1075 -eq "$shar_count" ||
    echo "programs/16-Graphs/list.c: original size 1075, current size $shar_count"
fi
# ============= programs/16-Graphs/list.h ==============
if test -f 'programs/16-Graphs/list.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/16-Graphs/list.h (file already exists)'
else
  echo 'x - extracting programs/16-Graphs/list.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/16-Graphs/list.h' &&
/*
X * File: list.h
X * ------------
X * This interface defines an abstraction for an immutable list.
X */
X
#ifndef _list_h
#define _list_h
X
#include "genlib.h"
X
/*
X * Type: listElementT
X * ------------------
X * The type listElementT is used in this interface to indicate
X * the type of values that can be stored in the list.  Here the
X * list is used to store values of type void *, but that can
X * be changed by editing this definition line.
X */
X
typedef void *listElementT;
X
/*
X * Type: listADT
X * -------------
X * The type listADT represents the abstract type used to represent
X * the list itself.  The empty list is always represented by NULL.
X * The client can rely on the following aspects of the internal
X * structure:
X *
X * 1. Each list value returned is dynamically allocated.
X *
X * 2. The list element is stored at the beginning of the
X *    structure used internally to hold the record so that
X *    the address of the list cell is also the address of the
X *    stored value.  This constraint makes it possible to apply
X *    comparison functions to the stored data.
X */
X
typedef struct listCDT *listADT;
X
/*
X * Function: ListCons
X * Usage: list = ListCons(head, tail);
X * -----------------------------------
X * This function allocates and returns a new list, which consists
X * of the element head followed by the list tail.
X */
X
listADT ListCons(listElementT head, listADT tail);
X
/*
X * Functions: ListHead, ListTail
X * Usage: head = ListHead(list);
X *        tail = ListTail(list);
X * -----------------------------
X * These functions return the head and tail of a list, where the
X * head is defined to be the first element and the tail is the
X * list that remains after removing the head of the list.
X */
X
listElementT ListHead(listADT list);
listADT ListTail(listADT list);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/16-Graphs/list.h' &&
  chmod 0644 'programs/16-Graphs/list.h' ||
  echo 'restore of programs/16-Graphs/list.h failed'
  shar_count="`wc -c < 'programs/16-Graphs/list.h'`"
  test 1793 -eq "$shar_count" ||
    echo "programs/16-Graphs/list.h: original size 1793, current size $shar_count"
fi
# ============= programs/16-Graphs/scanadt.c ==============
if test -f 'programs/16-Graphs/scanadt.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/16-Graphs/scanadt.c (file already exists)'
else
  echo 'x - extracting programs/16-Graphs/scanadt.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/16-Graphs/scanadt.c' &&
/*
X * File: scanadt.c
X * ---------------
X * This file implements the scanadt.h interface.
X */
X
#include <stdio.h>
#include <ctype.h>
#include "genlib.h"
#include "strlib.h"
#include "scanadt.h"
X
/*
X * Type: scannerCDT
X * ----------------
X * This structure is the concrete representation of the type
X * scannerADT, which is exported by this interface.  Its purpose
X * is to maintain the state of the scanner between calls.  The
X * details of the representation are invisible to the client,
X * but consist of the following fields:
X *
X * str          -- Copy of string passed to SetScannerString
X * len          -- Length of string, saved for efficiency
X * cp           -- Current character position in the string
X * savedToken   -- String saved by SaveToken (NULL indicates none)
X * spaceOption  -- Setting of the space option extension
X * numberOption -- Setting of the number option extension
X * stringOption -- Setting of string option extension
X */
X
struct scannerCDT {
X    string str;
X    int len;
X    int cp;
X    string savedToken;
X    spaceOptionT spaceOption;
X    numberOptionT numberOption;
X    stringOptionT stringOption;
};
X
/* Private function prototypes */
X
static void SkipSpaces(scannerADT scanner);
static int ScanToEndOfIdentifier(scannerADT scanner);
static int ScanToEndOfInteger(scannerADT scanner);
static int ScanToEndOfReal(scannerADT scanner);
static string ScanQuotedString(scannerADT scanner);
static char ScanEscapeCharacter(scannerADT scanner);
X
/* Exported entries */
X
scannerADT NewScanner(void)
{
X    scannerADT scanner;
X
X    scanner = New(scannerADT);
X    scanner->str = NULL;
X    scanner->spaceOption = PreserveSpaces;
X    scanner->numberOption = ScanNumbersAsLetters;
X    scanner->stringOption = ScanQuotesAsPunctuation;
X    return (scanner);
}
X
void FreeScanner(scannerADT scanner)
{
X    if (scanner->str != NULL) FreeBlock(scanner->str);
X    FreeBlock(scanner);
}
X
void SetScannerString(scannerADT scanner, string str)
{
X    if (scanner->str != NULL) FreeBlock(scanner->str);
X    scanner->str = CopyString(str);
X    scanner->len = StringLength(str);
X    scanner->cp = 0;
X    scanner->savedToken = NULL;
}
X
string ReadToken(scannerADT scanner)
{
X    char ch;
X    string token;
X    int start, finish;
X
X    if (scanner->str == NULL) {
X        Error("SetScannerString has not been called");
X    }
X    if (scanner->savedToken != NULL) {
X        token = scanner->savedToken;
X        scanner->savedToken = NULL;
X        return (token);
X    }
X    if (scanner->spaceOption == IgnoreSpaces) SkipSpaces(scanner);
X    start = finish = scanner->cp;
X    if (start >= scanner->len) return (CopyString(""));
X    ch = scanner->str[scanner->cp];
X    if (scanner->stringOption == ScanQuotesAsStrings
X            && ch == '"') {
X        return (ScanQuotedString(scanner));
X    }
X    if (isdigit(ch)) {
X        switch (scanner->numberOption) {
X          case ScanNumbersAsLetters:
X            finish = ScanToEndOfIdentifier(scanner);
X            break;
X          case ScanNumbersAsIntegers:
X            finish = ScanToEndOfInteger(scanner);
X            break;
X          case ScanNumbersAsReals:
X            finish = ScanToEndOfReal(scanner);
X            break;
X        }
X    } else if (isalnum(ch)) {
X        finish = ScanToEndOfIdentifier(scanner);
X    } else {
X        scanner->cp++;
X    }
X    return (SubString(scanner->str, start, finish));
}
X
bool MoreTokensExist(scannerADT scanner)
{
X    if (scanner->str == NULL) {
X        Error("SetScannerString has not been called");
X    }
X    if (scanner->savedToken != NULL) {
X        return (!StringEqual(scanner->savedToken, ""));
X    }
X    if (scanner->spaceOption == IgnoreSpaces) SkipSpaces(scanner);
X    return (scanner->cp < scanner->len);
}
X
void SaveToken(scannerADT scanner, string token)
{
X    if (scanner->str == NULL) {
X        Error("SetScannerString has not been called");
X    }
X    if (scanner->savedToken != NULL) {
X        Error("Token has already been saved");
X    }
X    scanner->savedToken = token;
}
X
void SetScannerSpaceOption(scannerADT scanner, spaceOptionT option)
{
X    scanner->spaceOption = option;
}
X
spaceOptionT GetScannerSpaceOption(scannerADT scanner)
{
X    return (scanner->spaceOption);
}
X
void SetScannerNumberOption(scannerADT scanner, numberOptionT option)
{
X    scanner->numberOption = option;
}
X
numberOptionT GetScannerNumberOption(scannerADT scanner)
{
X    return (scanner->numberOption);
}
X
void SetScannerStringOption(scannerADT scanner, stringOptionT option)
{
X    scanner->stringOption = option;
}
X
stringOptionT GetScannerStringOption(scannerADT scanner)
{
X    return (scanner->stringOption);
}
X
/* Private functions */
X
/*
X * Function: SkipSpaces
X * Usage: SkipSpaces(scanner);
X * ---------------------------
X * This function advances the position of the scanner until the
X * current character is not a whitespace character.
X */
X
static void SkipSpaces(scannerADT scanner)
{
X    while (isspace(scanner->str[scanner->cp])) {
X        scanner->cp++;
X    }
}
X
/*
X * Function: ScanToEndOfIdentifier
X * Usage: finish = ScanToEndOfIdentifier(scanner);
X * -----------------------------------------------
X * This function advances the position of the scanner until it
X * reaches the end of a sequence of letters or digits that make
X * up an identifier.  The return value is the index of the last
X * character in the identifier; the value of the stored index
X * cp is the first character after that.
X */
X
static int ScanToEndOfIdentifier(scannerADT scanner)
{
X    while (isalnum(scanner->str[scanner->cp])) {
X        scanner->cp++;
X    }
X    return (scanner->cp - 1);
}
X
/*
X * Function: ScanToEndOfInteger
X * Usage: finish = ScanToEndOfInteger(scanner);
X * --------------------------------------------
X * This function advances the position of the scanner until it
X * reaches the end of a sequence of digits.  The return value is
X * the index of the last character in the integer; the value
X * of the stored index cp is the first character after that.
X */
X
static int ScanToEndOfInteger(scannerADT scanner)
{
X    while (isdigit(scanner->str[scanner->cp])) {
X        scanner->cp++;
X    }
X    return (scanner->cp - 1);
}
X
/*
X * Function: ScanToEndOfReal
X * Usage: finish = ScanToEndOfReal(scanner);
X * -----------------------------------------
X * This function advances the position of the scanner until it
X * reaches the end of a legal number.  The return value is the
X * index of the last character in the identifier; the value
X * of the stored index cp is the first character after that.
X *
X * The function operates by simulating what computer scientists
X * call a finite-state machine.  The program uses the variable
X * state to record the history of the process and determine
X * what characters would be legal at this point in time.
X */
X
#define InitialState        0
#define BeforeDecimalPoint  1
#define AfterDecimalPoint   2
#define StartingExponent    3
#define FoundExponentSign   4
#define ScanningExponent    5
#define FinalState         -1
X
static int ScanToEndOfReal(scannerADT scanner)
{
X    int state;
X    char ch;
X
X    state = InitialState;
X    while (state != FinalState) {
X        ch = scanner->str[scanner->cp];
X        switch (state) {
X          case InitialState:
X            if (!isdigit(ch)) Error("ScanToEndOfReal called on nonnumber");
X             state = BeforeDecimalPoint;
X            break;
X          case BeforeDecimalPoint:
X            if (ch == '.') {
X                state = AfterDecimalPoint;
X            } else if (ch == 'E' || ch == 'e') {
X                state = StartingExponent;
X            } else if (!isdigit(ch)) {
X                state = FinalState;
X            }
X            break;
X          case AfterDecimalPoint:
X            if (ch == 'E' || ch == 'e') {
X                state = StartingExponent;
X            } else if (!isdigit(ch)) {
X                state = FinalState;
X            }
X            break;
X          case StartingExponent:
X            if (ch == '+' || ch == '-') {
X                state = FoundExponentSign;
X            } else if (isdigit(ch)) {
X                state = ScanningExponent;
X            } else {
X                scanner->cp--;
X                state = FinalState;
X            }
X            break;
X          case FoundExponentSign:
X            if (isdigit(ch)) {
X                state = ScanningExponent;
X            } else {
X                scanner->cp -= 2;
X                state = FinalState;
X            }
X            break;
X          case ScanningExponent:
X            if (!isdigit(ch)) {
X                state = FinalState;
X            }
X            break;
X        }
X        if (state != FinalState) scanner->cp++;
X    }
X    return (scanner->cp - 1);
}
X
/*
X * Function: ScanQuotedString
X * Usage: str = ScanQuotedString(scanner);
X * ---------------------------------------
X * This function reads and returns a quoted string from the
X * scanner.  The current position of the scanner must be the
X * opening quotation mark.  At the end, the current position
X * marker will be set to the character position after the
X * closing quote.  The scanner generates an error if there
X * is no closing quotation mark before the end of the string.
X */
X
static string ScanQuotedString(scannerADT scanner)
{
X    string token;
X    char ch;
X
X    token = "\"";
X    scanner->cp++;
X    while ((ch = scanner->str[scanner->cp++]) != '"') {
X        if (ch == '\0') Error("Unterminated string");
X        if (ch == '\\') ch = ScanEscapeCharacter(scanner);
X        token = Concat(token, CharToString(ch));
X    }
X    return (Concat(token, "\""));
}
X
/*
X * Function: ScanEscapeCharacter
X * Usage: ch = ScanEscapeCharacter(scanner);
X * -----------------------------------------
X * This function is used by ScanQuotedString to read an escape
X * character sequence from the scanner string.  The opening
X * backslash character has already been read.  Most of the
X * complexity comes in reading the '\ddd' and '\xdd' forms.
X */
X
static char ScanEscapeCharacter(scannerADT scanner)
{
X    char ch, result;
X    int digit, base;
X
X    ch = scanner->str[scanner->cp];
X    if (isdigit(ch) || ch == 'x') {
X        base = 8;
X        if (ch == 'x') {
X            base = 16;
X            scanner->cp++;
X        }
X        result = 0;
X        while (TRUE) {
X            ch = scanner->str[scanner->cp];
X            if (isdigit(ch)) {
X                digit = ch - '0';
X            } else if (isalpha(ch)) {
X                digit = toupper(ch) - 'A' + 10;
X            } else {
X                digit = base;
X            }
X            if (digit >= base) break;
X            result = base * result + digit;
X            scanner->cp++;
X        }
X        return (result);
X    }
X    scanner->cp++;
X    switch (ch) {
X      case 'a':  return ('\a');
X      case 'b':  return ('\b');
X      case 'f':  return ('\f');
X      case 'n':  return ('\n');
X      case 'r':  return ('\r');
X      case 't':  return ('\t');
X      case 'v':  return ('\v');
X      case '\\': return ('\\');
X      case '"':  return ('"');
X    }
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/16-Graphs/scanadt.c' &&
  chmod 0644 'programs/16-Graphs/scanadt.c' ||
  echo 'restore of programs/16-Graphs/scanadt.c failed'
  shar_count="`wc -c < 'programs/16-Graphs/scanadt.c'`"
  test 10928 -eq "$shar_count" ||
    echo "programs/16-Graphs/scanadt.c: original size 10928, current size $shar_count"
fi
# ============= programs/16-Graphs/scanadt.h ==============
if test -f 'programs/16-Graphs/scanadt.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/16-Graphs/scanadt.h (file already exists)'
else
  echo 'x - extracting programs/16-Graphs/scanadt.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/16-Graphs/scanadt.h' &&
/*
X * File: scanadt.h
X * ---------------
X * This file is the interface to a module that exports an abstract
X * data type to facilitate dividing a string into logical units
X * called "tokens," which are either
X *
X * 1. Strings of consecutive letters and digits representing words
X * 2. One-character strings representing punctuation or separators
X *
X * To use this package, you must first create an instance of a
X * scannerADT by calling
X *
X *      scanner = NewScanner();
X *
X * All other calls to the scanner package take this variable as their
X * first argument to identify a particular instance of the abstract
X * scanner type.
X *
X * You initialize the scanner to hold a particular string by calling
X *
X *      SetScannerString(scanner, str);
X *
X * where str is the string from which tokens should be read.  To
X * retrieve each individual token, you make the following call:
X *
X *      token = ReadToken(scanner);
X *
X * To determine whether any tokens remain to be read, you can call
X * the predicate function MoreTokensExist(scanner).  The ReadToken
X * function returns the empty string after the last token is read.
X *
X * The following code fragment serves as an idiom for processing
X * each token in the string inputString:
X *
X *      scanner = NewScanner();
X *      SetScannerString(scanner, inputString);
X *      while (MoreTokensExist(scanner)) {
X *          token = ReadToken(scanner);
X *          . . . process the token . . .
X *      }
X *
X * This version of scanadt.h also supports the following extensions,
X * which are documented later in the interface:
X *
X *   SaveToken
X *   SetScannerSpaceOption
X *   SetScannerStringOption
X *   SetScannerNumberOption
X */
X
#ifndef _scanadt_h
#define _scanadt_h
X
#include "genlib.h"
X
/*
X * Type: scannerADT
X * ----------------
X * This type is the abstract type used to represent a single instance
X * of a scanner.  As with any abstract type, the details of the
X * internal representation are hidden from the client.
X */
X
typedef struct scannerCDT *scannerADT;
X
/*
X * Function: NewScanner
X * Usage: scanner = NewScanner();
X * ------------------------------
X * This function creates a new scanner instance.  All other functions
X * in this interface take this scanner value as their first argument
X * so that they can identify what particular instance of the scanner
X * is in use.  This design makes it possible for clients to have more
X * than one scanner process active at the same time.
X */
X
scannerADT NewScanner(void);
X
/*
X * Function: FreeScanner
X * Usage: FreeScanner(scanner);
X * ----------------------------
X * This function frees the storage associated with scanner.
X */
X
void FreeScanner(scannerADT scanner);
X
/*
X * Function: SetScannerString
X * Usage: SetScannerString(scanner, str);
X * --------------------------------------
X * This function initializes the scanner so that it will start
X * extracting tokens from the string str.
X */
X
void SetScannerString(scannerADT scanner, string str);
X
/*
X * Function: ReadToken
X * Usage: token = ReadToken(scanner);
X * ----------------------------------
X * This function returns the next token from scanner.  If
X * ReadToken is called when no tokens are available, it returns
X * the empty string.  The token returned by ReadToken is always
X * allocated in the heap, which means that clients can call
X * FreeBlock when the token is no longer needed.
X */
X
string ReadToken(scannerADT scanner);
X
/*
X * Function: MoreTokensExist
X * Usage: if (MoreTokensExist(scanner)) . . .
X * ------------------------------------------
X * This function returns TRUE as long as there are additional
X * tokens for the scanner to read.
X */
X
bool MoreTokensExist(scannerADT scanner);
X
/*
X * Function: SaveToken
X * Usage: SaveToken(scanner, token);
X * ---------------------------------
X * This function stores the token in the scanner data structure
X * in such a way that the next time ReadToken is called, it will
X * return that token without reading any additional characters
X * from the input.
X */
X
void SaveToken(scannerADT scanner, string token);
X
/*
X * Functions: SetScannerSpaceOption, GetScannerSpaceOption
X * Usage: SetScannerSpaceOption(scanner, option);
X *        option = GetScannerSpaceOption(scanner);
X * -----------------------------------------------
X * The SetScannerSpaceOption function controls whether the scanner
X * ignores whitespace characters or treats them as valid tokens.
X * By default, the ReadToken function treats whitespace characters,
X * such as spaces and tabs, just like any other punctuation mark.
X * If, however, you call
X *
X *    SetScannerSpaceOption(scanner, IgnoreSpaces);
X *
X * the scanner will skip over any white space before reading a token.
X * You can restore the original behavior by calling
X *
X *    SetScannerSpaceOption(scanner, PreserveSpaces);
X *
X * The GetScannerSpaceOption function returns the current setting
X * of this option.
X */
X
typedef enum { PreserveSpaces, IgnoreSpaces } spaceOptionT;
X
void SetScannerSpaceOption(scannerADT scanner, spaceOptionT option);
spaceOptionT GetScannerSpaceOption(scannerADT scanner);
X
/*
X * Functions: SetScannerNumberOption, GetScannerNumberOption
X * Usage: SetScannerNumberOption(scanner, option);
X *        option = GetScannerNumberOption(scanner);
X * ------------------------------------------------
X * This function controls whether the scanner treats numeric values
X * specially.  The default behavior for the scanner is to treat
X * digits as equivalent to letters.  If you call
X *
X *    SetScannerNumberOption(scanner, ScanNumbersAsIntegers);
X *
X * a token beginning with a digit will end at the first nondigit.
X * (Note that digits can still be scanned as part of a token as in
X * the token "x1".)  If you call
X *
X *    SetScannerNumberOption(scanner, ScanNumbersAsReals);
X *
X * the scanner will return the longest token string that represents
X * a real number, if the next character to be scanned is a digit.
X * The format for a real number is a sequence of digit characters
X * that may include at most one decimal point, optionally followed
X * by the letter 'E' in either upper- or lowercase, an optional sign,
X * and an exponent.  You can restore the default behavior by calling
X *
X *    SetScannerNumberOption(scanner, ScanNumbersAsLetters);
X *
X * Even if the number options are enabled, ReadToken always returns
X * its result as a string, which means that you need to call
X * StringToInteger or StringToReal to convert the token to a number.
X */
X
typedef enum {
X    ScanNumbersAsLetters,
X    ScanNumbersAsIntegers,
X    ScanNumbersAsReals
} numberOptionT;
X
void SetScannerNumberOption(scannerADT scanner, numberOptionT option);
numberOptionT GetScannerNumberOption(scannerADT scanner);
X
/*
X * Functions: SetScannerStringOption, GetScannerStringOption
X * Usage: SetScannerStringOption(scanner, option);
X *        option = GetScannerStringOption(scanner);
X * ------------------------------------------------
X * This function controls how the scanner treats double quotation
X * marks in the input.  The default behavior for the scanner is
X * to treat quotes just like any other punctuation character.
X * If, however, you call
X *
X *    SetScannerStringOption(scanner, ScanQuotesAsStrings);
X *
X * a token beginning with a quotation mark will be scanned up to
X * the closing quotation mark.  The quotation marks are returned
X * as part of the scanned token so that clients can differentiate
X * strings from other token types.  The original behavior can be
X * restored by calling
X *
X *    SetScannerStringOption(scanner, ScanQuotesAsPunctuation);
X *
X * When scanning a string, the scanner recognizes the standard
X * escape sequences from ANSI C, such as \n and \t.
X */
X
typedef enum {
X    ScanQuotesAsPunctuation,
X    ScanQuotesAsStrings
} stringOptionT;
X
void SetScannerStringOption(scannerADT scanner, stringOptionT option);
stringOptionT GetScannerStringOption(scannerADT scanner);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/16-Graphs/scanadt.h' &&
  chmod 0644 'programs/16-Graphs/scanadt.h' ||
  echo 'restore of programs/16-Graphs/scanadt.h failed'
  shar_count="`wc -c < 'programs/16-Graphs/scanadt.h'`"
  test 7862 -eq "$shar_count" ||
    echo "programs/16-Graphs/scanadt.h: original size 7862, current size $shar_count"
fi
# ============= programs/16-Graphs/set.c ==============
if test -f 'programs/16-Graphs/set.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/16-Graphs/set.c (file already exists)'
else
  echo 'x - extracting programs/16-Graphs/set.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/16-Graphs/set.c' &&
/*
X * File: set.c
X * -----------
X * This file implements the set abstraction defined in set.h.
X */
X
#include <stdio.h>
#include <stdarg.h>
#include "genlib.h"
#include "bst.h"
#include "itertype.h"
#include "iterator.h"
#include "set.h"
X
/*
X * Type: setCDT
X * ------------
X * This type defines the concrete structure of a set.
X */
X
struct setCDT {
X    iteratorHeaderT header;
X    setClassT class;
X    cmpFnT cmpFn;
X    int nElements;
X    bstADT bst;
};
X
/*
X * Type: setElementT
X * -----------------
X * This union type combines the two representations of an element.
X * It is used in the implementation to allocate storage for an
X * element that is guaranteed to be large enough no matter whether
X * the set contains integers or pointers.  This type is used only
X * to reduce the number of special cases in the code and is not
X * exported to the client.
X */
X
typedef union {
X    int intRep;
X    void *ptrRep;
} setElementT;
X
/* Private function prototypes */
X
static setADT NewSet(setClassT class, cmpFnT cmpFn);
static void InitSetNodeFn(void *np, void *kp, void *clientData);
static void FreeNodeFn(void *np, void *clientData);
static void AddERef(setADT set, void *ep);
static void DeleteERef(setADT set, void *ep);
static bool TestERef(setADT set, void *ep);
static iteratorADT NewSetIterator(void *collection);
static void AddElementToIterator(void *np, void *clientData);
X
/* Exported entries */
X
/*
X * Implementation notes: NewIntSet, NewPtrSet
X * ------------------------------------------
X * The contructor functions call a common function that creates
X * a new set from a class and a comparison function.  The
X * elements in the set are stored in a binary search tree.
X */
X
setADT NewIntSet(void)
{
X    return (NewSet(IntSet, IntCmpFn));
}
X
setADT NewPtrSet(cmpFnT cmpFn)
{
X    return (NewSet(PtrSet, cmpFn));
}
X
static setADT NewSet(setClassT class, cmpFnT cmpFn)
{
X    setADT set;
X
X    set = New(setADT);
X    EnableIteration(set, NewSetIterator);
X    set->class = class;
X    set->cmpFn = cmpFn;
X    set->nElements = 0;
X    set->bst = NewBST(sizeof (setElementT), cmpFn, InitSetNodeFn);
X    return (set);
}
X
static void InitSetNodeFn(void *np, void *kp, void *clientData)
{
X    setADT set = (setADT) clientData;
X
X    switch (set->class) {
X      case IntSet: *((int *) np) = *((int *) kp); break;
X      case PtrSet: *((void **) np) = *((void **) kp); break;
X    }
X    set->nElements++;
}
X
void FreeSet(setADT set)
{
X    FreeBST(set->bst, FreeNodeFn);
X    FreeBlock(set);
}
X
static void FreeNodeFn(void *np, void *clientData)
{
X    FreeBlock(np);
}
X
/* Selection functions */
X
setClassT GetSetClass(setADT set)
{
X    return (set->class);
}
X
cmpFnT GetCompareFunction(setADT set)
{
X    return (set->cmpFn);
}
X
/*
X * Implementation notes: NElements, SetIsEmpty
X * -------------------------------------------
X * For efficiency, this package stores the number of elements
X * as part of the set data structure, updating it as necessary.
X */
X
int NElements(setADT set)
{
X    return (set->nElements);
}
X
bool SetIsEmpty(setADT set)
{
X    return (set->nElements == 0);
}
X
/*
X * Implementation notes: AddIntElement, AddPtrElement
X * --------------------------------------------------
X * These functions call a common function AddERef, which takes
X * a pointer to the element.
X */
X
X
void AddIntElement(setADT set, int element)
{
X    if (set->class != IntSet) Error("Set is not an integer set");
X    AddERef(set, &element);
}
X
void AddPtrElement(setADT set, void *element)
{
X    if (set->class != PtrSet) Error("Set is not a pointer set");
X    AddERef(set, &element);
}
X
void AddElement(setADT set, ...)
{
X    va_list args;
X    int n;
X    void *p, *np, *ep;
X
X    va_start(args, set);
X    switch (set->class) {
X      case IntSet: n = va_arg(args, int); ep = &n; break;
X      case PtrSet: p = va_arg(args, void *); ep = &p; break;
X    }
X    va_end(args);
X    AddERef(set, ep);
}
X
static void AddERef(setADT set, void *ep)
{
X    (void) InsertBSTNode(set->bst, ep, set);
}
X
/*
X * Implementation note: AddArrayToSet
X * ----------------------------------
X * This function calls AddERef for each element in the array.
X * Note that the addressing depends on the set class.
X */
X
void AddArrayToSet(setADT set, void *array, int n)
{
X    int i;
X
X    for (i = 0; i < n; i++) {
X        switch (set->class) {
X          case IntSet: AddERef(set, ((int *) array) + i); break;
X          case PtrSet: AddERef(set, ((void **) array) + i); break;
X        }
X    }
}
X
/*
X * Implementation notes: DeleteIntElement, DeletePtrElement
X * --------------------------------------------------------
X * These functions simply check to see that the set type is
X * appropriate and then call a common function.
X */
X
void DeleteIntElement(setADT set, int element)
{
X    if (set->class != IntSet) Error("Set is not an integer set");
X    DeleteERef(set, &element);
}
X
void DeletePtrElement(setADT set, void *element)
{
X    if (set->class != PtrSet) Error("Set is not a pointer set");
X    DeleteERef(set, &element);
}
X
void DeleteElement(setADT set, ...)
{
X    va_list args;
X    int n;
X    void *p, *np, *ep;
X
X    va_start(args, set);
X    switch (set->class) {
X      case IntSet: n = va_arg(args, int); ep = &n; break;
X      case PtrSet: p = va_arg(args, void *); ep = &p; break;
X    }
X    va_end(args);
X    DeleteERef(set, ep);
}
X
static void DeleteERef(setADT set, void *ep)
{
X    void *np;
X
X    np = DeleteBSTNode(set->bst, ep);
X    if (np != NULL) {
X        FreeBlock(np);
X        set->nElements--;
X    }
}
X
/*
X * Implementation notes: IsIntElement, IsPtrElement
X * ------------------------------------------------
X * These implementations call a common TestERef function, which
X * in turn calls FindBSTNode to look up the element.
X */
X
bool IsIntElement(setADT set, int element)
{
X    if (set->class != IntSet) Error("Set is not an integer set");
X    return (TestERef(set, &element));
}
X
bool IsPtrElement(setADT set, void *element)
{
X    if (set->class != PtrSet) Error("Set is not a pointer set");
X    return (TestERef(set, &element));
}
X
bool IsElement(setADT set, ...)
{
X    va_list args;
X    int n;
X    void *p, *np, *ep;
X
X    va_start(args, set);
X    switch (set->class) {
X      case IntSet: n = va_arg(args, int); ep = &n; break;
X      case PtrSet: p = va_arg(args, void *); ep = &p; break;
X    }
X    va_end(args);
X    return (TestERef(set, ep));
}
X
static bool TestERef(setADT set, void *ep)
{
X    return (FindBSTNode(set->bst, ep) != NULL);
}
X
/*
X * Implementation notes: Set operations
X * ------------------------------------
X * The functions IsSubset, Union, Intersection, and SetDifference
X * are similar in structure.  Each one uses an iterator to walk over
X * the appropriate set.  Because the functions in bst.h need only
X * the address of an element, the functions can use the union type
X * setElementT to avoid special-case code for the two set classes.
X */
X
bool SetEqual(setADT s1, setADT s2)
{
X    return (IsSubset(s1, s2) && IsSubset(s2, s1));
}
X
bool IsSubset(setADT s1, setADT s2)
{
X    iteratorADT iterator;
X    setElementT element;
X    bool result;
X
X    if (s1->class != s2->class || s1->cmpFn != s2->cmpFn) {
X        Error("IsSubset: Set types do not match");
X    }
X    result = TRUE;
X    iterator = NewIterator(s1);
X    while (result && StepIterator(iterator, &element)) {
X        if (!TestERef(s2, &element)) result = FALSE;
X    }
X    FreeIterator(iterator);
X    return (result);
}
X
setADT Union(setADT s1, setADT s2)
{
X    iteratorADT iterator;
X    setElementT element;
X    setADT set;
X
X    if (s1->class != s2->class || s1->cmpFn != s2->cmpFn) {
X        Error("Union: Set types do not match");
X    }
X    set = NewSet(s1->class, s1->cmpFn);
X    iterator = NewIterator(s1);
X    while (StepIterator(iterator, &element)) {
X        AddERef(set, &element);
X    }
X    FreeIterator(iterator);
X    iterator = NewIterator(s2);
X    while (StepIterator(iterator, &element)) {
X        AddERef(set, &element);
X    }
X    FreeIterator(iterator);
X    return (set);
}
X
setADT Intersection(setADT s1, setADT s2)
{
X    iteratorADT iterator;
X    setElementT element;
X    setADT set;
X
X    if (s1->class != s2->class || s1->cmpFn != s2->cmpFn) {
X        Error("Intersection: Set types do not match");
X    }
X    set = NewSet(s1->class, s1->cmpFn);
X    iterator = NewIterator(s1);
X    while (StepIterator(iterator, &element)) {
X        if (TestERef(s2, &element)) AddERef(set, &element);
X    }
X    FreeIterator(iterator);
X    return (set);
}
X
setADT SetDifference(setADT s1, setADT s2)
{
X    iteratorADT iterator;
X    setElementT element;
X    setADT set;
X
X    if (s1->class != s2->class || s1->cmpFn != s2->cmpFn) {
X        Error("SetDifference: Set types do not match");
X    }
X    set = NewSet(s1->class, s1->cmpFn);
X    iterator = NewIterator(s1);
X    while (StepIterator(iterator, &element)) {
X        if (!TestERef(s2, &element)) AddERef(set, &element);
X    }
X    FreeIterator(iterator);
X    return (set);
}
X
/*
X * Implementation notes: NewSetIterator, AddElementToIterator
X * ----------------------------------------------------------
X * These functions make it possible to use the general iterator
X * facility on sets.  For details on the general strategy, see
X * the comments in the itertype.h interface.  The comparison
X * function passed to NewIteratorList is UnsortedFn because the
X * InOrder walk already guarantees that the elements will appear
X * in sorted order.
X */
X
static iteratorADT NewSetIterator(void *collection)
{
X    setADT set = collection;
X    int elementSize;
X    iteratorADT iterator;
X
X    switch (set->class) {
X      case IntSet: elementSize = sizeof(int); break;
X      case PtrSet: elementSize = sizeof(void *); break;
X    }
X    iterator = NewIteratorList(elementSize, UnsortedFn);
X    MapBST(AddElementToIterator, set->bst, InOrder, iterator);
X    return (iterator);
}
X
static void AddElementToIterator(void *np, void *clientData)
{
X    AddToIteratorList((iteratorADT) clientData, np);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/16-Graphs/set.c' &&
  chmod 0644 'programs/16-Graphs/set.c' ||
  echo 'restore of programs/16-Graphs/set.c failed'
  shar_count="`wc -c < 'programs/16-Graphs/set.c'`"
  test 9887 -eq "$shar_count" ||
    echo "programs/16-Graphs/set.c: original size 9887, current size $shar_count"
fi
# ============= programs/16-Graphs/set.h ==============
if test -f 'programs/16-Graphs/set.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/16-Graphs/set.h (file already exists)'
else
  echo 'x - extracting programs/16-Graphs/set.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/16-Graphs/set.h' &&
/*
X * File: set.h
X * -----------
X * This interface exports the type setADT, which can be used
X * to represent sets of objects.  The objects themselves can
X * be either of the following two types:
X *
X * int     This base type makes it easy to represent sets
X *         of integers (or any other scalar type), which come
X *         up frequently in practice.
X *
X * void *  This base type makes it possible for clients to
X *         use the set package with more sophisticated
X *         client-defined types.  The only requirement is that
X *         the client must supply a comparison function that
X *         compares two elements of the specified type.
X *
X * These two base types define two classes of sets, IntSet and
X * PtrSet.  The class of the set is determined when the set is
X * created, and the interface in some cases provides separate
X * functions for dealing with sets of each class.
X *
X * In addition to the set operations shown in this interface,
X * the set type allows iteration, as described in the iterator.h
X * interface.  The standard iterator idiom looks like this:
X *
X *     iterator = NewIterator(s);
X *     while (StepIterator(iterator, &x)) {
X *        . . . body of loop involving x . . .
X *     }
X *     FreeIterator(iterator);
X */
X
#ifndef _set_h
#define _set_h
X
#include "genlib.h"
#include "cmpfn.h"
X
/*
X * Type: setClassT
X * ---------------
X * This enumeration type defines the two possible set classes.
X */
X
typedef enum { IntSet, PtrSet } setClassT;
X
/*
X * Type: setADT
X * ------------
X * This type defines the abstract set type.  Depending on how
X * you initialize it, a set may be of either class.
X */
X
typedef struct setCDT *setADT;
X
/* Exported entries */
X
/*
X * Functions: NewIntSet, NewPtrSet
X * Usage: set = NewIntSet();
X *        set = NewPtrSet(cmpFn);
X * ------------------------------
X * These functions are used to create empty setADT values of the
X * specified class.  The NewIntSet function creates sets capable
X * of holding integers; the NewPtrSet function creates a more
X * general set type capable of holding client-specified types.
X */
X
setADT NewIntSet(void);
setADT NewPtrSet(cmpFnT cmpFn);
X
/*
X * Function: FreeSet
X * Usage: FreeSet(set);
X * --------------------
X * This function frees the storage associated with set, which
X * may be of either class.
X */
X
void FreeSet(setADT set);
X
/*
X * Functions: GetSetClass, GetCompareFunction
X * Usage: class = GetSetClass(set);
X *        fn = GetCompareFunction(set);
X * ------------------------------------
X * These functions return the set class and the comparison
X * function for an existing set.
X */
X
setClassT GetSetClass(setADT set);
cmpFnT GetCompareFunction(setADT set);
X
/*
X * Function: NElements
X * Usage: n = NElements(set);
X * --------------------------
X * This function returns the number of elements in the set.
X */
X
int NElements(setADT set);
X
/*
X * Function: SetIsEmpty
X * Usage: if (SetIsEmpty(set)) . . .
X * ---------------------------------
X * This function returns TRUE if the set has no elements.
X */
X
bool SetIsEmpty(setADT set);
X
/*
X * Functions: AddIntElement, AddPtrElement
X * Usage: AddIntElement(set, element);
X *        AddPtrElement(set, element);
X * ---------------------------------------
X * These functions each add a new element to an existing set
X * and differ only in the type of that element.
X */
X
void AddIntElement(setADT set, int element);
void AddPtrElement(setADT set, void *element);
X
/*
X * Function: AddElement
X * Usage: AddElement(set, element);
X * --------------------------------
X * This function adds an element to the set, using the set class
X * to determine the addressing structure of the element.
X */
X
void AddElement(setADT set, ...);
X
/*
X * Function: AddArrayToSet
X * Usage: AddArrayToSet(set, array, n);
X * ------------------------------------
X * This function adds the elements in the specified array to the
X * set.  The parameter n gives the effective size of the array.
X * The client is responsible for ensuring that the type of the
X * array matches the element type of the set.
X */
X
void AddArrayToSet(setADT set, void *array, int n);
X
/*
X * Functions: DeleteIntElement, DeletePtrElement
X * Usage: DeleteIntElement(set, element);
X *        DeletePtrElement(set, element);
X * ---------------------------------------------
X * These functions delete the element from the set, if it exists.
X */
X
void DeleteIntElement(setADT set, int element);
void DeletePtrElement(setADT set, void *element);
X
/*
X * Function: DeleteElement
X * Usage: DeleteElement(set, element);
X * -----------------------------------
X * This function deletes an element from the set, using the set
X * class to determine the addressing structure of the element.
X */
X
void DeleteElement(setADT set, ...);
X
/*
X * Functions: IsIntElement, IsPtrElement
X * Usage: if (IsIntElement(set, element)) . . .
X *        if (IsPtrElement(set, element)) . . .
X * --------------------------------------------
X * These functions return TRUE if the element is in the set.
X */
X
bool IsIntElement(setADT set, int element);
bool IsPtrElement(setADT set, void *element);
X
/*
X * Function: IsElement
X * Usage: if (IsElement(set, element)) . . .
X * -----------------------------------------
X * This function returns TRUE if the element is in the set.
X */
X
bool IsElement(setADT set, ...);
X
/*
X * Functions: SetEqual, IsSubset
X * Usage: if (SetEqual(s1, s2)) . . .
X *        if (IsSubset(s1, s2)) . . .
X * ----------------------------------
X * These predicate functions implement the equality and subset
X * relations on sets, respectively.  SetEqual(s1, s2) returns
X * TRUE if s1 and s2 have the same elements.  IsSubset(s1, s2)
X * returns TRUE if all elements of s1 are also elements of s2.
X */
X
bool SetEqual(setADT s1, setADT s2);
bool IsSubset(setADT s1, setADT s2);
X
/*
X * Functions: Union, Intersection, SetDifference
X * Usage: set = Union(s1, s2);
X *        set = Intersection(s1, s2);
X *        set = SetDifference(s1, s2);
X * ---------------------------------------------
X * These functions each return a new set, as follows:
X *
X * Union(s1, s2)          All elements in either s1 or s2.
X * Intersection(s1, s2)   All elements in both s1 and s2.
X * SetDifference(s1, s2)  All elements in s1 but not in s2.
X */
X
setADT Union(setADT s1, setADT s2);
setADT Intersection(setADT s1, setADT s2);
setADT SetDifference(setADT s1, setADT s2);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/16-Graphs/set.h' &&
  chmod 0644 'programs/16-Graphs/set.h' ||
  echo 'restore of programs/16-Graphs/set.h failed'
  shar_count="`wc -c < 'programs/16-Graphs/set.h'`"
  test 6341 -eq "$shar_count" ||
    echo "programs/16-Graphs/set.h: original size 6341, current size $shar_count"
fi
# ============= programs/16-Graphs/simple-graph.c ==============
if test -f 'programs/16-Graphs/simple-graph.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/16-Graphs/simple-graph.c (file already exists)'
else
  echo 'x - extracting programs/16-Graphs/simple-graph.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/16-Graphs/simple-graph.c' &&
/*
X * File: graph.c (adjacency list version)
X * --------------------------------------
X * This file implements the preliminary version of the graph.h
X * interface using linked lists to store the nodes and arcs.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "list.h"
#include "graph.h"
X
/*
X * Type: graphCDT
X * --------------
X * This definition provides the concrete type for a graphADT,
X * which is implemented as a list of nodes.
X */
X
struct graphCDT {
X    listADT nodes;
};
X
/*
X * Type: nodeCDT
X * -------------
X * This type defines the concrete structure of a node, which
X * consists of the graph pointer and a list of connected nodes.
X */
X
struct nodeCDT {
X    graphADT graph;
X    listADT arcs;
};
X
/* Exported entries */
X
graphADT NewGraph(void)
{
X    graphADT graph;
X
X    graph = New(graphADT);
X    graph->nodes = NULL;
X    return (graph);
}
X
nodeADT NewNode(graphADT graph)
{
X    nodeADT node;
X
X    node = New(nodeADT);
X    node->graph = graph;
X    node->arcs = NULL;
X    graph->nodes = ListCons(node, graph->nodes);
X    return (node);
}
X
void Connect(nodeADT n1, nodeADT n2)
{
X    if (n1->graph != n2->graph) {
X        Error("Connect: Nodes are in different graphs");
X    }
X    if (IsConnected(n1, n2)) return;
X    n1->arcs = ListCons(n2, n1->arcs);
}
X
bool IsConnected(nodeADT n1, nodeADT n2)
{
X    listADT list;
X
X    if (n1->graph != n2->graph) {
X        Error("Connect: Nodes are in different graphs");
X    }
X    list = n1->arcs;
X    while (list != NULL) {
X        if (n2 == ListHead(list)) return (TRUE);
X        list = ListTail(list);
X    }
X    return (FALSE);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/16-Graphs/simple-graph.c' &&
  chmod 0644 'programs/16-Graphs/simple-graph.c' ||
  echo 'restore of programs/16-Graphs/simple-graph.c failed'
  shar_count="`wc -c < 'programs/16-Graphs/simple-graph.c'`"
  test 1583 -eq "$shar_count" ||
    echo "programs/16-Graphs/simple-graph.c: original size 1583, current size $shar_count"
fi
# ============= programs/16-Graphs/simple-graph.h ==============
if test -f 'programs/16-Graphs/simple-graph.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/16-Graphs/simple-graph.h (file already exists)'
else
  echo 'x - extracting programs/16-Graphs/simple-graph.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/16-Graphs/simple-graph.h' &&
/*
X * File: graph.h (preliminary)
X * ---------------------------
X * This file is a simplified version of an interface for graphs.
X */
X
#ifndef _graph_h
#define _graph_h
X
/*
X * Types: graphADT, nodeADT
X * ------------------------
X * These abstract types are used to represent graphs and nodes,
X * respectively.
X */
X
typedef struct graphCDT *graphADT;
typedef struct nodeCDT *nodeADT;
X
/*
X * Function: NewGraph
X * Usage: graph = NewGraph();
X * --------------------------
X * This function returns a new graph with no nodes.
X */
X
graphADT NewGraph(void);
X
/*
X * Function: NewNode
X * Usage: node = NewNode(graph);
X * -----------------------------
X * This function creates a new node and adds it to the graph.
X */
X
nodeADT NewNode(graphADT graph);
X
/*
X * Function: Connect
X * Usage: Connect(n1, n2);
X * -----------------------
X * This function creates an arc from node n1 to n2.
X */
X
void Connect(nodeADT n1, nodeADT n2);
X
/*
X * Function: IsConnected
X * Usage: if (IsConnected(n1, n2)) . . .
X * -------------------------------------
X * This function returns TRUE if there is an arc from n1 to n2.
X */
X
bool IsConnected(nodeADT n1, nodeADT n2);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/16-Graphs/simple-graph.h' &&
  chmod 0644 'programs/16-Graphs/simple-graph.h' ||
  echo 'restore of programs/16-Graphs/simple-graph.h failed'
  shar_count="`wc -c < 'programs/16-Graphs/simple-graph.h'`"
  test 1146 -eq "$shar_count" ||
    echo "programs/16-Graphs/simple-graph.h: original size 1146, current size $shar_count"
fi
# ============= programs/16-Graphs/symtab.c ==============
if test -f 'programs/16-Graphs/symtab.c' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/16-Graphs/symtab.c (file already exists)'
else
  echo 'x - extracting programs/16-Graphs/symtab.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/16-Graphs/symtab.c' &&
/*
X * File: symtab.c
X * --------------
X * This file implements the symbol table abstraction.
X */
X
#include <stdio.h>
#include "genlib.h"
#include "strlib.h"
#include "symtab.h"
X
/*
X * Constants
X * ---------
X * NBuckets -- Number of buckets in the hash table
X */
X
#define NBuckets 101
X
/*
X * Type: cellT
X * -----------
X * This type defines a linked list cell for the symbol table.
X */
X
typedef struct cellT {
X    string key;
X    void *value;
X    struct cellT *link;
} cellT;
X
/*
X * Type: symtabCDT
X * ---------------
X * This type defines the underlying concrete representation for a
X * symtabADT.  These details are not relevant to and therefore
X * not exported to the client.  In this implementation, the
X * underlying structure is a hash table organized as an array of
X * "buckets," in which each bucket is a linked list of elements
X * that share the same hash code.
X */
X
struct symtabCDT {
X    cellT *buckets[NBuckets];
};
X
/* Private function declarations */
X
static void FreeBucketChain(cellT *cp);
static cellT *FindCell(cellT *cp, string s);
static int Hash(string s, int nBuckets);
X
/* Public entries */
X
symtabADT NewSymbolTable(void)
{
X    symtabADT table;
X    int i;
X
X    table = New(symtabADT);
X    for (i = 0; i < NBuckets; i++) {
X        table->buckets[i] = NULL;
X    }
X    return (table);
}
X
void FreeSymbolTable(symtabADT table)
{
X    int i;
X
X    for (i = 0; i < NBuckets; i++) {
X        FreeBucketChain(table->buckets[i]);
X    }
X    FreeBlock(table);
}
X
void Enter(symtabADT table, string key, void *value)
{
X    int bucket;
X    cellT *cp;
X
X    bucket = Hash(key, NBuckets);
X    cp = FindCell(table->buckets[bucket], key);
X    if (cp == NULL) {
X        cp = New(cellT *);
X        cp->key = CopyString(key);
X        cp->link = table->buckets[bucket];
X        table->buckets[bucket] = cp;
X    }
X    cp->value = value;
}
X
void *Lookup(symtabADT table, string key)
{
X    int bucket;
X    cellT *cp;
X
X    bucket = Hash(key, NBuckets);
X    cp = FindCell(table->buckets[bucket], key);
X    if (cp == NULL) return(UNDEFINED);
X    return (cp->value);
}
X
/*
X * Implementation notes: DeleteSymbol
X * ----------------------------------
X * The implementation of DeleteSymbol must search the hash
X * chain for an entry with a matching key and then delete that
X * entry from the chain.  To delete the cell, the code must have
X * a pointer to the preceding cell, which is maintained in pp.
X * The first cell in the list is a special case because there
X * is no previous cell; this case is identified by having NULL
X * as the value of pp.
X */
X
void DeleteSymbol(symtabADT table, string key)
{
X    int bucket;
X    cellT *cp, *pp;
X
X    bucket = Hash(key, NBuckets);
X    pp = NULL;
X    cp = table->buckets[bucket];
X    while (cp != NULL && !StringEqual(cp->key, key)) {
X        pp = cp;
X        cp = cp->link;
X    }
X    if (cp == NULL) return;
X    if (pp == NULL) {
X        table->buckets[bucket] = cp->link;
X    } else {
X        pp->link = cp->link;
X    }
X    FreeBlock(cp);
}
X
void MapSymbolTable(symtabFnT fn, symtabADT table,
X                    void *clientData)
{
X    int i;
X    cellT *cp;
X
X    for (i = 0; i < NBuckets; i++) {
X        for (cp = table->buckets[i]; cp != NULL; cp = cp->link) {
X            fn(cp->key, cp->value, clientData);
X        }
X    }
}
X
/* Private functions */
X
/*
X * Function: FreeBucketChain
X * Usage: FreeBucketChain(cp);
X * ---------------------------
X * This function takes a chain pointer and frees all the cells
X * in that chain.  Because the package makes copies of the keys,
X * this function must free the string storage as well.
X */
X
static void FreeBucketChain(cellT *cp)
{
X    cellT *next;
X
X    while (cp != NULL) {
X        next = cp->link;
X        FreeBlock(cp->key);
X        FreeBlock(cp);
X        cp = next;
X    }
}
X
/*
X * Function: FindCell
X * Usage: cp = FindCell(cp, key);
X * ------------------------------
X * This function finds a cell in the chain beginning at cp that
X * matches key.  If a match is found, a pointer to that cell is
X * returned.  If no match is found, the function returns NULL.
X */
X
static cellT *FindCell(cellT *cp, string key)
{
X    while (cp != NULL && !StringEqual(cp->key, key)) {
X        cp = cp->link;
X    }
X    return (cp);
}
X
/*
X * Function: Hash
X * Usage: bucket = Hash(key, nBuckets);
X * ------------------------------------
X * This function takes the key and uses it to derive a hash code,
X * which is an integer in the range [0, nBuckets - 1].  The hash
X * code is computed using a method called linear congruence.  The
X * choice of the value for Multiplier can have a significant effect
X * on the performance of the algorithm, but not on its correctness.
X */
X
#define Multiplier -1664117991L
X
static int Hash(string s, int nBuckets)
{
X    int i;
X    unsigned long hashcode;
X
X    hashcode = 0;
X    for (i = 0; s[i] != '\0'; i++) {
X        hashcode = hashcode * Multiplier + s[i];
X    }
X    return (hashcode % nBuckets);
}
SHAR_EOF
  $shar_touch -am 0903182097 'programs/16-Graphs/symtab.c' &&
  chmod 0644 'programs/16-Graphs/symtab.c' ||
  echo 'restore of programs/16-Graphs/symtab.c failed'
  shar_count="`wc -c < 'programs/16-Graphs/symtab.c'`"
  test 4897 -eq "$shar_count" ||
    echo "programs/16-Graphs/symtab.c: original size 4897, current size $shar_count"
fi
# ============= programs/16-Graphs/symtab.h ==============
if test -f 'programs/16-Graphs/symtab.h' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/16-Graphs/symtab.h (file already exists)'
else
  echo 'x - extracting programs/16-Graphs/symtab.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/16-Graphs/symtab.h' &&
/*
X * File: symtab.h
X * --------------
X * This interface exports a simple symbol table abstraction.
X */
X
#ifndef _symtab_h
#define _symtab_h
X
#include "genlib.h"
X
/*
X * Type: symtabADT
X * ---------------
X * This type is the ADT used to represent a symbol table.
X */
X
typedef struct symtabCDT *symtabADT;
X
/*
X * Type: symtabFnT
X * ---------------
X * This type defines the class of functions that can be used to
X * map over the entries in a symbol table.
X */
X
typedef void (*symtabFnT)(string key, void *value,
X                          void *clientData);
X
/* Exported entries */
X
/*
X * Function: NewSymbolTable
X * Usage: table = NewSymbolTable();
X * --------------------------------
X * This function allocates a new symbol table with no entries.
X */
X
symtabADT NewSymbolTable(void);
X
/*
X * Function: FreeSymbolTable
X * Usage: FreeSymbolTable(table);
X * ------------------------------
X * This function frees the storage associated with the symbol table.
X */
X
void FreeSymbolTable(symtabADT table);
X
/*
X * Function: Enter
X * Usage: Enter(table, key, value);
X * --------------------------------
X * This function associates key with value in the symbol table.
X * Each call to Enter supersedes any previous definition for key.
X */
X
void Enter(symtabADT table, string key, void *value);
X
/*
X * Function: Lookup
X * Usage: value = Lookup(table, key);
X * ----------------------------------
X * This function returns the value associated with key in the symbol
X * table, or UNDEFINED, if no such value exists.
X */
X
void *Lookup(symtabADT table, string key);
X
/*
X * Function: DeleteSymbol
X * Usage: DeleteSymbol(table, key);
X * --------------------------------
X * This function removes the most recent definition of key,
X * reexposing the previous one.  If no definition exists for
X * key, DeleteSymbol simply returns without taking any action.
X */
X
void DeleteSymbol(symtabADT table, string key);
X
/*
X * Function: MapSymbolTable
X * Usage: MapSymbolTable(fn, table, clientData);
X * ---------------------------------------------
X * This function goes through every entry in the symbol table
X * and calls the function fn, passing it the following arguments:
X * the current key, its associated value, and the clientData
X * pointer.  The clientData pointer allows the client to pass
X * additional state information to the function fn, if necessary.
X * If no clientData argument is required, this value should be NULL.
X */
X
void MapSymbolTable(symtabFnT fn, symtabADT table,
X                    void *clientData);
X
#endif
SHAR_EOF
  $shar_touch -am 0903182097 'programs/16-Graphs/symtab.h' &&
  chmod 0644 'programs/16-Graphs/symtab.h' ||
  echo 'restore of programs/16-Graphs/symtab.h failed'
  shar_count="`wc -c < 'programs/16-Graphs/symtab.h'`"
  test 2504 -eq "$shar_count" ||
    echo "programs/16-Graphs/symtab.h: original size 2504, current size $shar_count"
fi
# ============= programs/16-Graphs/Makefile ==============
if test -f 'programs/16-Graphs/Makefile' && test X"$1" != X"-c"; then
  echo 'x - skipping programs/16-Graphs/Makefile (file already exists)'
else
  echo 'x - extracting programs/16-Graphs/Makefile (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'programs/16-Graphs/Makefile' &&
# Makefile for programs in directory 16-Graphs
# ***************************************************************
X
PROGRAMS = \
X    gtest
X
# ***************************************************************
# Parameters to control Makefile operation
# Note that the gccx command script must be defined
X
CC = gccx
CFLAGS = 
X
# ***************************************************************
# Entry to bring the package up to date
X
all: $(PROGRAMS)
X
# ***************************************************************
# Standard entries to remove files from the directories
#    tidy    -- eliminate unwanted files
#    scratch -- delete derived files in preparation for rebuild
X
tidy:
X	rm -f ,* .,* *~ core a.out graphics.ps
X
scratch: tidy
X	rm -f *.o *.a $(PROGRAMS)
X
# ***************************************************************
# C compilations
X
adjmat-graph.o: adjmat-graph.c graph.h
X	$(CC) $(CFLAGS) -c adjmat-graph.c
X
bst.o: bst.c bst.h cmpfn.h
X	$(CC) $(CFLAGS) -c bst.c
X
cmdscan.o: cmdscan.c cmdscan.h scanadt.h symtab.h
X	$(CC) $(CFLAGS) -c cmdscan.c
X
cmpfn.o: cmpfn.c cmpfn.h
X	$(CC) $(CFLAGS) -c cmpfn.c
X
foreach.o: foreach.c foreach.h iterator.h
X	$(CC) $(CFLAGS) -c foreach.c
X
graph.o: graph.c foreach.h graph.h set.h
X	$(CC) $(CFLAGS) -c graph.c
X
gtest.o: gtest.c cmdscan.h cmpfn.h foreach.h graph.h iterator.h \
X         scanadt.h set.h symtab.h
X	$(CC) $(CFLAGS) -c gtest.c
X
iterator.o: iterator.c cmpfn.h iterator.h itertype.h
X	$(CC) $(CFLAGS) -c iterator.c
X
list.o: list.c list.h
X	$(CC) $(CFLAGS) -c list.c
X
scanadt.o: scanadt.c scanadt.h
X	$(CC) $(CFLAGS) -c scanadt.c
X
set.o: set.c bst.h set.h
X	$(CC) $(CFLAGS) -c set.c
X
simple-graph.o: simple-graph.c graph.h list.h
X	$(CC) $(CFLAGS) -c simple-graph.c
X
symtab.o: symtab.c symtab.h
X	$(CC) $(CFLAGS) -c symtab.c
X
X
# ***************************************************************
# Executable programs
X
gtest: gtest.o bst.o cmdscan.o cmpfn.o foreach.o graph.o iterator.o \
X       scanadt.o set.o symtab.o
X	$(CC) $(CFLAGS) -o gtest bst.o gtest.o cmdscan.o cmpfn.o foreach.o \
X                                 graph.o iterator.o scanadt.o set.o symtab.o
X
SHAR_EOF
  $shar_touch -am 0905214397 'programs/16-Graphs/Makefile' &&
  chmod 0644 'programs/16-Graphs/Makefile' ||
  echo 'restore of programs/16-Graphs/Makefile failed'
  shar_count="`wc -c < 'programs/16-Graphs/Makefile'`"
  test 2112 -eq "$shar_count" ||
    echo "programs/16-Graphs/Makefile: original size 2112, current size $shar_count"
fi
exit 0

